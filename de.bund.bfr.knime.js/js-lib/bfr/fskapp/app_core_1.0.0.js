(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.kidaLibrary = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":1,"buffer":3,"ieee754":26}],4:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var callBind = require('./');

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};

},{"./":5,"get-intrinsic":19}],5:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var GetIntrinsic = require('get-intrinsic');
var setFunctionLength = require('set-function-length');

var $TypeError = require('es-errors/type');
var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $defineProperty = require('es-define-property');
var $max = GetIntrinsic('%Math.max%');

module.exports = function callBind(originalFunction) {
	if (typeof originalFunction !== 'function') {
		throw new $TypeError('a function is required');
	}
	var func = $reflectApply(bind, $call, arguments);
	return setFunctionLength(
		func,
		1 + $max(0, originalFunction.length - (arguments.length - 1)),
		true
	);
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}

},{"es-define-property":8,"es-errors/type":14,"function-bind":18,"get-intrinsic":19,"set-function-length":37}],6:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],7:[function(require,module,exports){
'use strict';

var $defineProperty = require('es-define-property');

var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');

var gopd = require('gopd');

/** @type {import('.')} */
module.exports = function defineDataProperty(
	obj,
	property,
	value
) {
	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
		throw new $TypeError('`obj` must be an object or a function`');
	}
	if (typeof property !== 'string' && typeof property !== 'symbol') {
		throw new $TypeError('`property` must be a string or a symbol`');
	}
	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('`loose`, if provided, must be a boolean');
	}

	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
	var nonWritable = arguments.length > 4 ? arguments[4] : null;
	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
	var loose = arguments.length > 6 ? arguments[6] : false;

	/* @type {false | TypedPropertyDescriptor<unknown>} */
	var desc = !!gopd && gopd(obj, property);

	if ($defineProperty) {
		$defineProperty(obj, property, {
			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
			value: value,
			writable: nonWritable === null && desc ? desc.writable : !nonWritable
		});
	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
		obj[property] = value; // eslint-disable-line no-param-reassign
	} else {
		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
	}
};

},{"es-define-property":8,"es-errors/syntax":13,"es-errors/type":14,"gopd":20}],8:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

/** @type {import('.')} */
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;

},{"get-intrinsic":19}],9:[function(require,module,exports){
'use strict';

/** @type {import('./eval')} */
module.exports = EvalError;

},{}],10:[function(require,module,exports){
'use strict';

/** @type {import('.')} */
module.exports = Error;

},{}],11:[function(require,module,exports){
'use strict';

/** @type {import('./range')} */
module.exports = RangeError;

},{}],12:[function(require,module,exports){
'use strict';

/** @type {import('./ref')} */
module.exports = ReferenceError;

},{}],13:[function(require,module,exports){
'use strict';

/** @type {import('./syntax')} */
module.exports = SyntaxError;

},{}],14:[function(require,module,exports){
'use strict';

/** @type {import('./type')} */
module.exports = TypeError;

},{}],15:[function(require,module,exports){
'use strict';

/** @type {import('./uri')} */
module.exports = URIError;

},{}],16:[function(require,module,exports){
module.exports = stringify
stringify.default = stringify
stringify.stable = deterministicStringify
stringify.stableStringify = deterministicStringify

var LIMIT_REPLACE_NODE = '[...]'
var CIRCULAR_REPLACE_NODE = '[Circular]'

var arr = []
var replacerStack = []

function defaultOptions () {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  }
}

// Regular stringify
function stringify (obj, replacer, spacer, options) {
  if (typeof options === 'undefined') {
    options = defaultOptions()
  }

  decirc(obj, '', 0, [], undefined, 0, options)
  var res
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(obj, replacer, spacer)
    } else {
      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer)
    }
  } catch (_) {
    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop()
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3])
      } else {
        part[0][part[1]] = part[2]
      }
    }
  }
  return res
}

function setReplace (replace, val, k, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k)
  if (propertyDescriptor.get !== undefined) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent, k, { value: replace })
      arr.push([parent, k, val, propertyDescriptor])
    } else {
      replacerStack.push([val, k, replace])
    }
  } else {
    parent[k] = replace
    arr.push([parent, k, val])
  }
}

function decirc (val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1
  var i
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)
        return
      }
    }

    if (
      typeof options.depthLimit !== 'undefined' &&
      depth > options.depthLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    if (
      typeof options.edgesLimit !== 'undefined' &&
      edgeIndex + 1 > options.edgesLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    stack.push(val)
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, i, stack, val, depth, options)
      }
    } else {
      var keys = Object.keys(val)
      for (i = 0; i < keys.length; i++) {
        var key = keys[i]
        decirc(val[key], key, i, stack, val, depth, options)
      }
    }
    stack.pop()
  }
}

// Stable-stringify
function compareFunction (a, b) {
  if (a < b) {
    return -1
  }
  if (a > b) {
    return 1
  }
  return 0
}

function deterministicStringify (obj, replacer, spacer, options) {
  if (typeof options === 'undefined') {
    options = defaultOptions()
  }

  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj
  var res
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(tmp, replacer, spacer)
    } else {
      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer)
    }
  } catch (_) {
    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
  } finally {
    // Ensure that we restore the object as it was.
    while (arr.length !== 0) {
      var part = arr.pop()
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3])
      } else {
        part[0][part[1]] = part[2]
      }
    }
  }
  return res
}

function deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1
  var i
  if (typeof val === 'object' && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)
        return
      }
    }
    try {
      if (typeof val.toJSON === 'function') {
        return
      }
    } catch (_) {
      return
    }

    if (
      typeof options.depthLimit !== 'undefined' &&
      depth > options.depthLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    if (
      typeof options.edgesLimit !== 'undefined' &&
      edgeIndex + 1 > options.edgesLimit
    ) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent)
      return
    }

    stack.push(val)
    // Optimize for Arrays. Big arrays could kill the performance otherwise!
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        deterministicDecirc(val[i], i, i, stack, val, depth, options)
      }
    } else {
      // Create a temporary object in the required way
      var tmp = {}
      var keys = Object.keys(val).sort(compareFunction)
      for (i = 0; i < keys.length; i++) {
        var key = keys[i]
        deterministicDecirc(val[key], key, i, stack, val, depth, options)
        tmp[key] = val[key]
      }
      if (typeof parent !== 'undefined') {
        arr.push([parent, k, val])
        parent[k] = tmp
      } else {
        return tmp
      }
    }
    stack.pop()
  }
}

// wraps replacer function to handle values we couldn't replace
// and mark them as replaced value
function replaceGetterValues (replacer) {
  replacer =
    typeof replacer !== 'undefined'
      ? replacer
      : function (k, v) {
        return v
      }
  return function (key, val) {
    if (replacerStack.length > 0) {
      for (var i = 0; i < replacerStack.length; i++) {
        var part = replacerStack[i]
        if (part[1] === key && part[0] === val) {
          val = part[2]
          replacerStack.splice(i, 1)
          break
        }
      }
    }
    return replacer.call(this, key, val)
  }
}

},{}],17:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],18:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":17}],19:[function(require,module,exports){
'use strict';

var undefined;

var $Error = require('es-errors');
var $EvalError = require('es-errors/eval');
var $RangeError = require('es-errors/range');
var $ReferenceError = require('es-errors/ref');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $URIError = require('es-errors/uri');

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();
var hasProto = require('has-proto')();

var getProto = Object.getPrototypeOf || (
	hasProto
		? function (x) { return x.__proto__; } // eslint-disable-line no-proto
		: null
);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('hasown');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

},{"es-errors":10,"es-errors/eval":9,"es-errors/range":11,"es-errors/ref":12,"es-errors/syntax":13,"es-errors/type":14,"es-errors/uri":15,"function-bind":18,"has-proto":22,"has-symbols":23,"hasown":25}],20:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;

},{"get-intrinsic":19}],21:[function(require,module,exports){
'use strict';

var $defineProperty = require('es-define-property');

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	return !!$defineProperty;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!$defineProperty) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;

},{"es-define-property":8}],22:[function(require,module,exports){
'use strict';

var test = {
	__proto__: null,
	foo: {}
};

var $Object = Object;

/** @type {import('.')} */
module.exports = function hasProto() {
	// @ts-expect-error: TS errors on an inherited property for some reason
	return { __proto__: test }.foo === test.foo
		&& !(test instanceof $Object);
};

},{}],23:[function(require,module,exports){
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

},{"./shams":24}],24:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{}],25:[function(require,module,exports){
'use strict';

var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = require('function-bind');

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);

},{"function-bind":18}],26:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],27:[function(require,module,exports){
(function (global){(function (){
var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = require('./util.inspect');
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function (value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function (value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */
    if (typeof window !== 'undefined' && obj === window) {
        return '{ [object Window] }';
    }
    if (obj === global) {
        return '{ [object globalThis] }';
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./util.inspect":2}],28:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],29:[function(require,module,exports){
'use strict';

var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};

},{}],30:[function(require,module,exports){
'use strict';

var stringify = require('./stringify');
var parse = require('./parse');
var formats = require('./formats');

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};

},{"./formats":29,"./parse":31,"./stringify":32}],31:[function(require,module,exports){
'use strict';

var utils = require('./utils');

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the  character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the  character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };

    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        var existing = has.call(obj, key);
        if (existing && options.duplicates === 'combine') {
            obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === 'last') {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = options.allowEmptyArrays && leaf === '' ? [] : [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
            var index = parseInt(decodedRoot, 10);
            if (!options.parseArrays && decodedRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== decodedRoot
                && String(index) === decodedRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (decodedRoot !== '__proto__') {
                obj[decodedRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;

    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
        throw new TypeError('The duplicates option must be either combine, first, or last');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        duplicates: duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};

},{"./utils":33}],32:[function(require,module,exports){
'use strict';

var getSideChannel = require('side-channel');
var utils = require('./utils');
var formats = require('./formats');
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: 'indices',
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    allowEmptyArrays,
    strictNullHandling,
    skipNulls,
    encodeDotInKeys,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, '%2E') : prefix;

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;

    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + '[]';
    }

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, '%2E') : key;
        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            allowEmptyArrays,
            strictNullHandling,
            skipNulls,
            encodeDotInKeys,
            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if ('indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = defaults.arrayFormat;
    }

    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat: arrayFormat,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.allowEmptyArrays,
            options.strictNullHandling,
            options.skipNulls,
            options.encodeDotInKeys,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};

},{"./formats":29,"./utils":33,"side-channel":38}],33:[function(require,module,exports){
'use strict';

var formats = require('./formats');

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var limit = 1024;

/* eslint operator-linebreak: [2, "before"] */

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];

        for (var i = 0; i < segment.length; ++i) {
            var c = segment.charCodeAt(i);
            if (
                c === 0x2D // -
                || c === 0x2E // .
                || c === 0x5F // _
                || c === 0x7E // ~
                || (c >= 0x30 && c <= 0x39) // 0-9
                || (c >= 0x41 && c <= 0x5A) // a-z
                || (c >= 0x61 && c <= 0x7A) // A-Z
                || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
            ) {
                arr[arr.length] = segment.charAt(i);
                continue;
            }

            if (c < 0x80) {
                arr[arr.length] = hexTable[c];
                continue;
            }

            if (c < 0x800) {
                arr[arr.length] = hexTable[0xC0 | (c >> 6)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            if (c < 0xD800 || c >= 0xE000) {
                arr[arr.length] = hexTable[0xE0 | (c >> 12)]
                    + hexTable[0x80 | ((c >> 6) & 0x3F)]
                    + hexTable[0x80 | (c & 0x3F)];
                continue;
            }

            i += 1;
            c = 0x10000 + (((c & 0x3FF) << 10) | (segment.charCodeAt(i) & 0x3FF));

            arr[arr.length] = hexTable[0xF0 | (c >> 18)]
                + hexTable[0x80 | ((c >> 12) & 0x3F)]
                + hexTable[0x80 | ((c >> 6) & 0x3F)]
                + hexTable[0x80 | (c & 0x3F)];
        }

        out += arr.join('');
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};

},{"./formats":29}],34:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],35:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],36:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":34,"./encode":35}],37:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');
var define = require('define-data-property');
var hasDescriptors = require('has-property-descriptors')();
var gOPD = require('gopd');

var $TypeError = require('es-errors/type');
var $floor = GetIntrinsic('%Math.floor%');

/** @type {import('.')} */
module.exports = function setFunctionLength(fn, length) {
	if (typeof fn !== 'function') {
		throw new $TypeError('`fn` is not a function');
	}
	if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
		throw new $TypeError('`length` must be a positive 32-bit integer');
	}

	var loose = arguments.length > 2 && !!arguments[2];

	var functionLengthIsConfigurable = true;
	var functionLengthIsWritable = true;
	if ('length' in fn && gOPD) {
		var desc = gOPD(fn, 'length');
		if (desc && !desc.configurable) {
			functionLengthIsConfigurable = false;
		}
		if (desc && !desc.writable) {
			functionLengthIsWritable = false;
		}
	}

	if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
		if (hasDescriptors) {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
		} else {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
		}
	}
	return fn;
};

},{"define-data-property":7,"es-errors/type":14,"get-intrinsic":19,"gopd":20,"has-property-descriptors":21}],38:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBound = require('call-bind/callBound');
var inspect = require('object-inspect');

var $TypeError = require('es-errors/type');
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);

var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list. By doing so, all the recently used nodes can be accessed relatively quickly.
*/
/** @type {import('.').listGetNode} */
var listGetNode = function (list, key) { // eslint-disable-line consistent-return
	/** @type {typeof list | NonNullable<(typeof list)['next']>} */
	var prev = list;
	/** @type {(typeof list)['next']} */
	var curr;
	for (; (curr = prev.next) !== null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			// eslint-disable-next-line no-extra-parens
			curr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);
			list.next = curr; // eslint-disable-line no-param-reassign
			return curr;
		}
	}
};

/** @type {import('.').listGet} */
var listGet = function (objects, key) {
	var node = listGetNode(objects, key);
	return node && node.value;
};
/** @type {import('.').listSet} */
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = /** @type {import('.').ListNode<typeof value>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens
			key: key,
			next: objects.next,
			value: value
		});
	}
};
/** @type {import('.').listHas} */
var listHas = function (objects, key) {
	return !!listGetNode(objects, key);
};

/** @type {import('.')} */
module.exports = function getSideChannel() {
	/** @type {WeakMap<object, unknown>} */ var $wm;
	/** @type {Map<object, unknown>} */ var $m;
	/** @type {import('.').RootNode<unknown>} */ var $o;

	/** @type {import('.').Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapGet($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapGet($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listGet($o, key);
				}
			}
		},
		has: function (key) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapHas($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapHas($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listHas($o, key);
				}
			}
			return false;
		},
		set: function (key, value) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if (!$wm) {
					$wm = new $WeakMap();
				}
				$weakMapSet($wm, key, value);
			} else if ($Map) {
				if (!$m) {
					$m = new $Map();
				}
				$mapSet($m, key, value);
			} else {
				if (!$o) {
					// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
					$o = { key: {}, next: null };
				}
				listSet($o, key, value);
			}
		}
	};
	return channel;
};

},{"call-bind/callBound":4,"es-errors/type":14,"get-intrinsic":19,"object-inspect":27}],39:[function(require,module,exports){
"use strict";

const defaults = ['use', 'on', 'once', 'set', 'query', 'type', 'accept', 'auth', 'withCredentials', 'sortQuery', 'retry', 'ok', 'redirects', 'timeout', 'buffer', 'serialize', 'parse', 'ca', 'key', 'pfx', 'cert', 'disableTLSCerts'];
class Agent {
  constructor() {
    this._defaults = [];
  }
  _setDefaults(request) {
    for (const def of this._defaults) {
      request[def.fn](...def.args);
    }
  }
}
for (const fn of defaults) {
  // Default setting for all requests from this agent
  Agent.prototype[fn] = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    this._defaults.push({
      fn,
      args
    });
    return this;
  };
}
module.exports = Agent;

},{}],40:[function(require,module,exports){
"use strict";

/**
 * Root reference for iframes.
 */

let root;
if (typeof window !== 'undefined') {
  // Browser window
  root = window;
} else if (typeof self === 'undefined') {
  // Other environments
  console.warn('Using browser-only version of superagent in non-browser environment');
  root = void 0;
} else {
  // Web Worker
  root = self;
}
const Emitter = require('component-emitter');
const safeStringify = require('fast-safe-stringify');
const qs = require('qs');
const RequestBase = require('./request-base');
const {
  isObject,
  mixin,
  hasOwn
} = require('./utils');
const ResponseBase = require('./response-base');
const Agent = require('./agent-base');

/**
 * Noop.
 */

function noop() {}

/**
 * Expose `request`.
 */

module.exports = function (method, url) {
  // callback
  if (typeof url === 'function') {
    return new exports.Request('GET', method).end(url);
  }

  // url first
  if (arguments.length === 1) {
    return new exports.Request('GET', method);
  }
  return new exports.Request(method, url);
};
exports = module.exports;
const request = exports;
exports.Request = Request;

/**
 * Determine XHR.
 */

request.getXHR = () => {
  if (root.XMLHttpRequest) {
    return new root.XMLHttpRequest();
  }
  throw new Error('Browser-only version of superagent could not find XHR');
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

const trim = ''.trim ? s => s.trim() : s => s.replace(/(^\s*|\s*$)/g, '');

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(object) {
  if (!isObject(object)) return object;
  const pairs = [];
  for (const key in object) {
    if (hasOwn(object, key)) pushEncodedKeyValuePair(pairs, key, object[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, value) {
  if (value === undefined) return;
  if (value === null) {
    pairs.push(encodeURI(key));
    return;
  }
  if (Array.isArray(value)) {
    for (const v of value) {
      pushEncodedKeyValuePair(pairs, key, v);
    }
  } else if (isObject(value)) {
    for (const subkey in value) {
      if (hasOwn(value, subkey)) pushEncodedKeyValuePair(pairs, `${key}[${subkey}]`, value[subkey]);
    }
  } else {
    pairs.push(encodeURI(key) + '=' + encodeURIComponent(value));
  }
}

/**
 * Expose serialization method.
 */

request.serializeObject = serialize;

/**
 * Parse the given x-www-form-urlencoded `str`.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseString(string_) {
  const object = {};
  const pairs = string_.split('&');
  let pair;
  let pos;
  for (let i = 0, length_ = pairs.length; i < length_; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos === -1) {
      object[decodeURIComponent(pair)] = '';
    } else {
      object[decodeURIComponent(pair.slice(0, pos))] = decodeURIComponent(pair.slice(pos + 1));
    }
  }
  return object;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  form: 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': qs.stringify,
  'application/json': safeStringify
};

/**
 * Default parsers.
 *
 *     superagent.parse['application/xml'] = function(str){
 *       return { object parsed from str };
 *     };
 *
 */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(string_) {
  const lines = string_.split(/\r?\n/);
  const fields = {};
  let index;
  let line;
  let field;
  let value;
  for (let i = 0, length_ = lines.length; i < length_; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    if (index === -1) {
      // could be empty line, just skip it
      continue;
    }
    field = line.slice(0, index).toLowerCase();
    value = trim(line.slice(index + 1));
    fields[field] = value;
  }
  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[/+]json($|[^-\w])/i.test(mime);
}

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(request_) {
  this.req = request_;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = this.req.method !== 'HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text') || typeof this.xhr.responseType === 'undefined' ? this.xhr.responseText : null;
  this.statusText = this.req.xhr.statusText;
  let {
    status
  } = this.xhr;
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }
  this._setStatusProperties(status);
  this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  this.header = this.headers;
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);
  if (this.text === null && request_._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method === 'HEAD' ? null : this._parseBody(this.text ? this.text : this.xhr.response);
  }
}
mixin(Response.prototype, ResponseBase.prototype);

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function (string_) {
  let parse = request.parse[this.type];
  if (this.req._parser) {
    return this.req._parser(this, string_);
  }
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && string_ && (string_.length > 0 || string_ instanceof Object) ? parse(string_) : null;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function () {
  const {
    req
  } = this;
  const {
    method
  } = req;
  const {
    url
  } = req;
  const message = `cannot ${method} ${url} (${this.status})`;
  const error = new Error(message);
  error.status = this.status;
  error.method = method;
  error.url = url;
  return error;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  const self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', () => {
    let error = null;
    let res = null;
    try {
      res = new Response(self);
    } catch (err) {
      error = new Error('Parser is unable to parse the response');
      error.parse = true;
      error.original = err;
      // issue #675: return the raw response if the response parsing fails
      if (self.xhr) {
        // ie9 doesn't have 'response' property
        error.rawResponse = typeof self.xhr.responseType === 'undefined' ? self.xhr.responseText : self.xhr.response;
        // issue #876: return the http status code if the response parsing fails
        error.status = self.xhr.status ? self.xhr.status : null;
        error.statusCode = error.status; // backwards-compat only
      } else {
        error.rawResponse = null;
        error.status = null;
      }
      return self.callback(error);
    }
    self.emit('response', res);
    let new_error;
    try {
      if (!self._isResponseOK(res)) {
        new_error = new Error(res.statusText || res.text || 'Unsuccessful HTTP response');
      }
    } catch (err) {
      new_error = err; // ok() callback can throw
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_error) {
      new_error.original = error;
      new_error.response = res;
      new_error.status = new_error.status || res.status;
      self.callback(new_error, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `RequestBase`.
 */

// eslint-disable-next-line new-cap
Emitter(Request.prototype);
mixin(Request.prototype, RequestBase.prototype);

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function (type) {
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function (type) {
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function (user, pass, options) {
  if (arguments.length === 1) pass = '';
  if (typeof pass === 'object' && pass !== null) {
    // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }
  if (!options) {
    options = {
      type: typeof btoa === 'function' ? 'basic' : 'auto'
    };
  }
  const encoder = options.encoder ? options.encoder : string => {
    if (typeof btoa === 'function') {
      return btoa(string);
    }
    throw new Error('Cannot use basic auth, btoa is not a function');
  };
  return this._auth(user, pass, options, encoder);
};

/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.query = function (value) {
  if (typeof value !== 'string') value = serialize(value);
  if (value) this._query.push(value);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function (field, file, options) {
  if (file) {
    if (this._data) {
      throw new Error("superagent can't mix .send() and .attach()");
    }
    this._getFormData().append(field, file, options || file.name);
  }
  return this;
};
Request.prototype._getFormData = function () {
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function (error, res) {
  if (this._shouldRetry(error, res)) {
    return this._retry();
  }
  const fn = this._callback;
  this.clearTimeout();
  if (error) {
    if (this._maxRetries) error.retries = this._retries - 1;
    this.emit('error', error);
  }
  fn(error, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function () {
  const error = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  error.crossDomain = true;
  error.status = this.status;
  error.method = this.method;
  error.url = this.url;
  this.callback(error);
};

// This only warns, because the request is still likely to work
Request.prototype.agent = function () {
  console.warn('This is not supported in browser version of superagent');
  return this;
};
Request.prototype.ca = Request.prototype.agent;
Request.prototype.buffer = Request.prototype.ca;

// This throws, because it can't send/receive data as expected
Request.prototype.write = () => {
  throw new Error('Streaming is not supported in browser version of superagent');
};
Request.prototype.pipe = Request.prototype.write;

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj host object
 * @return {Boolean} is a host object
 * @api private
 */
Request.prototype._isHost = function (object) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return object && typeof object === 'object' && !Array.isArray(object) && Object.prototype.toString.call(object) !== '[object Object]';
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function (fn) {
  if (this._endCalled) {
    console.warn('Warning: .end() was called twice. This is not supported in superagent');
  }
  this._endCalled = true;

  // store callback
  this._callback = fn || noop;

  // querystring
  this._finalizeQueryString();
  this._end();
};
Request.prototype._setUploadTimeout = function () {
  const self = this;

  // upload timeout it's wokrs only if deadline timeout is off
  if (this._uploadTimeout && !this._uploadTimeoutTimer) {
    this._uploadTimeoutTimer = setTimeout(() => {
      self._timeoutError('Upload timeout of ', self._uploadTimeout, 'ETIMEDOUT');
    }, this._uploadTimeout);
  }
};

// eslint-disable-next-line complexity
Request.prototype._end = function () {
  if (this._aborted) return this.callback(new Error('The request has been aborted even before .end() was called'));
  const self = this;
  this.xhr = request.getXHR();
  const {
    xhr
  } = this;
  let data = this._formData || this._data;
  this._setTimeouts();

  // state change
  xhr.addEventListener('readystatechange', () => {
    const {
      readyState
    } = xhr;
    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }
    if (readyState !== 4) {
      return;
    }

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    let status;
    try {
      status = xhr.status;
    } catch (err) {
      status = 0;
    }
    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  });

  // progress
  const handleProgress = (direction, e) => {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
      if (e.percent === 100) {
        clearTimeout(self._uploadTimeoutTimer);
      }
    }
    e.direction = direction;
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    try {
      xhr.addEventListener('progress', handleProgress.bind(null, 'download'));
      if (xhr.upload) {
        xhr.upload.addEventListener('progress', handleProgress.bind(null, 'upload'));
      }
    } catch (err) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }
  if (xhr.upload) {
    this._setUploadTimeout();
  }

  // initiate request
  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if (!this._formData && this.method !== 'GET' && this.method !== 'HEAD' && typeof data !== 'string' && !this._isHost(data)) {
    // serialize stuff
    const contentType = this._header['content-type'];
    let serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (const field in this.header) {
    if (this.header[field] === null) continue;
    if (hasOwn(this.header, field)) xhr.setRequestHeader(field, this.header[field]);
  }
  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data === 'undefined' ? null : data);
};
request.agent = () => new Agent();
for (const method of ['GET', 'POST', 'OPTIONS', 'PATCH', 'PUT', 'DELETE']) {
  Agent.prototype[method.toLowerCase()] = function (url, fn) {
    const request_ = new request.Request(method, url);
    this._setDefaults(request_);
    if (fn) {
      request_.end(fn);
    }
    return request_;
  };
}
Agent.prototype.del = Agent.prototype.delete;

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = (url, data, fn) => {
  const request_ = request('GET', url);
  if (typeof data === 'function') {
    fn = data;
    data = null;
  }
  if (data) request_.query(data);
  if (fn) request_.end(fn);
  return request_;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = (url, data, fn) => {
  const request_ = request('HEAD', url);
  if (typeof data === 'function') {
    fn = data;
    data = null;
  }
  if (data) request_.query(data);
  if (fn) request_.end(fn);
  return request_;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = (url, data, fn) => {
  const request_ = request('OPTIONS', url);
  if (typeof data === 'function') {
    fn = data;
    data = null;
  }
  if (data) request_.send(data);
  if (fn) request_.end(fn);
  return request_;
};

/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, data, fn) {
  const request_ = request('DELETE', url);
  if (typeof data === 'function') {
    fn = data;
    data = null;
  }
  if (data) request_.send(data);
  if (fn) request_.end(fn);
  return request_;
}
request.del = del;
request.delete = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = (url, data, fn) => {
  const request_ = request('PATCH', url);
  if (typeof data === 'function') {
    fn = data;
    data = null;
  }
  if (data) request_.send(data);
  if (fn) request_.end(fn);
  return request_;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = (url, data, fn) => {
  const request_ = request('POST', url);
  if (typeof data === 'function') {
    fn = data;
    data = null;
  }
  if (data) request_.send(data);
  if (fn) request_.end(fn);
  return request_;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = (url, data, fn) => {
  const request_ = request('PUT', url);
  if (typeof data === 'function') {
    fn = data;
    data = null;
  }
  if (data) request_.send(data);
  if (fn) request_.end(fn);
  return request_;
};

},{"./agent-base":39,"./request-base":41,"./response-base":42,"./utils":43,"component-emitter":6,"fast-safe-stringify":16,"qs":30}],41:[function(require,module,exports){
(function (process){(function (){
"use strict";

const semver = require('semver');

/**
 * Module of mixed-in functions shared between node and client code
 */
const {
  isObject,
  hasOwn
} = require('./utils');

/**
 * Expose `RequestBase`.
 */

module.exports = RequestBase;

/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase() {}

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.clearTimeout = function () {
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  clearTimeout(this._uploadTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  delete this._uploadTimeoutTimer;
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.parse = function (fn) {
  this._parser = fn;
  return this;
};

/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.responseType = function (value) {
  this._responseType = value;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.serialize = function (fn) {
  this._serializer = fn;
  return this;
};

/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 * - upload is the time  since last bit of data was sent or received. This timeout works only if deadline timeout is off
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.timeout = function (options) {
  if (!options || typeof options !== 'object') {
    this._timeout = options;
    this._responseTimeout = 0;
    this._uploadTimeout = 0;
    return this;
  }
  for (const option in options) {
    if (hasOwn(options, option)) {
      switch (option) {
        case 'deadline':
          this._timeout = options.deadline;
          break;
        case 'response':
          this._responseTimeout = options.response;
          break;
        case 'upload':
          this._uploadTimeout = options.upload;
          break;
        default:
          console.warn('Unknown timeout option', option);
      }
    }
  }
  return this;
};

/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.retry = function (count, fn) {
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

//
// NOTE: we do not include ESOCKETTIMEDOUT because that is from `request` package
//       <https://github.com/sindresorhus/got/pull/537>
//
// NOTE: we do not include EADDRINFO because it was removed from libuv in 2014
//       <https://github.com/libuv/libuv/commit/02e1ebd40b807be5af46343ea873331b2ee4e9c1>
//       <https://github.com/request/request/search?q=ESOCKETTIMEDOUT&unscoped_q=ESOCKETTIMEDOUT>
//
//
// TODO: expose these as configurable defaults
//
const ERROR_CODES = new Set(['ETIMEDOUT', 'ECONNRESET', 'EADDRINUSE', 'ECONNREFUSED', 'EPIPE', 'ENOTFOUND', 'ENETUNREACH', 'EAI_AGAIN']);
const STATUS_CODES = new Set([408, 413, 429, 500, 502, 503, 504, 521, 522, 524]);

// TODO: we would need to make this easily configurable before adding it in (e.g. some might want to add POST)
// const METHODS = new Set(['GET', 'PUT', 'HEAD', 'DELETE', 'OPTIONS', 'TRACE']);

/**
 * Determine if a request should be retried.
 * (Inspired by https://github.com/sindresorhus/got#retry)
 *
 * @param {Error} err an error
 * @param {Response} [res] response
 * @returns {Boolean} if segment should be retried
 */
RequestBase.prototype._shouldRetry = function (error, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }
  if (this._retryCallback) {
    try {
      const override = this._retryCallback(error, res);
      if (override === true) return true;
      if (override === false) return false;
      // undefined falls back to defaults
    } catch (err) {
      console.error(err);
    }
  }

  // TODO: we would need to make this easily configurable before adding it in (e.g. some might want to add POST)
  /*
  if (
    this.req &&
    this.req.method &&
    !METHODS.has(this.req.method.toUpperCase())
  )
    return false;
  */
  if (res && res.status && STATUS_CODES.has(res.status)) return true;
  if (error) {
    if (error.code && ERROR_CODES.has(error.code)) return true;
    // Superagent timeout
    if (error.timeout && error.code === 'ECONNABORTED') return true;
    if (error.crossDomain) return true;
  }
  return false;
};

/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */

RequestBase.prototype._retry = function () {
  this.clearTimeout();

  // node
  if (this.req) {
    this.req = null;
    this.req = this.request();
  }
  this._aborted = false;
  this.timedout = false;
  this.timedoutError = null;
  return this._end();
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */

RequestBase.prototype.then = function (resolve, reject) {
  if (!this._fullfilledPromise) {
    const self = this;
    if (this._endCalled) {
      console.warn('Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises');
    }
    this._fullfilledPromise = new Promise((resolve, reject) => {
      self.on('abort', () => {
        if (this._maxRetries && this._maxRetries > this._retries) {
          return;
        }
        if (this.timedout && this.timedoutError) {
          reject(this.timedoutError);
          return;
        }
        const error = new Error('Aborted');
        error.code = 'ABORTED';
        error.status = this.status;
        error.method = this.method;
        error.url = this.url;
        reject(error);
      });
      self.end((error, res) => {
        if (error) reject(error);else resolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
};
RequestBase.prototype.catch = function (callback) {
  return this.then(undefined, callback);
};

/**
 * Allow for extension
 */

RequestBase.prototype.use = function (fn) {
  fn(this);
  return this;
};
RequestBase.prototype.ok = function (callback) {
  if (typeof callback !== 'function') throw new Error('Callback required');
  this._okCallback = callback;
  return this;
};
RequestBase.prototype._isResponseOK = function (res) {
  if (!res) {
    return false;
  }
  if (this._okCallback) {
    return this._okCallback(res);
  }
  return res.status >= 200 && res.status < 300;
};

/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

RequestBase.prototype.get = function (field) {
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

RequestBase.prototype.getHeader = RequestBase.prototype.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function (field, value) {
  if (isObject(field)) {
    for (const key in field) {
      if (hasOwn(field, key)) this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = value;
  this.header[field] = value;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field field name
 */
RequestBase.prototype.unset = function (field) {
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name name of field
 * @param {String|Blob|File|Buffer|fs.ReadStream} val value of field
 * @param {String} options extra options, e.g. 'blob'
 * @return {Request} for chaining
 * @api public
 */
RequestBase.prototype.field = function (name, value, options) {
  // name should be either a string or an object.
  if (name === null || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }
  if (this._data) {
    throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }
  if (isObject(name)) {
    for (const key in name) {
      if (hasOwn(name, key)) this.field(key, name[key]);
    }
    return this;
  }
  if (Array.isArray(value)) {
    for (const i in value) {
      if (hasOwn(value, i)) this.field(name, value[i]);
    }
    return this;
  }

  // val should be defined now
  if (value === null || undefined === value) {
    throw new Error('.field(name, val) val can not be empty');
  }
  if (typeof value === 'boolean') {
    value = String(value);
  }

  // fix https://github.com/ladjs/superagent/issues/1680
  if (options) this._getFormData().append(name, value, options);else this._getFormData().append(name, value);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request} request
 * @api public
 */
RequestBase.prototype.abort = function () {
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  if (this.xhr) this.xhr.abort(); // browser
  if (this.req) {
    // Node v13 has major differences in `abort()`
    // https://github.com/nodejs/node/blob/v12.x/lib/internal/streams/end-of-stream.js
    // https://github.com/nodejs/node/blob/v13.x/lib/internal/streams/end-of-stream.js
    // https://github.com/nodejs/node/blob/v14.x/lib/internal/streams/end-of-stream.js
    // (if you run a diff across these you will see the differences)
    //
    // References:
    // <https://github.com/nodejs/node/issues/31630>
    // <https://github.com/ladjs/superagent/pull/1084/commits/dc18679a7c5ccfc6046d882015e5126888973bc8>
    //
    // Thanks to @shadowgate15 and @niftylettuce
    if (semver.gte(process.version, 'v13.0.0') && semver.lt(process.version, 'v14.0.0')) {
      // Note that the reason this doesn't work is because in v13 as compared to v14
      // there is no `callback = nop` set in end-of-stream.js above
      throw new Error('Superagent does not work in v13 properly with abort() due to Node.js core changes');
    }
    this.req.abort(); // node
  }
  this.clearTimeout();
  this.emit('abort');
  return this;
};
RequestBase.prototype._auth = function (user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', `Basic ${base64Encoder(`${user}:${pass}`)}`);
      break;
    case 'auto':
      this.username = user;
      this.password = pass;
      break;
    case 'bearer':
      // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', `Bearer ${user}`);
      break;
    default:
      break;
  }
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 * @param {Boolean} [on=true] - Set 'withCredentials' state
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.withCredentials = function (on) {
  // This is browser-only functionality. Node side is no-op.
  if (on === undefined) on = true;
  this._withCredentials = on;
  return this;
};

/**
 * Set the max redirects to `n`. Does nothing in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.redirects = function (n) {
  this._maxRedirects = n;
  return this;
};

/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n number of bytes
 * @return {Request} for chaining
 */
RequestBase.prototype.maxResponseSize = function (n) {
  if (typeof n !== 'number') {
    throw new TypeError('Invalid argument');
  }
  this._maxResponseSize = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

RequestBase.prototype.toJSON = function () {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

// eslint-disable-next-line complexity
RequestBase.prototype.send = function (data) {
  const isObject_ = isObject(data);
  let type = this._header['content-type'];
  if (this._formData) {
    throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }
  if (isObject_ && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw new Error("Can't merge these send calls");
  }

  // merge
  if (isObject_ && isObject(this._data)) {
    for (const key in data) {
      if (typeof data[key] == 'bigint' && !data[key].toJSON) throw new Error('Cannot serialize BigInt value to json');
      if (hasOwn(data, key)) this._data[key] = data[key];
    }
  } else if (typeof data === 'bigint') throw new Error("Cannot send value of type BigInt");else if (typeof data === 'string') {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if (type) type = type.toLowerCase().trim();
    if (type === 'application/x-www-form-urlencoded') {
      this._data = this._data ? `${this._data}&${data}` : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }
  if (!isObject_ || this._isHost(data)) {
    return this;
  }

  // default to json
  if (!type) this.type('json');
  return this;
};

/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.sortQuery = function (sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */
RequestBase.prototype._finalizeQueryString = function () {
  const query = this._query.join('&');
  if (query) {
    this.url += (this.url.includes('?') ? '&' : '?') + query;
  }
  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    const index = this.url.indexOf('?');
    if (index >= 0) {
      const queryArray = this.url.slice(index + 1).split('&');
      if (typeof this._sort === 'function') {
        queryArray.sort(this._sort);
      } else {
        queryArray.sort();
      }
      this.url = this.url.slice(0, index) + '?' + queryArray.join('&');
    }
  }
};

// For backwards compat only
RequestBase.prototype._appendQueryString = () => {
  console.warn('Unsupported');
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

RequestBase.prototype._timeoutError = function (reason, timeout, errno) {
  if (this._aborted) {
    return;
  }
  const error = new Error(`${reason + timeout}ms exceeded`);
  error.timeout = timeout;
  error.code = 'ECONNABORTED';
  error.errno = errno;
  this.timedout = true;
  this.timedoutError = error;
  this.abort();
  this.callback(error);
};
RequestBase.prototype._setTimeouts = function () {
  const self = this;

  // deadline
  if (this._timeout && !this._timer) {
    this._timer = setTimeout(() => {
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  }

  // response timeout
  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(() => {
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};

}).call(this)}).call(this,require('_process'))
},{"./utils":43,"_process":28,"semver":2}],42:[function(require,module,exports){
"use strict";

/**
 * Module dependencies.
 */

const utils = require('./utils');

/**
 * Expose `ResponseBase`.
 */

module.exports = ResponseBase;

/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase() {}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

ResponseBase.prototype.get = function (field) {
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

ResponseBase.prototype._setHeaderProperties = function (header) {
  // TODO: moar!
  // TODO: make this a util

  // content-type
  const ct = header['content-type'] || '';
  this.type = utils.type(ct);

  // params
  const parameters = utils.params(ct);
  for (const key in parameters) {
    if (Object.prototype.hasOwnProperty.call(parameters, key)) this[key] = parameters[key];
  }
  this.links = {};

  // links
  try {
    if (header.link) {
      this.links = utils.parseLinks(header.link);
    }
  } catch (err) {
    // ignore
  }
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

ResponseBase.prototype._setStatusProperties = function (status) {
  const type = Math.trunc(status / 100);

  // status / class
  this.statusCode = status;
  this.status = this.statusCode;
  this.statusType = type;

  // basics
  this.info = type === 1;
  this.ok = type === 2;
  this.redirect = type === 3;
  this.clientError = type === 4;
  this.serverError = type === 5;
  this.error = type === 4 || type === 5 ? this.toError() : false;

  // sugar
  this.created = status === 201;
  this.accepted = status === 202;
  this.noContent = status === 204;
  this.badRequest = status === 400;
  this.unauthorized = status === 401;
  this.notAcceptable = status === 406;
  this.forbidden = status === 403;
  this.notFound = status === 404;
  this.unprocessableEntity = status === 422;
};

},{"./utils":43}],43:[function(require,module,exports){
"use strict";

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = string_ => string_.split(/ *; */).shift();

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.params = value => {
  const object = {};
  for (const string_ of value.split(/ *; */)) {
    const parts = string_.split(/ *= */);
    const key = parts.shift();
    const value = parts.shift();
    if (key && value) object[key] = value;
  }
  return object;
};

/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.parseLinks = value => {
  const object = {};
  for (const string_ of value.split(/ *, */)) {
    const parts = string_.split(/ *; */);
    const url = parts[0].slice(1, -1);
    const rel = parts[1].split(/ *= */)[1].slice(1, -1);
    object[rel] = url;
  }
  return object;
};

/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */

exports.cleanHeader = (header, changesOrigin) => {
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header.host;
  // secuirty
  if (changesOrigin) {
    delete header.authorization;
    delete header.cookie;
  }
  return header;
};

/**
 * Check if `obj` is an object.
 *
 * @param {Object} object
 * @return {Boolean}
 * @api private
 */
exports.isObject = object => {
  return object !== null && typeof object === 'object';
};

/**
 * Object.hasOwn fallback/polyfill.
 *
 * @type {(object: object, property: string) => boolean} object
 * @api private
 */
exports.hasOwn = Object.hasOwn || function (object, property) {
  if (object == null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }
  return Object.prototype.hasOwnProperty.call(new Object(object), property);
};
exports.mixin = (target, source) => {
  for (const key in source) {
    if (exports.hasOwn(source, key)) {
      target[key] = source[key];
    }
  }
};

},{}],44:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ApiClient = void 0;
var _superagent = _interopRequireDefault(require("superagent"));
var _querystring = _interopRequireDefault(require("querystring"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
* @module ApiClient
* @version 1.0.0
*/
/**
* Manages low level client-server communications, parameter marshalling, etc. There should not be any need for an
* application to use this class directly - the *Api and model classes provide the public API for the service. The
* contents of this file should be regarded as internal but are documented for completeness.
* @alias module:ApiClient
* @class
*/
var ApiClient = exports.ApiClient = /*#__PURE__*/function () {
  function ApiClient() {
    _classCallCheck(this, ApiClient);
    /**
     * The base URL against which to resolve every API call's (relative) path.
     * @type {String}
     * @default /
     */
    this.basePath = '/'.replace(/\/+$/, '');

    /**
     * The authentication methods to be included for all API calls.
     * @type {Array.<String>}
     */
    this.authentications = {};

    /**
     * The default HTTP headers to be included for all API calls.
     * @type {Array.<String>}
     * @default {}
     */
    this.defaultHeaders = {};

    /**
     * The default HTTP timeout for all API calls.
     * @type {Number}
     * @default 60000
     */
    this.timeout = 60000;

    /**
     * If set to false an additional timestamp parameter is added to all API GET calls to
     * prevent browser caching
     * @type {Boolean}
     * @default true
     */
    this.cache = true;

    /**
     * If set to true, the client will save the cookies from each server
     * response, and return them in the next request.
     * @default false
     */
    this.enableCookies = false;

    /*
     * Used to save and return cookies in a node.js (non-browser) setting,
     * if this.enableCookies is set to true.
     */
    if (typeof window === 'undefined') {
      this.agent = new _superagent.default.agent();
    }

    /*
     * Allow user to override superagent agent
     */
    this.requestAgent = null;
  }

  /**
  * Returns a string representation for an actual parameter.
  * @param param The actual parameter.
  * @returns {String} The string representation of <code>param</code>.
  */
  return _createClass(ApiClient, [{
    key: "paramToString",
    value: function paramToString(param) {
      if (param == undefined || param == null) {
        return '';
      }
      if (param instanceof Date) {
        return param.toJSON();
      }
      return param.toString();
    }

    /**
    * Builds full URL by appending the given path to the base URL and replacing path parameter place-holders with parameter values.
    * NOTE: query parameters are not handled here.
    * @param {String} path The path to append to the base URL.
    * @param {Object} pathParams The parameter values to append.
    * @returns {String} The encoded path with parameter values substituted.
    */
  }, {
    key: "buildUrl",
    value: function buildUrl(path, pathParams) {
      var _this = this;
      if (!path.match(/^\//)) {
        path = '/' + path;
      }
      var url = this.basePath + path;
      url = url.replace(/\{([\w-]+)\}/g, function (fullMatch, key) {
        var value;
        if (pathParams.hasOwnProperty(key)) {
          value = _this.paramToString(pathParams[key]);
        } else {
          value = fullMatch;
        }
        return encodeURIComponent(value);
      });
      return url;
    }

    /**
    * Checks whether the given content type represents JSON.<br>
    * JSON content type examples:<br>
    * <ul>
    * <li>application/json</li>
    * <li>application/json; charset=UTF8</li>
    * <li>APPLICATION/JSON</li>
    * </ul>
    * @param {String} contentType The MIME content type to check.
    * @returns {Boolean} <code>true</code> if <code>contentType</code> represents JSON, otherwise <code>false</code>.
    */
  }, {
    key: "isJsonMime",
    value: function isJsonMime(contentType) {
      return Boolean(contentType != null && contentType.match(/^application\/json(;.*)?$/i));
    }

    /**
    * Chooses a content type from the given array, with JSON preferred; i.e. return JSON if included, otherwise return the first.
    * @param {Array.<String>} contentTypes
    * @returns {String} The chosen content type, preferring JSON.
    */
  }, {
    key: "jsonPreferredMime",
    value: function jsonPreferredMime(contentTypes) {
      for (var i = 0; i < contentTypes.length; i++) {
        if (this.isJsonMime(contentTypes[i])) {
          return contentTypes[i];
        }
      }
      return contentTypes[0];
    }

    /**
    * Checks whether the given parameter value represents file-like content.
    * @param param The parameter to check.
    * @returns {Boolean} <code>true</code> if <code>param</code> represents a file.
    */
  }, {
    key: "isFileParam",
    value: function isFileParam(param) {
      // fs.ReadStream in Node.js and Electron (but not in runtime like browserify)
      if (typeof require === 'function') {
        var fs;
        try {
          fs = require('fs');
        } catch (err) {}
        if (fs && fs.ReadStream && param instanceof fs.ReadStream) {
          return true;
        }
      }

      // Buffer in Node.js
      if (typeof Buffer === 'function' && param instanceof Buffer) {
        return true;
      }

      // Blob in browser
      if (typeof Blob === 'function' && param instanceof Blob) {
        return true;
      }

      // File in browser (it seems File object is also instance of Blob, but keep this for safe)
      if (typeof File === 'function' && param instanceof File) {
        return true;
      }
      return false;
    }

    /**
    * Normalizes parameter values:
    * <ul>
    * <li>remove nils</li>
    * <li>keep files and arrays</li>
    * <li>format to string with `paramToString` for other cases</li>
    * </ul>
    * @param {Object.<String, Object>} params The parameters as object properties.
    * @returns {Object.<String, Object>} normalized parameters.
    */
  }, {
    key: "normalizeParams",
    value: function normalizeParams(params) {
      var newParams = {};
      for (var key in params) {
        if (params.hasOwnProperty(key) && params[key] != undefined && params[key] != null) {
          var value = params[key];
          if (this.isFileParam(value) || Array.isArray(value)) {
            newParams[key] = value;
          } else {
            newParams[key] = this.paramToString(value);
          }
        }
      }
      return newParams;
    }

    /**
    * Enumeration of collection format separator strategies.
    * @enum {String}
    * @readonly
    */
  }, {
    key: "buildCollectionParam",
    value:
    /**
    * Builds a string representation of an array-type actual parameter, according to the given collection format.
    * @param {Array} param An array parameter.
    * @param {module:ApiClient.CollectionFormatEnum} collectionFormat The array element separator strategy.
    * @returns {String|Array} A string representation of the supplied collection, using the specified delimiter. Returns
    * <code>param</code> as is if <code>collectionFormat</code> is <code>multi</code>.
    */
    function buildCollectionParam(param, collectionFormat) {
      if (param == null) {
        return null;
      }
      switch (collectionFormat) {
        case 'csv':
          return param.map(this.paramToString).join(',');
        case 'ssv':
          return param.map(this.paramToString).join(' ');
        case 'tsv':
          return param.map(this.paramToString).join('\t');
        case 'pipes':
          return param.map(this.paramToString).join('|');
        case 'multi':
          //return the array directly as SuperAgent will handle it as expected
          return param.map(this.paramToString);
        default:
          throw new Error('Unknown collection format: ' + collectionFormat);
      }
    }

    /**
    * Applies authentication headers to the request.
    * @param {Object} request The request object created by a <code>superagent()</code> call.
    * @param {Array.<String>} authNames An array of authentication method names.
    */
  }, {
    key: "applyAuthToRequest",
    value: function applyAuthToRequest(request, authNames) {
      var _this2 = this;
      authNames.forEach(function (authName) {
        var auth = _this2.authentications[authName];
        switch (auth.type) {
          case 'basic':
            if (auth.username || auth.password) {
              request.auth(auth.username || '', auth.password || '');
            }
            break;
          case 'apiKey':
            if (auth.apiKey) {
              var data = {};
              if (auth.apiKeyPrefix) {
                data[auth.name] = auth.apiKeyPrefix + ' ' + auth.apiKey;
              } else {
                data[auth.name] = auth.apiKey;
              }
              if (auth['in'] === 'header') {
                request.set(data);
              } else {
                request.query(data);
              }
            }
            break;
          case 'oauth2':
            if (auth.accessToken) {
              request.set({
                'Authorization': 'Bearer ' + auth.accessToken
              });
            }
            break;
          default:
            throw new Error('Unknown authentication type: ' + auth.type);
        }
      });
    }

    /**
    * Deserializes an HTTP response body into a value of the specified type.
    * @param {Object} response A SuperAgent response object.
    * @param {(String|Array.<String>|Object.<String, Object>|Function)} returnType The type to return. Pass a string for simple types
    * or the constructor function for a complex type. Pass an array containing the type name to return an array of that type. To
    * return an object, pass an object with one property whose name is the key type and whose value is the corresponding value type:
    * all properties on <code>data<code> will be converted to this type.
    * @returns A value of the specified type.
    */
  }, {
    key: "deserialize",
    value: function deserialize(response, returnType) {
      if (response == null || returnType == null || response.status == 204) {
        return null;
      }

      // Rely on SuperAgent for parsing response body.
      // See http://visionmedia.github.io/superagent/#parsing-response-bodies
      var data = response.body;
      if (data == null || _typeof(data) === 'object' && typeof data.length === 'undefined' && !Object.keys(data).length) {
        // SuperAgent does not always produce a body; use the unparsed response as a fallback
        data = response.text;
      }
      return ApiClient.convertToType(data, returnType);
    }

    /**
    * Callback function to receive the result of the operation.
    * @callback module:ApiClient~callApiCallback
    * @param {String} error Error message, if any.
    * @param data The data returned by the service call.
    * @param {String} response The complete HTTP response.
    */

    /**
    * Invokes the REST service using the supplied settings and parameters.
    * @param {String} path The base URL to invoke.
    * @param {String} httpMethod The HTTP method to use.
    * @param {Object.<String, String>} pathParams A map of path parameters and their values.
    * @param {Object.<String, Object>} queryParams A map of query parameters and their values.
    * @param {Object.<String, Object>} headerParams A map of header parameters and their values.
    * @param {Object.<String, Object>} formParams A map of form parameters and their values.
    * @param {Object} bodyParam The value to pass as the request body.
    * @param {Array.<String>} authNames An array of authentication type names.
    * @param {Array.<String>} contentTypes An array of request MIME types.
    * @param {Array.<String>} accepts An array of acceptable response MIME types.
    * @param {(String|Array|ObjectFunction)} returnType The required type to return; can be a string for simple types or the
    * constructor for a complex type.
    * @param {module:ApiClient~callApiCallback} callback The callback function.
    * @returns {Object} The SuperAgent request object.
    */
  }, {
    key: "callApi",
    value: function callApi(path, httpMethod, pathParams, queryParams, headerParams, formParams, bodyParam, authNames, contentTypes, accepts, returnType, callback) {
      var _this3 = this;
      var url = this.buildUrl(path, pathParams);
      var request = (0, _superagent.default)(httpMethod, url);

      // apply authentications
      this.applyAuthToRequest(request, authNames);

      // set query parameters
      if (httpMethod.toUpperCase() === 'GET' && this.cache === false) {
        queryParams['_'] = new Date().getTime();
      }
      request.query(this.normalizeParams(queryParams));

      // set header parameters
      request.set(this.defaultHeaders).set(this.normalizeParams(headerParams));

      // set requestAgent if it is set by user
      if (this.requestAgent) {
        request.agent(this.requestAgent);
      }

      // set request timeout
      request.timeout(this.timeout);
      var contentType = this.jsonPreferredMime(contentTypes);
      if (contentType) {
        // Issue with superagent and multipart/form-data (https://github.com/visionmedia/superagent/issues/746)
        if (contentType != 'multipart/form-data') {
          request.type(contentType);
        }
      } else if (!request.header['Content-Type']) {
        request.type('application/json');
      }
      if (contentType === 'application/x-www-form-urlencoded') {
        request.send(_querystring.default.stringify(this.normalizeParams(formParams)));
      } else if (contentType == 'multipart/form-data') {
        var _formParams = this.normalizeParams(formParams);
        for (var key in _formParams) {
          if (_formParams.hasOwnProperty(key)) {
            if (this.isFileParam(_formParams[key])) {
              // file field
              request.attach(key, _formParams[key]);
            } else {
              request.field(key, _formParams[key]);
            }
          }
        }
      } else if (bodyParam) {
        request.send(bodyParam);
      }
      var accept = this.jsonPreferredMime(accepts);
      if (accept) {
        request.accept(accept);
      }
      if (returnType === 'Blob') {
        request.responseType('blob');
      } else if (returnType === 'String') {
        request.responseType('string');
      }

      // Attach previously saved cookies, if enabled
      if (this.enableCookies) {
        if (typeof window === 'undefined') {
          this.agent.attachCookies(request);
        } else {
          request.withCredentials();
        }
      }
      request.end(function (error, response) {
        if (callback) {
          var data = null;
          if (!error) {
            try {
              data = _this3.deserialize(response, returnType);
              if (_this3.enableCookies && typeof window === 'undefined') {
                _this3.agent.saveCookies(response);
              }
            } catch (err) {
              error = err;
            }
          }
          callback(error, data, response);
        }
      });
      return request;
    }

    /**
    * Parses an ISO-8601 string representation of a date value.
    * @param {String} str The date value as a string.
    * @returns {Date} The parsed date object.
    */
  }], [{
    key: "parseDate",
    value: function parseDate(str) {
      return new Date(str);
    }

    /**
    * Converts a value to the specified type.
    * @param {(String|Object)} data The data to convert, as a string or object.
    * @param {(String|Array.<String>|Object.<String, Object>|Function)} type The type to return. Pass a string for simple types
    * or the constructor function for a complex type. Pass an array containing the type name to return an array of that type. To
    * return an object, pass an object with one property whose name is the key type and whose value is the corresponding value type:
    * all properties on <code>data<code> will be converted to this type.
    * @returns An instance of the specified type or null or undefined if data is null or undefined.
    */
  }, {
    key: "convertToType",
    value: function convertToType(data, type) {
      if (data === null || data === undefined) return data;
      switch (type) {
        case 'Boolean':
          return Boolean(data);
        case 'Integer':
          return parseInt(data, 10);
        case 'Number':
          return parseFloat(data);
        case 'String':
          return String(data);
        case 'Date':
          return ApiClient.parseDate(String(data));
        case 'Blob':
          return data;
        default:
          if (type === Object) {
            // generic object, return directly
            return data;
          } else if (typeof type === 'function') {
            // for model type like: User
            return type.constructFromObject(data);
          } else if (Array.isArray(type)) {
            // for array type like: ['String']
            var itemType = type[0];
            return data.map(function (item) {
              return ApiClient.convertToType(item, itemType);
            });
          } else if (_typeof(type) === 'object') {
            // for plain object type like: {'String': 'Integer'}
            var keyType, valueType;
            for (var k in type) {
              if (type.hasOwnProperty(k)) {
                keyType = k;
                valueType = type[k];
                break;
              }
            }
            var result = {};
            for (var k in data) {
              if (data.hasOwnProperty(k)) {
                var key = ApiClient.convertToType(k, keyType);
                var value = ApiClient.convertToType(data[k], valueType);
                result[key] = value;
              }
            }
            return result;
          } else {
            // for unknown type, return the data directly
            return data;
          }
      }
    }

    /**
    * Constructs a new map or array model from REST data.
    * @param data {Object|Array} The REST data.
    * @param obj {Object|Array} The target object or array.
    */
  }, {
    key: "constructFromObject",
    value: function constructFromObject(data, obj, itemType) {
      if (Array.isArray(data)) {
        for (var i = 0; i < data.length; i++) {
          if (data.hasOwnProperty(i)) obj[i] = ApiClient.convertToType(data[i], itemType);
        }
      } else {
        for (var k in data) {
          if (data.hasOwnProperty(k)) obj[k] = ApiClient.convertToType(data[k], itemType);
        }
      }
    }
  }]);
}();
/**
* The default API client implementation.
* @type {module:ApiClient}
*/
_defineProperty(ApiClient, "CollectionFormatEnum", {
  /**
   * Comma-separated values. Value: <code>csv</code>
   * @const
   */
  CSV: ',',
  /**
   * Space-separated values. Value: <code>ssv</code>
   * @const
   */
  SSV: ' ',
  /**
   * Tab-separated values. Value: <code>tsv</code>
   * @const
   */
  TSV: '\t',
  /**
   * Pipe(|)-separated values. Value: <code>pipes</code>
   * @const
   */
  PIPES: '|',
  /**
   * Native array. Value: <code>multi</code>
   * @const
   */
  MULTI: 'multi'
});
ApiClient.instance = new ApiClient();

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":3,"fs":2,"querystring":36,"superagent":40}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.APPLandingpage = void 0;
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/*

version: 1.0.0
author: sascha obermller
date: 04.12.2020

*/
var APPLandingpage = exports.APPLandingpage = /*#__PURE__*/function () {
  function APPLandingpage(settings, $container, metadata, uploadDates, executionTimes) {
    _classCallCheck(this, APPLandingpage);
    var O = this;
    O._metadata = metadata;
    O._uploadDates = uploadDates;
    O._executionTimes = executionTimes;
    O._$container = $container;
    O._debug = true;
    // defaults
    O._opts = $.extend(true, {}, {
      header: {
        brand: {
          logo: 'assets/img/bfr_logo.gif',
          // false
          title: 'FSK-Web Landing Page Test' // false or ''
        },
        nav: [{
          title: 'MenuItem',
          href: '#'
        }]
      },
      mainTable: {},
      on: {
        afterInit: null
      }
    }, settings);

    // basic init actions
    O._create();

    // callback
    if ($.isFunction(O.opts.on.afterInit)) {
      O.opts.on.afterInit.call(O);
    }
  }
  return _createClass(APPLandingpage, [{
    key: "opts",
    get: function get() {
      return this._opts;
    },
    set: function set(settings) {
      this._opts = $.extend(true, {}, this.opts, settings);
    }

    /**
     * CREATE
     * init main app
     */
  }, {
    key: "_create",
    value: (function () {
      var _create2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var O, mtSettings;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              O = this;
              _log('LANDINGPAGE / _create', 'primary');

              // header
              if (O.opts.header) {
                O._$header = O._createHeader(O.opts.header).appendTo(O._$container);
              }

              // endpoints defined?
              if (_typeof(window._endpoints) != (typeof undefined === "undefined" ? "undefined" : _typeof(undefined))) {
                // main table settings: merge with app opts
                mtSettings = $.extend(true, {}, {
                  endpoints: window._endpoints,
                  data: {
                    metadata: O._metadata,
                    uploadDates: O._uploadDates,
                    executionTimes: O._executionTimes
                  }
                }, O.opts.mainTable);
                O._mainTable = new APPTableMT(mtSettings, O._$container, O._metadata, O._uploadDates, O._executionTimes);

                // tooltips
                _appUI._initTooltips();
              } else {
                // error no endpoints
                _appUI._createAlert('Cannot create main table, no endpoints defined', {}, O._$container);
              }
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _create() {
        return _create2.apply(this, arguments);
      }
      return _create;
    }()
    /**
     * CREATE HEADER
     * @param {array} settingss
     */
    )
  }, {
    key: "_createHeader",
    value: function _createHeader(settings) {
      var O = this;
      _log('LANDINGPAGE / _create header');

      // header
      var $header = $('<header class="page-header"></header>');

      // navbar
      $header.navBar = $('<nav class="navbar navbar-expand">').appendTo($header);

      // header brand
      if (settings.brand) {
        $header.navBrand = $('<div class="navbar-brand"></div>').appendTo($header.navBar);

        // brand logo
        if (settings.brand.logo) {
          // logo
          $('<span class="brand-logo"><img src="' + settings.brand.logo + '" alt="" /></span>').appendTo($header.navBrand);
          // brand logo + title ? add divider 
          if (settings.brand.title) {
            $('<span class="brand-divider"></span>').appendTo($header.navBrand);
          }
        }
        // brand title
        if (settings.brand.title) {
          $('<span class="brand-typo">' + settings.brand.title + '</span>').appendTo($header.navBrand);
        }
      }

      // create header nav
      if (settings.nav && settings.nav.length > 0) {
        // nav
        $header.nav = $('<ul class="navbar-nav mt-2 mt-sm-0 ml-auto"></ul>').appendTo($header.navBar);

        // toggle
        $header.navToggle = $('<button id="menuToggle" class="action action-pure action-lg" data-toggle="dropdown" aria-expanded="false" role="button"><i class="feather icon-menu"></i></button>').appendTo($header.nav).wrap('<li class="nav-item"></li>').wrap('<div class="dropdown"></div>');

        // dropdown menu
        $header.navDropdownMenu = $('<div class="dropdown-menu dropdown-menu-right" aria-labeledby="menuToggle"></div>').insertAfter($header.navToggle);

        // dropdown items by opts
        $.each(settings.nav, function (i, link) {
          // set link target or default value _self?
          link.target = link.target ? link.target : '_self';
          // add links
          var $link = $('<a href="' + link.href + '" target="' + link.target + '" class="dropdown-item">' + link.title + '</a>').appendTo($header.navDropdownMenu);
        });
      }
      return $header;
    }
  }]);
}();

},{}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.APPMTDetails = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/*

version: 1.0.0
author: Ahmad Swaid
date: 17.12.2020

*/
var APPMTDetails = exports.APPMTDetails = /*#__PURE__*/function () {
  function APPMTDetails(settings, $container) {
    _classCallCheck(this, APPMTDetails);
    var O = this;
    // defaults maintable simulations modal
    O._$modalContent = $container;
    O._opts = $.extend(true, {}, {
      classes: '',
      data: null,
      on: {
        afterInit: null,
        // function
        show: function show(O, event) {
          O._updateModal(event);
        },
        // function
        hide: null // function
      }
    }, settings);
    O._create();
  }
  return _createClass(APPMTDetails, [{
    key: "opts",
    get: function get() {
      return this._opts;
    },
    set: function set(settings) {
      this._opts = $.extend(true, {}, this.opts, settings);
    }
    /**
     * CREATE
     * calls super class and sets _metadata
     */
  }, {
    key: "_create",
    value: function _create() {
      var O = this;
      _log('MODAL DETAILS / _create', 'primary');
      O._metadata = O.opts.data;
    }
    /**
     * CREATE MODAL
     * creates basic modal components: header and blank body
     */
  }, {
    key: "_createModelMetadataContent",
    value: function _createModelMetadataContent() {
      var O = this;
      _log('MODAL DETAILS / _createModelMetadataContent');
      // modal nav with tabs & search
      O._$modalNav = $('<div class="modal-body modal-nav"></div>').appendTo(O._$modalContent);
      O._navId = O._id + 'Nav';
      if (!O._$navBar) {
        O._$navBar = $('<nav class="navbar navbar-expand-sm row justify-content-start justify-content-md-between"></nav>').appendTo(O._$modalNav);

        // nav toggle
        var $navToggle = $('<button class="action action-pure mt-1 mb-1" type="button" data-toggle="collapse" aria-expanded="false" aria-label="Toggle navigation"><i class="feather icon-list"></i></button>').appendTo(O._$navBar).attr('data-target', '#' + O._navId).attr('aria-controls', O._navId).wrap('<div class="col-auto navbar-toggler order-1 modal-nav-toggler"></div>');

        // divider
        O._$navBar.append('<div class="col-divider order-2 d-block d-sm-none d-md-block"></div>');

        // nav search
        O._$navBar._$search = $('<input class="form-control form-control-plaintext search-input" type="search" placeholder="Search Details" aria-label="Search Details" />').appendTo(O._$navBar).attr('id', O._id + 'NavSearch').wrap('<div class="col col-xxs-auto order-2 modal-nav-search"></div>').wrap('<div class="search"></div>');

        // TO DO
        // search functionality

        // nav tabs
        O._$navBar._$nav = $('<ul class="nav nav-pointer pt-1 pt-md-0"></ul>').appendTo(O._$navBar).wrap('<div class="col-12 col-md-auto order-3 order-md-1 modal-nav-menu order-4"></div>').wrap('<div class="collapse navbar-collapse" id="' + O._navId + '"></div>');
      }

      // modal body
      O._createModalBody();
      O._$modalBody.addClass('p-0 modal-table');

      // content container
      O._$modalTabContent = $('<div class="tab-content h-100"></div>').appendTo(O._$modalBody);
    }

    /**
    * CREATE MODAL
    * creates basic modal components: header and blank body
    */
  }, {
    key: "_createModalBody",
    value: function _createModalBody() {
      var O = this;
      _log('MODAL / _createBody');
      O._$modalBody = $('<div class="modal-body"></div>').appendTo(O._$modalContent);
    }

    /**
    * BUILD PANEL
    * build PANEL content
    * @param {event} event 
    */
  }, {
    key: "_updateContent",
    value: (function () {
      var _updateContent2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_modelMetadata, _modelId) {
        var O;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              O = this;
              _log('PANEL MetaData / _updateContent');

              // clear tab-panes
              O._$modalTabContent.html('');

              // get appropiate modelMetadata modelHandler for the model type.
              _context.next = 5;
              return O._getModelHandler(_modelMetadata, _modelId);
            case 5:
              O._modelHandler = _context.sent;
              // populate nav
              O._populateModalNav(O._modelHandler, O._$navBar._$nav);

              // populate panel
              O._populateModalPanel(O._modelHandler);

              // activate first pane
              O._$navBar._$nav.find('.nav-link').first().addClass('active');
              O._$modalTabContent.find('.tab-pane').first().addClass('active');
            case 10:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _updateContent(_x, _x2) {
        return _updateContent2.apply(this, arguments);
      }
      return _updateContent;
    }()
    /**
     * POPULATE MODAL MENU
     * @param {object} Model
     */
    )
  }, {
    key: "_populateModalNav",
    value: function _populateModalNav(modelHandler) {
      var O = this;
      _log('MODAL DETAILS / _populateModalNav');
      _log(modelHandler);

      // clear nav
      O._$navBar._$nav.html('');

      // create nav items
      if (modelHandler && modelHandler._menu) {
        $.each(modelHandler._menu, function (i, menuMeta) {
          if (menuMeta.id == 'resources') return;
          var $navItem = null;
          if (menuMeta.submenus && menuMeta.submenus.length > 0) {
            $navItem = O._createNavItemDropdown(menuMeta).appendTo(O._$navBar._$nav);
          } else {
            //if(menuMeta.id !== 'modelScript' && menuMeta.id !== 'visualizationScript' && menuMeta.id !== 'readme'){
            var _$navItem = O._createNavItem(menuMeta).appendTo(O._$navBar._$nav);
            //}
          }
        });
      }
    }

    /**
     * POPULATE MODAL PANEL
     * @param {object} Model
     */
  }, {
    key: "_populateModalPanel",
    value: function _populateModalPanel(modelHandler) {
      var O = this;
      _log('MODAL DETAILS / _populateModalPanel');
      _log(modelHandler);

      // create panels
      if (modelHandler && modelHandler._menu && modelHandler._panels) {
        // get each menus id
        $.each(modelHandler._menu, function (i, menuMeta) {
          // dropdown nav item 
          if (menuMeta.id == 'resources') return;
          if (menuMeta.submenus && menuMeta.submenus.length > 0) {
            // iterate over submenus
            $.each(menuMeta.submenus, function (j, submenuMeta) {
              // panel meta data exists in handler
              if (submenuMeta.id in modelHandler._panels) {
                var cpanel = O._createPanel(submenuMeta, modelHandler);
                panel.appendTo(O._$modalTabContent);
              }
            });
          }
          // single nav item ? create panel
          else {
            if (menuMeta.id) {
              if (menuMeta.id in modelHandler._panels) {
                //if(menuMeta.id !== 'modelScript' && menuMeta.id !== 'visualizationScript' && menuMeta.id !== 'readme'){
                var cpanel = O._createPanel(menuMeta, modelHandler);
                cpanel.appendTo(O._$modalTabContent);
                //}
              }
            }
          }
        });
      }
    }

    /**
     * CREATE NAV ITEM DROPDOWN
     * @param {array} menuMeta: array of dropdown-items width 'id' and 'label'
     */
  }, {
    key: "_createNavItemDropdown",
    value: function _createNavItemDropdown(menuMeta) {
      var O = this;
      _log('MODAL DETAILS / _createTabNavItemDropdown: ' + menuMeta.label);
      var $navItem = $('<li class="nav-item dropdown"></li>');
      var $navLink = $('<a class="nav-link dropdown-toggle" role="button">' + menuMeta.label + '</a>').attr('href', '#').attr('aria-haspopup', true).attr('aria-expanded', false).attr('data-toggle', 'dropdown').appendTo($navItem);
      var $dropdown = $('<div class="dropdown-menu"></div>').appendTo($navItem);
      $.each(menuMeta.submenus, function (i, submenuMeta) {
        var $dropdownItem = $('<a class="dropdown-item" role="button">' + submenuMeta.label + '</a>').attr('href', '#' + submenuMeta.id).attr('aria-controls', '#' + submenuMeta.id).attr('data-toggle', 'tab').appendTo($dropdown);
      });
      return $navItem;
    }

    /**
     * CREATE NAV ITEM
     * @param {array} menuMeta
     */
  }, {
    key: "_createNavItem",
    value: function _createNavItem(menuMeta) {
      var O = this;
      _log('MODAL DETAILS / _createNavItem: ' + menuMeta.label);
      var $navItem = $('<li class="nav-item"></li>');
      var $navLink = $('<a class="nav-link" role="button">' + menuMeta.label + '</a>').attr('href', '#' + menuMeta.id).attr('aria-controls', '#' + menuMeta.id).attr('data-toggle', 'tab').appendTo($navItem);
      return $navItem;
    }

    /**
     * CREATE PANEL
     * create tab-pane for specific menu by selecting type and calling specific creation (simple, complex, plot)
     * @param {array} menu
     * @param {object} modelHandler: object of type Model
     */
  }, {
    key: "_createPanel",
    value: function _createPanel(menu, modelHandler) {
      var O = this;
      _log('MODAL DETAILS / _createPanel: ' + menu.id);
      var $panel = null;
      if (modelHandler && menu.id) {
        var panelMeta = modelHandler._panels[menu.id];
        // panel type
        if (panelMeta.type) {
          // complex
          if (panelMeta.type == 'complex') {
            $panel = O._createComplexPanel(menu, modelHandler);
          }
          // simple
          else if (panelMeta.type == 'simple') {
            $panel = O._createSimplePanel(menu, modelHandler);
          }
          // plot
          else if (panelMeta.type == 'plot') {
            $panel = O._createPlotPanel(menu, modelHandler);
          }
          // Model Script
          else if (panelMeta.type == 'modelScript') {
            $panel = O._createModelScriptPanel(menu, modelHandler);
          }
          // Visualization Script
          else if (panelMeta.type == 'visualizationScript') {
            $panel = O._createVisualizationScriptPanel(menu, modelHandler);
          }
          // readme
          else if (panelMeta.type == 'readme') {
            $panel = O._createReadmetPanel(menu, modelHandler);
          }
        }
      }
      return $panel;
    }

    /**
     * CREATE SIMPLE PANEL
     * create simple tab-pane for specific menu
     * table has property, value cols
     * @param {array} menu
     * @param {object} modelHandler: object of type Model
     */
  }, {
    key: "_createSimplePanel",
    value: function _createSimplePanel(menu, modelHandler) {
      var O = this;
      _log('MODAL DETAILS / _createSimplePanel: ' + menu.id);

      // tab-pane
      var $panel = $('<div class="tab-pane h-100" role="tabpanel"></div>').attr('id', menu.id);
      if (modelHandler && menu.id) {
        // get panel meta
        var panelMeta = modelHandler._panels[menu.id];

        // title
        $panel.append('<div class="panel-heading">' + menu.label + '</div>');

        // table settings
        var tableSettings = {
          cols: [{
            label: 'Property',
            field: 'property',
            classes: {
              th: null,
              td: 'td-label min-200'
            },
            sortable: true,
            switchable: false
          }, {
            label: 'Value',
            field: 'value',
            sortable: false,
            switchable: false
          }],
          tableData: [],
          responsive: false,
          showToggle: true
        };

        // set table row data
        if (panelMeta.metadata && panelMeta.schema) {
          $.each(panelMeta.schema, function (j, prop) {
            var rowData = {
              cells: []
            };
            // cell 1 label
            rowData.cells.push(prop.label);
            // cell 2 val
            var data = panelMeta.metadata[prop.id];
            if (prop.type == 'date') {
              data = _formatter['_metadataDate'].call(0, data);
            }
            if (prop.type == 'date-array') {
              data = _formatter['_metadataDateArray'].call(0, data);
              rowData.type = prop.type;
            }
            data = _checkUndefinedContent(data);
            rowData.cells.push(data);
            tableSettings.tableData.push(rowData);
          });
        }

        // create table
        var panelTable = new APPTable(tableSettings, $panel);
        $panel.data('table', panelTable);
      }
      ;
      return $panel;
    }

    /**
     * CREATE COMPLEX PANEL
     * create complex tab-pane for specific menu
     * table has in metadata and schema defined cols
     * @param {array} menu
     * @param {object} modelHandler: object of class Model
     */
  }, {
    key: "_createComplexPanel",
    value: function _createComplexPanel(menu, modelHandler) {
      var O = this;
      _log('MODAL DETAILS / _createComplexPanel: ' + menu.id);

      // tab-pane
      var $panel = $('<div class="tab-pane h-100" role="tabpanel"></div>').attr('id', menu.id);
      if (modelHandler && menu.id) {
        // get panel meta
        var panelMeta = modelHandler._panels[menu.id];

        // title
        $panel.append('<div class="panel-heading">' + menu.label + '</div>');

        // table settings
        var tableSettings = {
          cols: [],
          tableData: [],
          responsive: false,
          showToggle: true
        };

        // set table cols
        $.each(panelMeta.schema, function (i, prop) {
          tableSettings.cols.push({
            label: prop.label,
            field: prop.id,
            sortable: true,
            switchable: true
          });
        });

        // set table row data
        if (panelMeta.metadata && panelMeta.schema) {
          $.each(panelMeta.metadata, function (i, item) {
            // row each item
            var rowData = {
              cells: []
            };
            // cells
            $.each(panelMeta.schema, function (j, prop) {
              var data = item[prop.id];
              if (prop.type == 'date' || prop.type == 'year_date') {
                data = _formatter['_metadataDate'].call(0, data);
              }
              if (prop.type == 'date-array') {
                data = _formatter['_metadataDateArray'].call(0, data);
                rowData.type = prop.type;
              }
              data = _checkUndefinedContent(data);
              // cell each prop
              rowData.cells.push(data);
            });
            tableSettings.tableData.push(rowData);
          });
        }

        // create table
        var panelTable = new APPTable(tableSettings, $panel);
        $panel.data('table', panelTable);
      }
      ;
      return $panel;
    }

    /**
    	 * CREATE PLOT PANEL
    	 * create plot tab-pane for specific menu
    	 * @param {array} menu
    	 * @param {object} modelHandler: object of class Model
    	 */
  }, {
    key: "_createPlotPanel",
    value: function _createPlotPanel(menu, modelHandler) {
      var O = this;
      _log('MODAL DETAILS / _createPlotPanel');

      // tab-pane
      var $panel = $('<div class="tab-pane h-100" role="tabpanel"></div>').attr('id', menu.id);
      if (modelHandler && menu.id && modelHandler._img) {
        // get panel meta
        var panelMeta = modelHandler._panels[menu.id];

        // title
        $panel.append('<div class="panel-heading">' + menu.label + '</div>');
        var $plot = $('<figure class="figure"><svg width = "100%" height = "1500" >"' + modelHandler._img + '" </svg></figure>').appendTo($panel).wrap('<div class="panel-plot"></div>');
      }
      return $panel;
    }
    /**
     * CREATE Model Script PANEL
     * create Model Script tab-pane for specific menu
     * @param {array} menu
     * @param {object} modelHandler: object of class Model
     */
  }, {
    key: "_createModelScriptPanel",
    value: function _createModelScriptPanel(menu, modelHandler) {
      var O = this;
      _log('MODAL DETAILS / _createPlotPanel');

      // tab-pane
      var $panel = $('<div class="tab-pane h-100" role="tabpanel"></div>').attr('id', menu.id);
      if (modelHandler && menu.id && modelHandler._modelScript) {
        // get panel meta
        var panelMeta = modelHandler._panels[menu.id];

        // title
        $panel.append('<div class="panel-heading">' + menu.label + '</div>');
        var $script = $('<pre class="precss"></pre>').appendTo($panel).wrap('<div class="panel-plot"></div>');
        var lines = modelHandler._modelScript.split("\n");
        for (var i = 0; i < lines.length; i++) {
          $('<span class="line">' + lines[i] + '</span>').appendTo($script);
        }
      }
      return $panel;
    }
    /**
     * CREATE VISUALIZATION SCRIPT
     * create plot tab-pane for specific menu
     * @param {array} menu
     * @param {object} modelHandler: object of class Model
     */
  }, {
    key: "_createVisualizationScriptPanel",
    value: function _createVisualizationScriptPanel(menu, modelHandler) {
      var O = this;
      _log('MODAL DETAILS / _createPlotPanel');

      // tab-pane
      var $panel = $('<div class="tab-pane h-100" role="tabpanel"></div>').attr('id', menu.id);
      if (modelHandler && menu.id && modelHandler._visScript) {
        // get panel meta
        _log('ifffff visualizationScript: ' + modelHandler._visScript);
        var panelMeta = modelHandler._panels[menu.id];

        // title
        $panel.append('<div class="panel-heading">' + menu.label + '</div>');
        var $script = $('<pre class="precss"></pre>').appendTo($panel).wrap('<div class="panel-plot"></div>');
        var lines = modelHandler._visScript.split("\n");
        for (var i = 0; i < lines.length; i++) {
          $('<span class="line">' + lines[i] + '</span>').appendTo($script);
        }
      }
      return $panel;
    }
  }, {
    key: "_createReadmetPanel",
    value: function _createReadmetPanel(menu, modelHandler) {
      var O = this;
      _log('MODAL DETAILS / _createPlotPanel');

      // tab-pane
      var $panel = $('<div class="tab-pane h-100" role="tabpanel"></div>').attr('id', menu.id);
      if (modelHandler && menu.id && modelHandler.readme) {
        // get panel meta
        _log('ifffff visualizationScript: ' + modelHandler.readme);
        var panelMeta = modelHandler._panels[menu.id];

        // title
        $panel.append('<div class="panel-heading">' + menu.label + '</div>');
        var $script = $('<pre class="precssreadme"></pre>').appendTo($panel).wrap('<div class="panel-plot"></div>');
        var lines = modelHandler.readme.split("\n");
        for (var i = 0; i < lines.length; i++) {
          $('<span class="text-wrap">' + lines[i] + '</span>').appendTo($script);
        }
      }
      return $panel;
    }
    /**
     * GET MODEL HANDLER
     * returns model handler of class Model
     * @param {array} modelMetadata: metadata for specific id
     */
  }, {
    key: "_getModelHandler",
    value: (function () {
      var _getModelHandler2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(modelMetadata, modelId) {
        var O, modelHandler, imgUrl, modelScript, visScript;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              O = this;
              _log('MODAL DETAILS / _getModelHandler');
              modelHandler = null;
              if (!modelMetadata) {
                _context2.next = 29;
                break;
              }
              _context2.next = 6;
              return _fetchData._content(window._endpoints.image, modelMetadata.generalInformation.identifier);
            case 6:
              imgUrl = _context2.sent;
              if (!(!modelMetadata.modelscript && modelMetadata.modelscript != "")) {
                _context2.next = 13;
                break;
              }
              _context2.next = 10;
              return _fetchData._content(window._endpoints.modelscriptEndpoint, modelMetadata.generalInformation.identifier);
            case 10:
              modelScript = _context2.sent;
              _context2.next = 14;
              break;
            case 13:
              modelScript = modelMetadata.modelscript;
            case 14:
              if (!(!modelMetadata.visualization && modelMetadata.visualization != "")) {
                _context2.next = 20;
                break;
              }
              _context2.next = 17;
              return _fetchData._content(window._endpoints.visualizationscriptEndpoint, modelMetadata.generalInformation.identifier);
            case 17:
              visScript = _context2.sent;
              _context2.next = 21;
              break;
            case 20:
              visScript = modelMetadata.visualization;
            case 21:
              if (modelMetadata.readme) {
                _context2.next = 27;
                break;
              }
              _context2.next = 24;
              return _fetchData._content(window._endpoints.readmeEndpoint, modelMetadata.generalInformation.identifier);
            case 24:
              readme = _context2.sent;
              _context2.next = 28;
              break;
            case 27:
              readme = modelMetadata.readme;
            case 28:
              // get appropiate modelMetadata modelHandler for the model type.
              if (modelMetadata.modelType === 'genericModel') {
                modelHandler = new GenericModel(modelMetadata, imgUrl, false, modelScript, visScript, readme);
              } else if (modelMetadata.modelType === 'dataModel') {
                modelHandler = new DataModel(modelMetadata, imgUrl, false, modelScript, visScript, readme);
              } else if (modelMetadata.modelType === 'predictiveModel') {
                modelHandler = new PredictiveModel(modelMetadata, imgUrl, false, modelScript, visScript, readme);
              } else if (modelMetadata.modelType === 'otherModel') {
                modelHandler = new OtherModel(modelMetadata, imgUrl, false, modelScript, visScript, readme);
              } else if (modelMetadata.modelType === 'toxicologicalModel') {
                modelHandler = new ToxicologicalModel(modelMetadata, imgUrl, false, modelScript, visScript, readme);
              } else if (modelMetadata.modelType === 'doseResponseModel') {
                modelHandler = new DoseResponseModel(modelMetadata, imgUrl, false, modelScript, visScript, readme);
              } else if (modelMetadata.modelType === 'exposureModel') {
                modelHandler = new ExposureModel(modelMetadata, imgUrl, false, modelScript, visScript, readme);
              } else if (modelMetadata.modelType === 'processModel') {
                modelHandler = new ProcessModel(modelMetadata, imgUrl, false, modelScript, visScript, readme);
              } else if (modelMetadata.modelType === 'consumptionModel') {
                modelHandler = new ConsumptionModel(modelMetadata, imgUrl, false, modelScript, visScript, readme);
              } else if (modelMetadata.modelType === 'healthModel') {
                modelHandler = new HealthModel(modelMetadata, imgUrl, false, modelScript, visScript, readme);
              } else if (modelMetadata.modelType === 'riskModel') {
                modelHandler = new RiskModel(modelMetadata, imgUrl, false, modelScript, visScript, readme);
              } else if (modelMetadata.modelType === 'qraModel') {
                modelHandler = new QraModel(modelMetadata, imgUrl, false, modelScript, visScript, readme);
              } else {
                modelHandler = new GenericModel(modelMetadata, imgUrl, false, modelScript, visScript, readme);
              }
            case 29:
              return _context2.abrupt("return", modelHandler);
            case 30:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _getModelHandler(_x3, _x4) {
        return _getModelHandler2.apply(this, arguments);
      }
      return _getModelHandler;
    }())
  }]);
}();

},{}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.APPMTEditableDetails = void 0;
var _AssayView = require("../model/AssayView");
var _ConsumptionModelView = require("../model/ConsumptionModelView");
var _ConsumptionModelScopeView = require("../model/ConsumptionModelScopeView");
var _ContactView = require("../model/ContactView");
var _DataModelView = require("../model/DataModelView");
var _DataModelGeneralInformationView = require("../model/DataModelGeneralInformationView");
var _DataModelModelMathView = require("../model/DataModelModelMathView");
var _DietaryAssessmentMethodView = require("../model/DietaryAssessmentMethodView");
var _DoseResponseModelView = require("../model/DoseResponseModelView");
var _DoseResponseModelGeneralInformationView = require("../model/DoseResponseModelGeneralInformationView");
var _DoseResponseModelModelMathView = require("../model/DoseResponseModelModelMathView");
var _DoseResponseModelScopeView = require("../model/DoseResponseModelScopeView");
var _ExposureView = require("../model/ExposureView");
var _ExposureModelView = require("../model/ExposureModelView");
var _ExposureModelScopeView = require("../model/ExposureModelScopeView");
var _GenericModelView = require("../model/GenericModelView");
var _GenericModelDataBackgroundView = require("../model/GenericModelDataBackgroundView");
var _GenericModelGeneralInformationView = require("../model/GenericModelGeneralInformationView");
var _GenericModelModelMathView = require("../model/GenericModelModelMathView");
var _GenericModelScopeView = require("../model/GenericModelScopeView");
var _HazardView = require("../model/HazardView");
var _HealthModelView = require("../model/HealthModelView");
var _HealthModelScopeView = require("../model/HealthModelScopeView");
var _LaboratoryView = require("../model/LaboratoryView");
var _ModelView = require("../model/ModelView");
var _ModelCategoryView = require("../model/ModelCategoryView");
var _ModelEquationView = require("../model/ModelEquationView");
var _OtherModelView = require("../model/OtherModelView");
var _OtherModelDataBackgroundView = require("../model/OtherModelDataBackgroundView");
var _OtherModelGeneralInformationView = require("../model/OtherModelGeneralInformationView");
var _OtherModelModelMathView = require("../model/OtherModelModelMathView");
var _OtherModelScopeView = require("../model/OtherModelScopeView");
var _ParameterView = require("../model/ParameterView");
var _PopulationGroupView = require("../model/PopulationGroupView");
var _PredictiveModelView = require("../model/PredictiveModelView");
var _PredictiveModelDataBackgroundView = require("../model/PredictiveModelDataBackgroundView");
var _PredictiveModelGeneralInformationView = require("../model/PredictiveModelGeneralInformationView");
var _PredictiveModelModelMathView = require("../model/PredictiveModelModelMathView");
var _PredictiveModelScopeView = require("../model/PredictiveModelScopeView");
var _PredictiveModelScopeProductView = require("../model/PredictiveModelScopeProductView");
var _ProcessModelView = require("../model/ProcessModelView");
var _ProcessModelScopeView = require("../model/ProcessModelScopeView");
var _ProductView = require("../model/ProductView");
var _QraModelView = require("../model/QraModelView");
var _QualityMeasuresView = require("../model/QualityMeasuresView");
var _ReferenceView = require("../model/ReferenceView");
var _RiskModelView = require("../model/RiskModelView");
var _StudyView = require("../model/StudyView");
var _StudySampleView = require("../model/StudySampleView");
var _ToxicologicalModelView = require("../model/ToxicologicalModelView");
var _ToxicologicalModelScopeView = require("../model/ToxicologicalModelScopeView");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*

version: 1.0.0
author: Ahmad Swaid
date: 17.12.2020

*/
var APPMTEditableDetails = exports.APPMTEditableDetails = /*#__PURE__*/function () {
  function APPMTEditableDetails(settings, $container) {
    _classCallCheck(this, APPMTEditableDetails);
    var O = this;
    // defaults maintable modal
    O._$modalContent = $container;
    O._opts = $.extend(true, {}, {
      classes: '',
      data: null,
      on: {
        afterInit: null,
        // function
        show: function show(O, event) {
          O._updateModal(event);
        },
        // function
        hide: null // function
      }
    }, settings);
    O._create();
  }
  return _createClass(APPMTEditableDetails, [{
    key: "opts",
    get: function get() {
      var O = this;
      return O._opts;
    },
    set: function set(settings) {
      var O = this;
      O._opts = $.extend(true, {}, O.opts, settings);
    }
    /**
     * CREATE
     * calls super class and sets _metadata
     */
  }, {
    key: "_create",
    value: function _create() {
      var O = this;
      _log('MODAL DETAILS / _create', 'primary');
      O._metadata = O.opts.data;
    }
    /**
     * CREATE MODAL
     * creates basic modal components: header and blank body
     */
  }, {
    key: "_createModelMetadataContent",
    value: function _createModelMetadataContent() {
      var O = this;
      _log('MODAL DETAILS / _createModelMetadataContent');
      // modal nav with tabs & search
      O._$modalNav = $('<div class="modal-body modal-nav card-header"></div>').appendTo(O._$modalContent);
      O._navId = O._id + 'Nav';
      if (!O._$navBar) {
        O._$navBar = $('<nav class="navbar navbar-expand-sm row justify-content-start justify-content-md-between"></nav>').appendTo(O._$modalNav);

        // nav toggle
        var $navToggle = $('<button class="action action-pure mt-1 mb-1" type="button" data-toggle="collapse" aria-expanded="false" aria-label="Toggle navigation"><i class="feather icon-list"></i></button>').appendTo(O._$navBar).attr('data-target', '#' + O._navId).attr('aria-controls', O._navId).wrap('<div class="col-auto navbar-toggler order-1 modal-nav-toggler"></div>');

        // divider
        // O._$navBar.append('<div class="col-divider order-2 d-block d-sm-none d-md-block"></div>');

        // nav search
        /*O._$navBar._$search = $('<input class="form-control form-control-plaintext search-input" type="search" placeholder="Search Details" aria-label="Search Details" />')
            .appendTo(O._$navBar)
            .attr('id', O._id + 'NavSearch')
            .wrap('<div class="col col-xxs-auto order-2 modal-nav-search"></div>')
            .wrap('<div class="search"></div>');
        */

        // TO DO
        // search functionality

        // nav tabs
        O._$navBar._$nav = $('<ul class="nav nav-pointer pt-1 pt-md-0"></ul>').appendTo(O._$navBar).wrap('<div class="col-12 col-md-auto order-3 order-md-1 modal-nav-menu order-4"></div>').wrap('<div class="collapse navbar-collapse" id="' + O._navId + '"></div>');
      }

      // modal body
      O._createModalBody();
      O._$modalBody.addClass('p-0 modal-table');

      // content container
      O._$modalTabContent = $('<div class="tab-content h-100"></div>').appendTo(O._$modalBody);
    }

    /**
    * CREATE MODAL
    * creates basic modal components: header and blank body
    */
  }, {
    key: "_createModalBody",
    value: function _createModalBody() {
      var O = this;
      _log('MODAL / _createBody');
      O._$modalBody = $('<div class="modal-body"></div>').appendTo(O._$modalContent);
    }

    /**
    * BUILD PANEL
    * build PANEL content
    * @param {*} _modelMetadata 
     * @param {*} _modelId 
    */
  }, {
    key: "_updateContent",
    value: (function () {
      var _updateContent2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_modelMetadata, _modelId) {
        var O;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              O = this;
              _log('PANEL MetaData / _updateContent');

              // clear tab-panes
              O._$modalTabContent.html('');

              // get appropiate modelMetadata modelHandler for the model type.
              _context.next = 5;
              return O._getModelHandler(_modelMetadata);
            case 5:
              O._modelHandler = _context.sent;
              // populate nav
              O._populateModalNav(O._modelHandler, O._$navBar._$nav);

              // populate panel
              O._populateModalPanel(O._modelHandler);

              // activate first pane
              O._$navBar._$nav.find('.nav-link').first().addClass('active');
              O._$modalTabContent.find('.tab-pane').first().addClass('active');
            case 10:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _updateContent(_x, _x2) {
        return _updateContent2.apply(this, arguments);
      }
      return _updateContent;
    }()
    /**
     * POPULATE MODAL MENU
     * @param {*} modelHandler 
     */
    )
  }, {
    key: "_populateModalNav",
    value: function _populateModalNav(modelHandler) {
      var O = this;
      _log('MODAL DETAILS / _populateModalNav');
      _log(modelHandler);

      // clear nav
      O._$navBar._$nav.html('');

      // create nav items
      if (modelHandler && modelHandler._menu) {
        $.each(modelHandler._menu, function (i, menuMeta) {
          if (menuMeta.id == 'plot') return;
          var $navItem = null;
          if (menuMeta.submenus && menuMeta.submenus.length > 0) {
            $navItem = O._createNavItemDropdown(menuMeta).appendTo(O._$navBar._$nav);
          } else {
            var _$navItem = O._createNavItem(menuMeta).appendTo(O._$navBar._$nav);
          }
        });
      }
      //init collapsable td
      $('a[data-toggle="tab"]').on('shown.bs.tab', function (e) {
        var target = $(e.target).attr("href"); // activated tab
        var targetTable = $('div' + target + '.tab-pane.h-100.active').find('table');
        //if not initialized
        if (targetTable.find('.td-collapse-toggle').length == 0) {
          _appUI._initTdCollapse(targetTable);
        }
      });
    }

    /**
     * POPULATE MODAL PANEL
     * @param {object} modelHandler
     */
  }, {
    key: "_populateModalPanel",
    value: function _populateModalPanel(modelHandler) {
      var O = this;
      _log('MODAL DETAILS / _populateModalPanel');
      _log(modelHandler);

      // create panels
      if (modelHandler && modelHandler._menu && modelHandler.panels) {
        // get each menus id
        $.each(modelHandler._menu, function (i, menuMeta) {
          // dropdown nav item 
          if (menuMeta.submenus && menuMeta.submenus.length > 0) {
            // iterate over submenus
            $.each(menuMeta.submenus, function (j, submenuMeta) {
              // panel meta data exists in handler
              if (submenuMeta.id in modelHandler.panels) {
                var cpanel = O._preparePanel(submenuMeta, modelHandler, $(modelHandler.panels[submenuMeta.id].panel));
                cpanel.appendTo(O._$modalTabContent);
              }
            });
          }
          // single nav item ? create panel
          else {
            if (menuMeta.id && menuMeta.id != 'plot') {
              if (menuMeta.id in modelHandler._panels) {
                var cpanel = O._preparePanel(menuMeta, modelHandler, $(modelHandler._panels[menuMeta.id].panel));
                cpanel.appendTo(O._$modalTabContent);
                //O._createPanel(menuMeta, modelHandler)
                //    .appendTo(O._$modalTabContent);
              }
            }
          }
        });
      }
    }

    /**
     * CREATE NAV ITEM DROPDOWN
     * @param {array} menuMeta: array of dropdown-items width 'id' and 'label'
     */
  }, {
    key: "_createNavItemDropdown",
    value: function _createNavItemDropdown(menuMeta) {
      var O = this;
      _log('MODAL DETAILS / _createTabNavItemDropdown: ' + menuMeta.label);
      var $navItem = $('<li class="nav-item dropdown"></li>');
      var $navLink = $('<a class="nav-link dropdown-toggle" role="button">' + menuMeta.label + '</a>').attr('href', '#').attr('aria-haspopup', true).attr('aria-expanded', false).attr('data-toggle', 'dropdown').appendTo($navItem);
      var $dropdown = $('<div class="dropdown-menu"></div>').appendTo($navItem);
      $.each(menuMeta.submenus, function (i, submenuMeta) {
        var $dropdownItem = $('<a class="dropdown-item" role="button">' + submenuMeta.label + '</a>').attr('href', '#' + submenuMeta.id).attr('aria-controls', '#' + submenuMeta.id).attr('data-toggle', 'tab').appendTo($dropdown);
      });
      return $navItem;
    }

    /**
     * CREATE NAV ITEM
     * @param {array} menuMeta
     */
  }, {
    key: "_createNavItem",
    value: function _createNavItem(menuMeta) {
      var O = this;
      _log('MODAL DETAILS / _createNavItem: ' + menuMeta.label);
      var $navItem = $('<li class="nav-item"></li>');
      var $navLink = $('<a class="nav-link" role="button">' + menuMeta.label + '</a>').attr('href', '#' + menuMeta.id).attr('aria-controls', '#' + menuMeta.id).attr('data-toggle', 'tab').appendTo($navItem);
      if (menuMeta.id == "resources") {
        $navLink.hide();
        $navLink.attr('id', 'Resources');
      }
      return $navItem;
    }

    /**
     * CREATE PANEL
     * create tab-pane for specific menu by selecting type and calling specific creation (simple, complex, plot)
     * @param {array} menu
     * @param {object} modelHandler: object of type Model
     * @param {object} handlerPanel: Panel to add elements to.
     */
  }, {
    key: "_preparePanel",
    value: function _preparePanel(menu, modelHandler, handlerPanel) {
      var O = this;
      _log('MODAL DETAILS / _createPanel: ' + menu.id);
      var $panel = null;
      if (modelHandler && menu.id) {
        var panelMeta = modelHandler._panels[menu.id];
        if (panelMeta && panelMeta.type) {
          // complex
          if (panelMeta.type == 'modelScript') {
            $panel = O._createScriptPanel(menu, modelHandler);
          }
          // simple
          else if (panelMeta.type == 'visualizationScript') {
            $panel = O._createScriptPanel(menu, modelHandler);
          }
          // plot
          else if (panelMeta.type == 'readme') {
            $panel = O._createScriptPanel(menu, modelHandler);
          } else if (panelMeta.type == 'resources') {
            $panel = O._createResourcesPanel(menu, modelHandler);
          } else {
            $panel = O._createPanelPan(menu, modelHandler, handlerPanel);
          }
        }
      }
      return $panel;
    }

    /**
     * CREATE PLOT PANEL
     * create plot tab-pane for specific menu
     * @param {array} menu
     * @param {object} modelHandler: object of class Model
     * @param {object} handlerPanel: Panel to add elements to.
     */
  }, {
    key: "_createPanelPan",
    value: function _createPanelPan(menu, modelHandler, handlerPanel) {
      var O = this;
      _log('MODAL DETAILS / _createPlotPanel');

      // tab-pane
      var $panel = $('<div class="tab-pane h-100" role="tabpanel"></div>').attr('id', menu.id);
      if (modelHandler && menu.id) {
        // get panel meta
        var panelMeta = modelHandler._panels[menu.id];

        // title
        $panel.append('<div class="panel-heading">' + menu.label + '</div>');
        handlerPanel.appendTo($panel);
      }
      return $panel;
    }

    /**
     * CREATE SCRIPT PANEL
     * create SCRIPT tab-pane for specific menu
     * @param {array} menu
     * @param {object} modelHandler: object of class Model
     */
  }, {
    key: "_createScriptPanel",
    value: function _createScriptPanel(menu, modelHandler) {
      var O = this;
      _log('MODAL DETAILS / _createScriptPanel');

      // tab-pane
      var $panel = $('<div class="tab-pane h-100" role="tabpanel"></div>').attr('id', menu.id);
      if (modelHandler && menu.id) {
        // get panel meta
        var panelMeta = modelHandler._panels[menu.id];

        // title
        $panel.append('<div class="panel-heading">' + menu.label + '</div>');
        var $plot = $('<textarea row="6" class="form-control form-control-sm" />').attr('id', menu.id + 'Area').appendTo($panel);
      }
      return $panel;
    }
  }, {
    key: "_createResourcesPanel",
    value: function _createResourcesPanel(menu, modelHandler) {
      var O = this;
      _log('MODAL DETAILS / _createScriptPanel');

      // tab-pane
      var $panel = $('<div class="tab-pane h-100" role="tabpanel"></div>').attr('id', menu.id);
      if (modelHandler && menu.id) {
        // get panel meta
        var panelMeta = modelHandler._panels[menu.id];

        // title
        $panel.append('<div class="panel-heading">' + menu.label + '</div>');
        var $resourcesInput = $("<input id='filesInput' type='file' multiple style='display:none' />").appendTo($panel);
        var $resourcesButton = $("<button id='filesButton' type='button' style='border-radius: 5px; background-color: #fff; color: green;'>+ Add Files</button>").appendTo($panel);
        var $resourcesArea = $("<div id='filesArea'></div>").appendTo($panel);
      }
      return $panel;
    }
    /**
     * GET MODEL HANDLER
     * returns model handler of class Model
     * @param {array} modelMetadata: metadata for specific id
     */
  }, {
    key: "_getModelHandler",
    value: (function () {
      var _getModelHandler2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(modelMetadata) {
        var O, modelHandler, imgUrl;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              O = this;
              _log('MODAL DETAILS / _getModelHandler');
              modelHandler = null;
              if (modelMetadata) {
                // get plot image

                // get appropiate modelMetadata modelHandler for the model type.

                if (modelMetadata.modelType === 'consumptionModel') {
                  modelHandler = new _ConsumptionModelView.ConsumptionModelView(modelMetadata, imgUrl, true);
                }
                if (modelMetadata.modelType === 'dataModel') {
                  modelHandler = new _DataModelView.DataModelView(modelMetadata, imgUrl, true);
                }
                if (modelMetadata.modelType === 'doseResponseModel') {
                  modelHandler = new _DoseResponseModelView.DoseResponseModelView(modelMetadata, imgUrl, true);
                }
                if (modelMetadata.modelType === 'exposureModel') {
                  modelHandler = new _ExposureModelView.ExposureModelView(modelMetadata, imgUrl, true);
                }
                if (modelMetadata.modelType === 'genericModel') {
                  modelHandler = new _GenericModelView.GenericModelView(modelMetadata, imgUrl, true);
                }
                if (modelMetadata.modelType === 'healthModel') {
                  modelHandler = new _HealthModelView.HealthModelView(modelMetadata, imgUrl, true);
                }
                if (modelMetadata.modelType === 'otherModel') {
                  modelHandler = new _OtherModelView.OtherModelView(modelMetadata, imgUrl, true);
                }
                if (modelMetadata.modelType === 'predictiveModel') {
                  modelHandler = new _PredictiveModelView.PredictiveModelView(modelMetadata, imgUrl, true);
                }
                if (modelMetadata.modelType === 'processModel') {
                  modelHandler = new _ProcessModelView.ProcessModelView(modelMetadata, imgUrl, true);
                }
                if (modelMetadata.modelType === 'qraModel') {
                  modelHandler = new _QraModelView.QraModelView(modelMetadata, imgUrl, true);
                }
                if (modelMetadata.modelType === 'riskModel') {
                  modelHandler = new _RiskModelView.RiskModelView(modelMetadata, imgUrl, true);
                }
                if (modelMetadata.modelType === 'toxicologicalModel') {
                  modelHandler = new _ToxicologicalModelView.ToxicologicalModelView(modelMetadata, imgUrl, true);
                }
              }
              return _context2.abrupt("return", modelHandler);
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _getModelHandler(_x3) {
        return _getModelHandler2.apply(this, arguments);
      }
      return _getModelHandler;
    }())
  }]);
}();

},{"../model/AssayView":66,"../model/ConsumptionModelScopeView":69,"../model/ConsumptionModelView":70,"../model/ContactView":72,"../model/DataModelGeneralInformationView":75,"../model/DataModelModelMathView":77,"../model/DataModelView":78,"../model/DietaryAssessmentMethodView":80,"../model/DoseResponseModelGeneralInformationView":83,"../model/DoseResponseModelModelMathView":85,"../model/DoseResponseModelScopeView":87,"../model/DoseResponseModelView":88,"../model/ExposureModelScopeView":92,"../model/ExposureModelView":93,"../model/ExposureView":94,"../model/GenericModelDataBackgroundView":97,"../model/GenericModelGeneralInformationView":99,"../model/GenericModelModelMathView":101,"../model/GenericModelScopeView":103,"../model/GenericModelView":104,"../model/HazardView":106,"../model/HealthModelScopeView":109,"../model/HealthModelView":110,"../model/LaboratoryView":112,"../model/ModelCategoryView":115,"../model/ModelEquationView":117,"../model/ModelView":118,"../model/OtherModelDataBackgroundView":121,"../model/OtherModelGeneralInformationView":123,"../model/OtherModelModelMathView":125,"../model/OtherModelScopeView":127,"../model/OtherModelView":128,"../model/ParameterView":130,"../model/PopulationGroupView":132,"../model/PredictiveModelDataBackgroundView":135,"../model/PredictiveModelGeneralInformationView":137,"../model/PredictiveModelModelMathView":139,"../model/PredictiveModelScopeProductView":142,"../model/PredictiveModelScopeView":143,"../model/PredictiveModelView":144,"../model/ProcessModelScopeView":147,"../model/ProcessModelView":148,"../model/ProductView":150,"../model/QraModelView":152,"../model/QualityMeasuresView":154,"../model/ReferenceView":156,"../model/RiskModelView":158,"../model/StudySampleView":161,"../model/StudyView":162,"../model/ToxicologicalModelScopeView":165,"../model/ToxicologicalModelView":166}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.APPModal = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/*

version: 1.0.0
author: sascha obermller
date: 06.12.2020

*/
var APPModal = exports.APPModal = /*#__PURE__*/function () {
  function APPModal(settings, $container) {
    _classCallCheck(this, APPModal);
    var O = this;
    O._$container = $container;
    O._debug = true;
    O._initiated = false;
    // defaults
    O._opts = $.extend(true, {}, {
      classes: '',
      data: null,
      on: {
        afterInit: null,
        // function
        show: function show(O, event) {
          O._updateModal(event);
        },
        // function
        hide: null // function
      }
    }, settings);
    // basic init actions
    O._create();
    O._initiated = true;
    // callback
    if ($.isFunction(O.opts.on.afterInit)) {
      O.opts.on.afterInit.call(O);
    }
  }
  return _createClass(APPModal, [{
    key: "opts",
    get: function get() {
      return this._opts;
    },
    set: function set(settings) {
      this._opts = $.extend(true, {}, this.opts, settings);
    }

    /**
     * CREATE
     * build basic model parts: modal header, body
     */
  }, {
    key: "_create",
    value: function _create() {
      var O = this;
      _log('MODAL / _create');
      O._id = O.opts.id || 'modal' + $.now();
      O._type = O.opts.type || 'default';
      O._$modal = $('<div class="modal fade" tabindex="-1" role="dialog" aria-hidden="true"></div>').attr('id', O._id).addClass(O.opts.classes).appendTo(O._$container);
      O._$modalContent = $('<div class="modal-content"></div>').appendTo(O._$modal).wrap('<div class="modal-dialog modal-xl" role="document"></div>');

      // loader
      O._loader = _appUI._createLoader({
        classes: 'loader-modal'
      }, O._$modalContent);

      // create modal
      O._createModal();

      // create bs modal
      O._$modal.modal({
        show: false // initially hidden
      });

      // bind show event
      O._$modal.on('show.bs.modal', function (event) {
        // callback
        if ($.isFunction(O.opts.on.show)) {
          O.opts.on.show.call(O, O, event);
        }
        if (!window.knimeService.isSingleView() && !window.multipleview) {
          window.parent.scrollTo(0, 0);
        }
      });

      // bind hide event
      O._$modal.on('hide.bs.modal', function (event) {
        // callback
        if ($.isFunction(O.opts.on.hide)) {
          O.opts.on.hide.call(O, O, event);
        }
      });
    }

    /**
     * CREATE MODAL
     * creates basic modal components: header and blank body
     */
  }, {
    key: "_createModal",
    value: function _createModal() {
      var O = this;
      _log('MODAL / _createModal');

      // modal head default
      O._createModalHead();

      // modal body default
      O._createModalBody().appendTo(O._$modalContent);
    }

    /**
     * CREATE MODAL HEAD
     * creates basic modal header with title and close
     */
  }, {
    key: "_createModalHead",
    value: function _createModalHead() {
      var O = this;
      _log('MODAL / _createModalHead');

      // modal head
      O._$modalHead = $('<div class="modal-header"></div>').appendTo(O._$modalContent);
      // modal head title
      O._$modalTitle = $('<h1 class="modal-title"></h1>').appendTo(O._$modalHead);
      // modal close
      $('<button type="button" class="modal-close action action-pure action-lg ml-2" data-dismiss="modal" aria-label="Close"><i class="feather icon-x"></i></button>').appendTo(O._$modalHead);
    }

    /**
     * CREATE MODAL
     * creates basic modal components: header and blank body
     */
  }, {
    key: "_createModalBody",
    value: function _createModalBody() {
      var O = this;
      _log('MODAL / _createBody');
      O._$modalBody = $('<div class="modal-body"></div>').appendTo(O._$modalContent);
    }

    /**
     * BUILD MODAL
     * build modal blank function
     */
  }, {
    key: "_updateModal",
    value: (function () {
      var _updateModal2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(event) {
        var O;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              O = this;
              _log('MODAL / _updateModal');

              // let $trigger = $( event.relatedTarget );
              // let modalID = $trigger.data( 'modal-id' );
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _updateModal(_x) {
        return _updateModal2.apply(this, arguments);
      }
      return _updateModal;
    }()
    /**
     * SET TITLE
     * set modal title
     */
    )
  }, {
    key: "_setTitle",
    value: function _setTitle(text) {
      var O = this;
      _log('MODAL / _setTitle: ' + text);
      if (O._$modalTitle) {
        O._$modalTitle.text(text);
      }
    }

    /**
     * SHOW
     * show modal
     */
  }, {
    key: "_show",
    value: function _show() {
      var O = this;
      O._$modal.modal('show');
    }

    /**
     * HIDE
     * hide modal
     */
  }, {
    key: "_hide",
    value: function _hide() {
      var O = this;
      O._$modal.modal('hide');
    }

    /**
     * CLEAR MODAL
     * removes table body rows
     */
  }, {
    key: "_clear",
    value: function _clear() {
      var O = this;
      _log('MODAL / _clear');
      if (O._$modalContent) {
        O._$modalContent.empty();
      }
    }
  }]);
}();

},{}],49:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.APPModalMTDetails = void 0;
var _APPModal2 = require("./APPModal.js");
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*

version: 1.0.0
author: sascha obermller
date: 07.12.2020

*/
var APPModalMTDetails = exports.APPModalMTDetails = /*#__PURE__*/function (_APPModal) {
  function APPModalMTDetails(settings, $container) {
    _classCallCheck(this, APPModalMTDetails);
    return _callSuper(this, APPModalMTDetails, [settings, $container]);
  }

  /**
   * CREATE
   * calls super class and sets _metadata
   */
  _inherits(APPModalMTDetails, _APPModal);
  return _createClass(APPModalMTDetails, [{
    key: "_create",
    value: function _create() {
      var O = this;
      _log('MODAL DETAILS / _create', 'primary');
      O._metadata = O.opts.data;
      _get(_getPrototypeOf(APPModalMTDetails.prototype), "_create", this).call(this);
    }

    /**
     * CREATE MODAL
     * creates basic modal components: header and blank body
     */
  }, {
    key: "_createModal",
    value: function _createModal() {
      var O = this;
      _log('MODAL DETAILS / _createModal');

      // modal head default
      O._createModalHead();
      O.ModelMTPanel = new APPMTDetails(O.opts, O._$modalContent);
      O.ModelMTPanel._createModelMetadataContent();
    }

    /**
     * BUILD MODAL
     * build modal content
     */
  }, {
    key: "_updateModal",
    value: (function () {
      var _updateModal2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(event) {
        var O, $trigger;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              O = this;
              _log('MODAL DETAILS / _updateModal');
              _log(event);
              O._loader._setState(true); // set loader

              // get trigger
              $trigger = $(event.relatedTarget); // get model id & data
              O._modelId = $trigger.data('modal-id');
              O._modelMetadata = O._metadata[O._modelId];

              // modal title
              if (O._modelMetadata.generalInformation && O._modelMetadata.generalInformation.name) {
                O._setTitle(O._modelMetadata.generalInformation.name);
              }
              _context.next = 10;
              return O.ModelMTPanel._updateContent(O._modelMetadata, O._modelId);
            case 10:
              O._loader._setState(false); // set loader
            case 11:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _updateModal(_x) {
        return _updateModal2.apply(this, arguments);
      }
      return _updateModal;
    }())
  }]);
}(_APPModal2.APPModal);

},{"./APPModal.js":48}],50:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.APPModalMTSimulations = void 0;
var _APPModal2 = require("./APPModal.js");
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*

version: 1.0.0
author: sascha obermller
date: 07.12.2020

*/
var APPModalMTSimulations = exports.APPModalMTSimulations = /*#__PURE__*/function (_APPModal) {
  function APPModalMTSimulations(settings, $container) {
    _classCallCheck(this, APPModalMTSimulations);
    // defaults maintable simulations modal
    var modalSettings = $.extend(true, {}, {
      on: {
        simRunModelView: null // function
      }
    }, settings);
    return _callSuper(this, APPModalMTSimulations, [modalSettings, $container]);
  }

  /**
   * CREATE
   * calls super class and sets _metadata
   */
  _inherits(APPModalMTSimulations, _APPModal);
  return _createClass(APPModalMTSimulations, [{
    key: "_create",
    value: function _create() {
      var O = this;
      _log('MODAL SIM / _create', 'primary');
      _log(O.opts);

      // global
      O._metadata = O.opts.data;
      O._state = 'params'; // default state: params form

      O._$simInputs = []; // inputs from params and customs
      O._simFields = {};
      O._simSelectedIndex = 0; // initial simulation

      _get(_getPrototypeOf(APPModalMTSimulations.prototype), "_create", this).call(this);

      // bind hide event
      O._$modal.on('hide.bs.modal', function (event) {
        // callback
        if ($.isFunction(O.opts.on.hide)) {
          O.opts.on.hide.call(O, O, event);
        }
        // abort running fetch
        if (O._fetchController) {
          _log('MODAL SIM / abort fetch');
          O._fetchController.abort();
        }
      });
    }

    /**
     * CREATE MODAL
     * creates basic modal components: header and blank body
     */
  }, {
    key: "_createModal",
    value: function _createModal() {
      var O = this;
      _log('MODAL SIM / _createModal');
      // modal head default
      O._createModalHead();
      O.opts._loader = O._loader;
      O._simulationPanel = new APPSimulation(O.opts, O._$modalContent);
      O._simulationPanel._createSimulationContent();
    }

    /**
     * BUILD MODAL
     * build modal content
     * @param {event} event 
     */
  }, {
    key: "_updateModal",
    value: (function () {
      var _updateModal2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(event) {
        var O, $trigger, modelIdentifier;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              O = this;
              _log('MODAL SIM / _updateModal');
              _log(event);
              O._loader._setState(true); // set loader

              // get trigger
              $trigger = $(event.relatedTarget); // get model id & data
              O._modelId = $trigger.data('modal-id');
              O._modelMetadata = O._metadata[O._modelId];

              // modal title 
              if (O._modelMetadata.generalInformation && O._modelMetadata.generalInformation.name) {
                _log(O._modelMetadata.generalInformation.name);
                O._setTitle(O._modelMetadata.generalInformation.name);
              }
              // get simulations
              modelIdentifier = O._modelMetadata.generalInformation.identifier;
              _context.next = 11;
              return _fetchData._json(window._endpoints.simulations, modelIdentifier);
            case 11:
              _simulations = _context.sent;
              _context.next = 14;
              return O._simulationPanel._updateContent(O._modelMetadata, O._modelId, _simulations);
            case 14:
              O._loader._setState(false); // set loader
            case 15:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _updateModal(_x) {
        return _updateModal2.apply(this, arguments);
      }
      return _updateModal;
    }())
  }]);
}(_APPModal2.APPModal);

},{"./APPModal.js":48}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.APPSimulation = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/*

version: 1.0.0
author: Ahmad Swaid
date: 17.12.2020

*/
var APPSimulation = exports.APPSimulation = /*#__PURE__*/function () {
  function APPSimulation(settings, $container) {
    _classCallCheck(this, APPSimulation);
    var O = this;

    // defaults maintable simulations modal
    O._$container = $container;
    O._opts = $.extend(true, {}, {
      classes: '',
      data: null,
      on: {
        afterInit: null,
        // function
        show: function show(O, event) {
          O._updateModal(event);
        },
        // function
        hide: null // function
      }
    }, settings);
    O._create();
  }
  return _createClass(APPSimulation, [{
    key: "opts",
    get: function get() {
      return this._opts;
    },
    set: function set(settings) {
      this._opts = $.extend(true, {}, this.opts, settings);
    }
    /**
    * CREATE
    * calls super class and sets _metadata
    */
  }, {
    key: "_create",
    value: function _create() {
      var O = this;
      _log('SIM / _create', 'primary');
      _log(O.opts);

      // global
      O._metadata = O.opts.data;
      O._state = 'params'; // default state: params form
      O._savedState = 'clean';
      O._$simInputs = []; // inputs from params and customs
      O._simFields = {};
      O._simSelectedIndex = 0; // initial simulation
    }
  }, {
    key: "_createSimulationContent",
    value: function _createSimulationContent() {
      var O = this;
      _log('panel SIM / _createSimulationContent');

      // nav
      O._$modalNav = $('<div class="modal-body sim-select"></div>').appendTo(O._$container);
      O._$globalValidation = $('<ul class="col-12 errorMessages"></ul>').appendTo(O._$container);

      // navbar
      O._$navBar = $('<nav class="navbar">').appendTo(O._$modalNav).wrap('<form></form>');

      // sim select label
      O._$simSelectLabel = $('<label class="col-12 col-md-3 sim-select-label" for="simulationSelect">Simulations</label>').appendTo(O._$navBar);

      // sim select counter
      O._$simSelectCounter = $('<span class="badge badge-primary ml-1">x1</span>').appendTo(O._$simSelectLabel);

      // sim select
      O._$simSelect = $('<select id="simulationSelect" class="custom-control custom-select"></select>').attr('id', 'simulationSelect').appendTo(O._$navBar).wrap('<div class="col-12 col-xs-auto col-md-4 sim-select-field"></div>').on('change', function (event) {
        var selectedIndex = O._$simSelect[0].selectedIndex;
        if (selectedIndex >= 0) {
          O._updateSimIndex(selectedIndex);
        }
      });

      // create actions
      O._createSimActions();

      // panel bodys

      // panel params
      O._$modalParams = $('<div class="modal-body p-0 sim-params"></div>').appendTo(O._$container);
      // param content container
      O._$modalParams._$content = $('<div class="tab-content h-100"></div>').appendTo(O._$modalParams);

      // panel execution
      O._$modalExecution = $('<div class="modal-body p-0 sim-execution"></div>').appendTo(O._$container);
      // execution content container
      O._$modalExecution._$content = $('<div class="tab-content h-100"></div>').appendTo(O._$modalExecution);
    }

    /**
     * CREATE SIM ACTIONS
     * creates actionss
     */
  }, {
    key: "_createSimActions",
    value: function _createSimActions() {
      var O = this;
      _log('panel SIM / _createSimActions');

      // sim select actions
      O._$simSelectActions = $('<div class="col-12 col-xs-auto col-md-5 mt-2 mt-xs-0 sim-select-actions"></div>').appendTo(O._$navBar);

      // create actions
      // action group 1
      var $actionGroup1 = $('<div class="col-auto sim-select-actions-group"></div>').appendTo(O._$simSelectActions);

      // remove
      O._$simActionRemove = $('<button type="button" class="btn btn-icon btn-outline-light"><i class="feather icon-trash-2"></i></button>').attr('id', 'simActionRemove').attr('data-tooltip', '').attr('title', 'Remove simulation').appendTo($actionGroup1).on('click', function (event) {
        O._removeSimulation();
      });

      // add
      O._$simActionAdd = $('<button type="button" class="btn btn-icon btn-outline-light ml-1"><i class="feather icon-plus"></i></button>').attr('id', 'simActionAdd').attr('data-tooltip', '').attr('title', 'Add simulation').appendTo($actionGroup1).on('click', function (event) {
        O._addSimulation();
      });

      // save
      O._$simActionSave = $('<button type="button" class="btn btn-icon btn-outline-light ml-1"><i class="feather icon-save"></i></button>').attr('id', 'simActionSave').attr('data-tooltip', '').attr('title', 'Save changes').appendTo($actionGroup1).on('click', function (event) {
        O._saveSimulation();
      });

      // col divider

      if (!window.noExecution) {
        $('<div class="col-divider ml-auto ml-xs-0"></div>').appendTo(O._$simSelectActions);

        // action group 2
        var $actionGroup2 = $('<div class="col-auto sim-select-actions-group"></div>').appendTo(O._$simSelectActions);
        O._$simActionRun = $('<button type="button" class="btn btn-icon btn-outline-light ml-1"><i class="feather icon-play"></i></button>').attr('id', 'simActionRun').attr('data-tooltip', '').attr('title', 'Run simulation').appendTo($actionGroup2).on('click', function (event) {
          O._runModelView();
        });
      }
      O._$simSelectActions.wrapInner('<div class="row justify-content-end align-items-center"></div>');
    }

    /**
     * CREATE PARAM METADATA LIST
     * create table for metadata collapse container
     * @param {array} param 
     */
  }, {
    key: "_createParamMetadataList",
    value: function _createParamMetadataList(param) {
      var O = this;
      _log('PANEL SIM / _createParamMetadataList');
      var listData = {
        'ID': param.id,
        'Name': param.name,
        'Description': param.description,
        'Unit': param.unit,
        'Unit category': param.unitCategory,
        'Data type': param.dataType,
        'Source': param.source,
        'Subject': param.subject,
        'Distribution': param.distribution,
        'Reference': param.reference,
        'Variability subject': param.variabilitySubject,
        'Min value': param.minValue,
        'Max value': param.maxValue,
        'Error': param.error
      };
      _log(listData);

      // create table
      var $table = $('<table class="table table-sm table-hover table-params-metadata"></table>');

      // create rows
      $.each(listData, function (name, value) {
        if (value) {
          var $row = $('<tr></tr>').appendTo($table);
          $row.append('<td class="td-label">' + name + '</td>'); // label/name
          $row.append('<td>' + value + '</td>'); // value
        }
      });
      return $table;
    }

    /**
     * CREATE FORM FIELD
     * create field as form group
     * @param {array} param
     */
  }, {
    key: "_createFormField",
    value: function _createFormField(param) {
      var O = this;
      _log('PANEL SIM / _createFormField');
      _log(param);
      if (param) {
        // formgroup
        var $formGroup = $('<div class="form-group row"></div>');
        // .appendTo( O._$simForm );

        // label
        var $label = $('<label class="col-form-label col-form-label-sm col-9 col-xs-3 order-1 sim-param-label"></label>').attr('for', 'paramInput_' + param.id).appendTo($formGroup);
        // set custom label or id
        if (O.paramsColorMap[param.id]) {
          param._label ? $label.text(param._label) : $label.text(O.paramsColorMap[param.id][1]);
          $label.css("background-color", O.paramsColorMap[param.id][0]);
        } else param._label ? $label.text(param._label) : $label.text(param.id);
        // field
        var $field = $('<div class="col-12 col-xs-7 col-md-6 order-3 order-xs-2 sim-param-field"></div>').appendTo($formGroup);

        // actions
        var $actions = $('<div class="col-3 col-xs-auto order-2 order-xs-3 sim-param-actions"></div>').appendTo($formGroup);

        // input item
        var $input = null;
        // set input type
        var inputType = null;
        if (param.dataType.toLowerCase() === 'integer' || param.dataType.toLowerCase() === 'double' || param.dataType.toLowerCase() === 'number') {
          inputType = 'number';
        } else if (param.dataType.toLowerCase() === 'simname') {
          inputType = 'simName'; // custom type for name and description
        } else if (param.dataType.toLowerCase() === 'simdescription') {
          inputType = 'simDescription'; // custom type for name and description
        } else if (param.dataType.toLowerCase() === 'vectorofnumbers') {
          inputType = 'vectorofnumbers';
        } else if (param.dataType.toLowerCase() === 'matrixofnumbers') {
          inputType = 'matrixofnumbers';
        } else if (param.dataType.toLowerCase() === 'file') {
          inputType = 'file';
        } else {
          inputType = 'text';
        }

        // create param metadata action
        if (_isNull(param._showMetadata) || param._showMetadata === true) {
          // action metadata list
          var $actionMetadata = $('<button class="action action-pure" type="button"><i class="feather icon-info"></i></button>').attr('data-toggle', 'collapse').attr('data-target', '#paramMetadata_' + param.id).attr('aria-expanded', false).attr('aria-controls', 'paramMetadata_' + param.id).attr('title', 'Show Metadata').appendTo($actions);
        }

        // add special action for vector or matrix of numbers
        if (inputType == 'vectorofnumbers') {
          var $actionVectoEditor = $('<button class="action action-pure" type="button"><i class="feather icon-edit"></i></button>').attr('title', 'Edit Vector').appendTo($actions);

          // TO DO
          // action what to do on click
        } else if (inputType == 'matrixofnumbers') {
          var _$actionVectoEditor = $('<button class="action action-pure" type="button"><i class="feather icon-edit"></i></button>').attr('title', 'Edit Matrix').appendTo($actions);

          // TO DO
          // action what to do on click
        }
        if (inputType) {
          // numeric
          if (inputType == 'number' && param.classification != "CONSTANT") {
            var $inputGroup = $('<div class="input-group input-group-sm"></div>').appendTo($field);
            $input = $('<input type="text" />').attr('id', 'paramInput_' + param.id).data('param-input', param).attr('aria-invalid', false).appendTo($inputGroup);
            // rangeslider single, if min/max
            if (param.minValue && param.maxValue && param.minValue != "-" && param.maxValue != "-") {
              var step = 1;
              // calc decimals for slider steps depending on min-max values
              if (param.dataType.toLowerCase() === 'double') {
                var decimals = param.value.substring(param.value.indexOf('.') + 1).length;
                for (var j = 0; j < decimals; j++) {
                  step = step / 10;
                }
              }

              // add rangeslider attributes
              $input.addClass('custom-range').attr('data-rangeslider', '').attr('data-step', step).attr('data-min', parseFloat(param.minValue)) // min value
              .attr('data-max', parseFloat(param.maxValue)) // max value
              .attr('data-control-single', '#paramControlSingle_' + param.id);

              // control input field for range value
              var $inputControl = $('<input type="text" class="form-control" />').attr('id', 'paramControlSingle_' + param.id).data('param-input', param).appendTo($field).wrap('<div class="input-range-controls"></div>').wrap('<div class="input-group input-group-sm input-range-control-single"></div>');

              // O._$simInputs.push( $inputControl );

              // add unit postfix to touchspin
              if (param.unit && param.unit != '[]' && param.unit != 'Others') {
                var $append = $('<div class="input-group-text"></div>').text(param.unit).insertAfter($inputControl).wrap('<div class="input-group-append"></div>');
              }
            }
            // touchspin
            else {
              $input.addClass('form-control form-control-sm').attr('data-touchspin', '');
              // add unit postfix to touchspin
              if (param.unit && param.unit != '[]' && param.unit != 'Others') {
                $input.attr('data-touchspin-postfix', param.unit);
              }
              var _step = 1;

              // calc decimals for slider steps depending on min-max values
              if (param.dataType.toLowerCase() === 'double') {
                var _decimals = param.value.substring(param.value.indexOf('.') + 1).length;
                for (var _j = 0; _j < _decimals; _j++) {
                  _step = _step / 10;
                }
                // add decimals support
                if (_decimals > 0) {
                  $input.attr('data-touchspin-decimals', _decimals);
                }
              }
              // add step range
              $input.attr('data-touchspin-step', _step);
            }
          }
          // sim name
          else if (inputType == 'simName') {
            $input = $('<input type="text" class="form-control form-control-sm" />').attr('id', 'customInput_' + param.id).data('custom-input', param).appendTo($field);
            O._$simNameInput = $input;
          }
          // sim description
          else if (inputType == 'simDescription') {
            $input = $('<textarea type="text" class="form-control form-control-sm" rows="6" /></textarea>').attr('id', 'customInput_' + param.id).data('custom-input', param).appendTo($field);
            O._$simDescInput = $input;
          } else if (inputType == 'file') {
            if (window.location.protocol != '' && window.location.host != '') {
              var timeStampInMs = window.performance && window.performance.now && window.performance.timing && window.performance.timing.navigationStart ? window.performance.now() + window.performance.timing.navigationStart : Date.now();
              // send AJAX request to acquire the JWT for the currently logged in
              // user. Subsequent requests need to carry the token in the
              // Authorization header

              server = window.location.protocol + "//" + window.location.host;
              var xhttp = new XMLHttpRequest();
              xhttp.onreadystatechange = function () {
                if (this.readyState == 4 && this.status == 200) {
                  JWT = this.responseText;
                }
                // create temp folder for the current running instance of the
                // worklflow on the server
                // this folder will be removed after coping all the content inside
                // to the fsk object working directory.
                var anotherxhttp = new XMLHttpRequest();
                window.parentResourcesFolder = "knime://knime.mountpoint/tempResources/jsSimulatorTempFolder" + timeStampInMs;
                anotherxhttp.open("put", server + "/knime/rest/v4/repository/tempResources/jsSimulatorTempFolder" + timeStampInMs, true);
                anotherxhttp.setRequestHeader("Authorization", "Bearer" + JWT);
                anotherxhttp.send();
              };
              xhttp.open("GET", server + "/knime/rest/session", true);
              xhttp.send();

              // title
              var $panel = $('<div class="tab-pane" role="tabpanel"></div>').appendTo($field);
              $input = $("<input id='filesInput' type='file' style='display:none' />");
              $input.attr('id', 'paramInput_' + param.id).data('param-input', param).appendTo($panel);
              var button = $("<button id='filesButton' type='button' style='border-radius: 5px; background-color: #fff; color: green;'>Add File</button>").appendTo($panel);
              var filesContainer = $("<div id='filesArea-" + param.id + "'></div>").appendTo($panel);
              if (param.value) {
                var fileElement = $("<div ><hr/><p>" + param.value + "</div>");
                filesContainer.html(fileElement);
              }
              var files = [];
              var fileIDMap = {};
              var fileUploadAJAXMap = {};
              $input.change(function () {
                var newFiles = [];
                for (var index = 0; index < $input[0].files.length; index++) {
                  var file = $input[0].files[index];
                  newFiles.push(file);
                  files.push(file);
                }
                var _loop = function _loop() {
                    var file = newFiles[_index];
                    ID = function () {
                      return '_' + Math.random().toString(36).substr(2, 9);
                    }();
                    var fileElement = $("<div ><hr/><p>" + file.name + "</p><progress id='" + ID + "' value='0' max='100' style='width:300px;'/><button idFile='" + file.name + "' type='button' >delete</button></div>");
                    fileElement.data('fileData', file);
                    filesContainer.html(fileElement);
                    fileIDMap[file.name] = ID;
                    $("[idFile='" + file.name + "']").click(function (event) {
                      var fileElement = $(event.target);
                      var indexToRemove = files.indexOf(fileElement.data('fileData'));
                      $.ajax({
                        type: "DELETE",
                        url: server + "/knime/rest/v4/repository/tempResources/jsSimulatorTempFolder" + timeStampInMs + "/" + $(this).attr('idFile') + "?deletePermanently",
                        success: function success(msg) {}
                      });
                      $(this).parent().remove();
                      //$("#" + fileIDMap[fileElement.html()]).remove()
                      files.splice(indexToRemove, 1);
                      fileUploadAJAXMap[$(this).attr('idFile')].abort();
                    });
                    fileUploadAJAXMap[file.name] = $.ajax({
                      url: server + "/knime/rest/v4/repository/tempResources/jsSimulatorTempFolder" + timeStampInMs + "/" + file.name + ":data",
                      xhr: function xhr() {
                        var myXhr = $.ajaxSettings.xhr();
                        if (myXhr.upload) {
                          myXhr.upload.addEventListener('progress', function (e) {
                            if (e.lengthComputable) {
                              var max = e.total;
                              var current = e.loaded;
                              var Percentage = current * 100 / max;
                              $("#" + fileIDMap[file.name]).attr('value', Percentage);
                              if (Percentage >= 100) {
                                // process
                                // completed
                              }
                            }
                          }, false);
                        }
                        return myXhr;
                      },
                      headers: {
                        Authorization: "Bearer" + JWT
                      },
                      data: file,
                      type: 'put',
                      success: function success(data) {
                        window.resourcesFiles[param.id] = ["knime://knime.mountpoint" + data.path, ""];
                      },
                      error: function error(data) {
                        console.log('ERROR !!!', data);
                      },
                      cache: false,
                      processData: false,
                      contentType: false
                    });
                  },
                  ID;
                for (var _index = 0; _index < newFiles.length; _index++) {
                  _loop();
                }
              });
              button.click(function () {
                $input.trigger("click");
              });
            } else {
              $input = $('<input type="text" class="form-control form-control-sm" />').attr('id', 'paramInput_' + param.id).data('param-input', param).appendTo($field);
            }
          }
          // string or others
          else {
            $input = $('<input type="text" class="form-control form-control-sm" />').attr('id', 'paramInput_' + param.id).data('param-input', param).appendTo($field);
          }

          // readonly attribute
          param.classification === "CONSTANT" ? $input.attr('readonly', '') : null;

          // add $input to global variable
          O._$simInputs.push($input);
          O._simFields[param.id] = {
            input: $input,
            param: param
          };
        }

        // create validation container
        $input.$validationContainer = $('<div class="validation-message mt-1"></div>').appendTo($field);

        // create param metadata list
        if (_isNull(param._showMetadata) || param._showMetadata === true) {
          // metadata table
          var $metadataContainer = $('<div class="collapse param-metadata"></div>').attr('id', 'paramMetadata_' + param.id).attr('aria-expanded', false).appendTo($field);
          $metadataContainer.append(O._createParamMetadataList(param));
        }
        return $formGroup;
      }
      return null;
    }

    /**
     * POPULATE SIM SELECT
     * create select options 
     */
  }, {
    key: "_populateSimSelect",
    value: function _populateSimSelect() {
      var O = this;
      _log('PANEL SIM / _populateSimSelect');
      if (O._simulations && O._simulations.length > 0 && O._$simSelect) {
        // clear sim select
        O._$simSelect.empty();
        // options
        $.each(O._simulations, function (i, sim) {
          if (sim.name) {
            var $option = $('<option>' + sim.name + '</option>').appendTo(O._$simSelect);
          }
        });
        // update badge counter
        O._$simSelectCounter.text('x' + O._simulations.length);
      }
    }

    /**
     * POPULATE SIMULATION FORM
     * creates all input fields
     */
  }, {
    key: "_populateSimForm",
    value: function _populateSimForm() {
      var O = this;
      _log('PANEL SIM / _populateSimForm');

      // clear
      O._state == 'form';
      O._$simInputs = []; // stores all inputs in global var to provide access on params an custom fields like name and description
      O._simFields = {};
      O._selectedSimIndex = 0;
      O._$simForm ? O._clear(O._$simForm) : null; // clear form

      // create form
      O._$simForm = $('<form class="form-striped"></form>').attr('id', 'simParamsForm').appendTo(O._$modalParams._$content);

      // create mandatory custom form group sim name 
      var simNameParam = {
        id: 'simName',
        dataType: 'SIMNAME',
        _showMetadata: false,
        _label: 'Simulation Name',
        _isCustom: true,
        _on: {
          update: function update(O, $input) {
            O._updateSimName();
          }
        }
      };
      var $simNameFormGroup = O._createFormField(simNameParam);
      $simNameFormGroup ? $simNameFormGroup.appendTo(O._$simForm) : null;

      // create optional custom form group sim description 
      var simDescParam = {
        id: 'simDescription',
        dataType: 'SIMDESCRIPTION',
        _showMetadata: false,
        _label: 'Description (optional)',
        _isCustom: true,
        _on: {
          update: function update(O, $input) {
            O._updateSimDescription();
          }
        }
      };
      var $simDescFormGroup = O._createFormField(simDescParam);
      $simDescFormGroup ? $simDescFormGroup.appendTo(O._$simForm) : null;

      // model metadata params
      var params = O._modelMetadata['modelMath']['parameter'];
      if (params.length > 0) {
        // create form group for each param
        $.each(params, function (i, param) {
          if (O.paramsColorMap[param.id][2]) {
            // create model name title 
            // formgroup
            var $formGroup = $('<div class="form-group row"></div>');

            // label containing the model name
            var $label = $('<label class="col-form-label col-form-label-sm col-9 col-xs-3 order-1 sim-param-label"></label>').text(O.paramsColorMap[param.id][2]).css("background-color", O.paramsColorMap[param.id][0]).appendTo($formGroup);
            var _$simDescFormGroup = O._createFormField(simDescParam);
            $formGroup ? $formGroup.appendTo(O._$simForm) : null;
          }
          if (param.classification != 'OUTPUT') {
            var _$formGroup = O._createFormField(param);
            _$formGroup ? _$formGroup.appendTo(O._$simForm) : null;
          }
        });

        // init form items' functions: touchspin, range, select2 ...
        _appUI._initFormItems(O._$simForm);
      }
      _log(O._simFields);
    }

    /**
     * UPDATE SIMULATION INDEX
     * set selected simulation index and trigger update
     */
  }, {
    key: "_updateSimIndex",
    value: function _updateSimIndex(simIndex) {
      var O = this;
      _log('PANEL SIM / _updateSimIndex: ' + simIndex);
      simIndex = !_isNull(simIndex) ? simIndex : O._simSelectedIndex;
      if (simIndex >= -1 && simIndex != O._simSelectedIndex && simIndex <= O._simulations.length - 1) {
        // update sim index
        O._simSelectedIndex = simIndex;
        O._setState('params');

        // update inputs
        O._updateSimForm(simIndex);
        O._updateSimActions(simIndex);
      }

      // update badge counter
      O._$simSelectCounter.text('x' + O._simulations.length);
    }

    /**
     * UPDATE SIMULATION INPUTS
     * changes the selected simulation's inputs
     * @param {integer} simIndex of selected simulation: -1 ich add action, 0 = default
     */
  }, {
    key: "_updateSimForm",
    value: function _updateSimForm(simIndex) {
      var _this = this;
      var O = this;
      _log('PANEL SIM / _updateSimForm: ' + simIndex);
      simIndex = !_isNull(simIndex) ? simIndex : O._simSelectedIndex;

      // set value if param or custom
      var valIndex = simIndex;
      if (simIndex < 0) {
        valIndex = 0;
      }
      var simulation = O._simulations[valIndex];

      // disable parameter inputs for the default simulation.
      O._simDisabled = simIndex == 0;

      // remove error classes
      $('.has-error').removeClass('has-error');
      $('.is-invalid').removeClass('is-invalid');

      // update param values
      // $.each( O._$simInputs, ( i, $input ) => {

      $.each(O._simFields, function (id, field) {
        _log(field);
        if (field.input && field.param) {
          // disable or enable 
          field.input.prop('disabled', O._simDisabled);

          // disable rangeslider 
          if (field.input.data('rangeslider')) {
            field.input.data('rangeslider').update({
              disable: O._simDisabled
            });
          }
          // disable touchspin
          else if (!_isUndefined(field.input.attr('data-touchspin'))) {
            // disable/enable buttons oof touchspin group
            field.input.parent().find('button').prop('disabled', O._simDisabled);
          }
          // param fields
          if (!field.param._isCustom) {
            // set value of current selected sim index
            _log(field.param.id + ' : ' + simulation.parameters[field.param.id], 'level1');
            var paramValue = simulation.parameters[field.param.id];

            // change rangeslider value
            if (!_isUndefined($(field.input).data('rangeslider'))) {
              var $inputControl = $($(field.input).data('control-single'));
              if ($inputControl.length > 0) {
                $inputControl.val(paramValue);
                // trigger change
                $inputControl.trigger('change');
              }
            }
            // change other inputs
            else {
              if (field.param.dataType == 'FILE') {
                if (window.location.protocol != '' && window.location.host != '') {
                  var paramId = field.input.attr('id').split('_').pop();
                  var filesContainer = $('#filesArea-Input_' + paramId);
                  var fileElement = $("<div ><hr/><p>" + paramValue + "</div>");
                  filesContainer.html(fileElement);
                } else {
                  !_isNull(paramValue) ? field.input.val(paramValue) : null;
                }
              } else {
                !_isNull(paramValue) ? field.input.val(paramValue) : null;
              }
            }
          }
          // custom fields like name and desc
          else if (field.param._isCustom && field.param._isCustom == true) {
            _log(field.param.id + ' : ', 'level1');

            // check opt for custom update function 
            if (field.param._on && field.param._on.update && $.isFunction(field.param._on.update)) {
              field.param._on.update.call(_this, O);
            }
          }

          // trigger change
          field.input.trigger('change');
        }
      });
    }

    /**
     * UPDATE SIMULATION ACTIONS
     * changes the selected simulation's inputs
     * @param {integer} simIndex of selected simulation
     */
  }, {
    key: "_updateSimActions",
    value: function _updateSimActions(simIndex) {
      var O = this;
      _log('PANEL SIM / _updateSimActions');
      simIndex = !_isNull(simIndex) ? simIndex : O._simSelectedIndex;
      if (simIndex == -1) {
        // add simulation
        O._$simActionRemove.prop('disabled', false);
        O._$simActionAdd.prop('disabled', true);
        O._$simActionSave.prop('disabled', false);
      } else if (simIndex == 0) {
        // default sim
        O._$simActionRemove.prop('disabled', true);
        O._$simActionAdd.prop('disabled', false);
        O._$simActionSave.prop('disabled', true);
      } else {
        // selected sim > 0
        O._$simActionRemove.prop('disabled', false);
        O._$simActionAdd.prop('disabled', false);
        O._$simActionSave.prop('disabled', false);
      }
    }

    /**
     * UPDATE SIMULATION CUTOM NAME
     * changes the custom input name to selected simulation's name
     */
  }, {
    key: "_updateSimName",
    value: function _updateSimName() {
      var O = this;
      _log('PANEL SIM / _updateSimName');
      if (O._$simNameInput) {
        var simName = '';
        if (!_isNull(O._simulations) && !_isNull(O._simSelectedIndex) && O._simulations[O._simSelectedIndex]) {
          // get simulation name
          simName = O._simulations[O._simSelectedIndex].name;
        }
        // set name
        O._$simNameInput.val(simName);
      }
    }

    /**
     * UPDATE SIMULATION CUSTOM DESCRIPTUION
     * changes the custom input description to selected simulation's name
     * @param {jquery elem} $input
     */
  }, {
    key: "_updateSimDescription",
    value: function _updateSimDescription($input) {
      var O = this;
      _log('PANEL SIM / _updateSimDescription');
      if (O._$simDescInput) {
        var simDesc = '';
        if (!_isNull(O._simulations) && !_isNull(O._simSelectedIndex) && O._simulations[O._simSelectedIndex]) {
          // get simulation name
          simDesc = O._simulations[O._simSelectedIndex].desc;
        }
        // set name
        O._$simDescInput.val(simDesc);
      }
    }

    /**
     * ADD SIMULATION
     * add the selected simulation
     */
  }, {
    key: "_addSimulation",
    value: function _addSimulation() {
      var O = this;
      _log('PANEL SIM / _addSimulation', 'secondary');

      // clear sim select
      O._$simSelect.val('');

      // update sim select to index for add-action : -1
      O._updateSimIndex(-1);
      O._setSavedState('dirty');
    }

    /**
     * REMOVE SIMULATION
     * remove the selected simulation
     */
  }, {
    key: "_removeSimulation",
    value: function _removeSimulation() {
      var O = this;
      _log('PANEL SIM / _removeSimulation', 'secondary');
      if (O._simSelectedIndex != 0) {
        // remove from sim select
        O._$simSelect.find('option').eq(O._simSelectedIndex).remove();

        // remove from simulations var
        O._simulations.splice(O._simSelectedIndex, 1);

        // reset to default
        O._$simSelect.find('option').eq(0).prop('selected', true);
        O._updateSimIndex(0);
      }
    }

    /**
     * SAVE SIMULATION
     * save the selected simulation
     */
  }, {
    key: "_saveSimulation",
    value: (function () {
      var _saveSimulation2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var O, validation, newSimulation, property;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              O = this;
              _log('PANEL SIM / _saveSimulation', 'secondary');
              if (O._$simNameInput.val() == "") {
                O._$simNameInput.val("simulationname" + O._getRandomInt(100));
              }
              // run validation
              _context.next = 5;
              return O._validateSimForm();
            case 5:
              validation = _context.sent;
              // no errors ?
              if (validation.length == 0) {
                newSimulation = JSON.parse(JSON.stringify(O._simulations[0])); // set new simulation's name
                newSimulation.name = O._$simNameInput.val();
                // set sim desc
                newSimulation.desc = O._$simDescInput ? O._$simDescInput.val() : '';

                // set new simulation's parameters
                if (O._simFields) {
                  // for each input get value and et param value
                  $.each(O._simFields, function (id, field) {
                    if (field.input && !_isNull(field.param)) {
                      // create simulation param
                      if (field.param.dataType.toLowerCase() != 'file') newSimulation.parameters[field.param.id] = field.input.val();
                    }
                  });
                  O._simulations.push(newSimulation);
                  // re-populate sim select
                  O._populateSimSelect();
                  // update sim index
                  O._$simSelect.find('option').last().prop('selected', true);
                  O._updateSimIndex(O._simulations.length - 1);
                }
              }
              for (property in window.resourcesFiles) {
                window.resourcesFile[property] = $('#customInput_simName').val();
              }
              O._setSavedState('clean');
              // TO DO 
              // save to endpoint ?
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _saveSimulation() {
        return _saveSimulation2.apply(this, arguments);
      }
      return _saveSimulation;
    }()
    /**
     * VALIDATE SIMULATION FORM
     * run validation on sim form inputs
     */
    )
  }, {
    key: "_validateSimForm",
    value: (function () {
      var _validateSimForm2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var O, validationErrors;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              O = this;
              _log('PANEL SIM / _validateSimForm');
              O._$globalValidation.empty();
              validationErrors = []; // remove error classes
              $('.has-error').removeClass('has-error');
              $('.is-invalid').removeClass('is-invalid');
              $('.validation-message').empty();

              // validate sim inputs values
              if (O._simFields) {
                $.each(O._simFields, function (id, field) {
                  // let param = $input.data( 'param-input' );

                  if (!_isNull(field.param)) {
                    var validationParam = O._validateSimField(field);
                    validationParam ? validationErrors.push(validationParam) : null;
                  }
                });
              }

              // proceed error visualization
              $.each(validationErrors, function (i, error) {
                error.input.parents('.form-group').addClass('has-error');
                error.input.addClass('is-invalid');
                error.input.$validationContainer.text(error.msg);
                $('<li>' + error.msg + '</li>').appendTo(O._$globalValidation);
                // let $errorMsg = $( '<div class="alert alert-danger alert-xs"></div>' )
                // 	.appendTo( error.input.$validationContainer )
                // 	.text( error.msg );
              });
              O._$globalValidation.show();
              _log(validationErrors);
              return _context2.abrupt("return", validationErrors);
            case 12:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _validateSimForm() {
        return _validateSimForm2.apply(this, arguments);
      }
      return _validateSimForm;
    }()
    /**
     * VALIDATE SIMULATION PARAM
     * run validation on param field
     */
    )
  }, {
    key: "_validateSimField",
    value: function _validateSimField(field) {
      var O = this;
      _log('PANEL SIM / _validateSimField');
      _log(field);
      if (field && field.input) {
        var fieldValue = field.input.val();

        // check simulation name
        if (field.param.dataType.toLowerCase() === 'simname') {
          var idRegexp = /^[A-Za-z_^s]\w*$/;

          // name length
          if (fieldValue.length == 0) {
            return {
              input: field.input,
              msg: 'Simulation name is required'
            };
          }
          // name already exists?
          for (var i = 0; i < O._simulations.length; ++i) {
            if (fieldValue === O._simulations[i].name) {
              return {
                input: field.input,
                msg: 'Simulation name already exists'
              };
            }
          }
          // name fits regexp
          if (!idRegexp.test(fieldValue)) {
            return {
              input: field.input,
              msg: 'Not a valid simulation name (SId)'
            };
          }
        } else if (field.param.dataType.toLowerCase() === 'simdescription') {} else {
          // no value
          if (!fieldValue) {
            if (field.param.dataType.toLowerCase() != 'file') {
              return {
                input: field.input,
                msg: 'Please provide a value for ' + field.param.id
              };
            }
          }

          // check range for integers and doubles
          if (field.param.dataType.toLowerCase() === 'integer' || field.param.dataType.toLowerCase() === 'double') {
            if (field.param.dataType.toLowerCase === 'integer' && fieldValue.indexOf('.') > 0) {
              return {
                input: field.input,
                msg: 'Invalid integer value'
              };
            }
            if (field.param.minValue && parseFloat(field.param.minValue) > fieldValue) {
              return {
                input: field.input,
                msg: 'Invalid value. Value is lower than minimal value: ' + field.param.minValue
              };
            }
            if (field.param.maxValue && parseFloat(field.param.maxValue) < fieldValue) {
              return {
                input: field.input,
                msg: 'Invalid value. Value is higher than maximum value: ' + field.param.maxValue
              };
            }
          } else if (field.param.dataType.toLowerCase() === 'file') {

            // TBD
          } else if (field.param.dataType.toLowerCase() === 'vectorofnumbers') {

            // TBD
          } else if (field.param.dataType.toLowerCase() === 'matrixofnumbers') {

            // TBD
          }
        }
      }
      return false;
    }
    /**
    * BUILD PANEL
    * build PANEL content
    * @param {event} event 
    */
  }, {
    key: "_updateContent",
    value: (function () {
      var _updateContent2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_modelMetadata, _modelId, _simulations, paramsColorMap) {
        var O;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              O = this;
              _log('PANEL SIM / _updateContent');
              O._setState('params'); // reset state to form params when opening PANEL

              O._modelMetadata = _modelMetadata;
              O._modelId = _modelId;
              // clear tab-panes
              O._clear(O._$modalParams._$content);
              O._simSelectedIndex = 0; // reset simulation
              // get simulations
              O._simulations = _simulations;
              O.paramsColorMap = paramsColorMap;

              // create params		
              if (O._simulations && O._simulations.length > 0) {
                // populate sim select
                O._populateSimSelect();
                // populate sim form
                O._populateSimForm();
                // update form groups' value
                O._updateSimForm(0);
                O._updateSimActions(0);
              }
            case 10:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function _updateContent(_x, _x2, _x3, _x4) {
        return _updateContent2.apply(this, arguments);
      }
      return _updateContent;
    }()
    /**
     * RUN MODEL VIEW
     * run modelview
     */
    )
  }, {
    key: "_runModelView",
    value: (function () {
      var _runModelView2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(modelId) {
        var O, $alert, result, $title, $plot;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              O = this;
              _log('PANEL SIM / _runModelView : ' + O._modelId, 'secondary');
              modelId = modelId || O._modelId;
              if (!(modelId >= 0)) {
                _context4.next = 23;
                break;
              }
              O._fetchController = new AbortController();
              O._signal = O._fetchController.signal;

              // clear tab content
              O._clear(O._$modalExecution._$content);
              O._clear(O._$modalExecution._$title);
              O._setState('execution');

              // activate loader
              O._$container.addClass('loading');
              O._opts._loader._setState(true);
              // create loading alert
              $alert = _appUI._createAlert('executing model... please wait', {
                type: 'primary',
                state: 'show',
                classes: 'm-1'
              }, O._$modalExecution._$content); // TO DO 
              // run simulation by selected index
              // execute result
              _context4.next = 14;
              return _fetchData._content(_endpoints.execution, modelId, O._signal);
            case 14:
              result = _context4.sent;
              //O._app._getExecutionResult( modelId ) ;

              // clear tab content
              O._clear(O._$modalExecution._$content);
              O._clear(O._$modalExecution._$title);
              $alert.remove();

              // add executet simulation name as panel-title
              $title = $('<div class="panel-heading"></div>').text(O._simulations[O._selectedSimIndex].name).appendTo(O._$modalExecution._$content); // add result as plot
              $plot = $(result).appendTo(O._$modalExecution._$content).wrapAll('<div class="panel-plot"></div>'); // deactivate loader
              O._$container.removeClass('loading');
              O._opts._loader._setState(false);

              // callback
              if ($.isFunction(O.opts.on.simRunModelView)) {
                O.opts.on.simRunModelView.call(O, O, modelId, O._simulations[O._selectedSimIndex]);
              }
            case 23:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function _runModelView(_x5) {
        return _runModelView2.apply(this, arguments);
      }
      return _runModelView;
    }()
    /**
     * CLEAR
     * removes content from element
     * @param {jquery selector} $elem
     */
    )
  }, {
    key: "_clear",
    value: function _clear($elem) {
      var O = this;
      _log('PANEL SIM / _clear');
      _log($elem);
      if ($elem) {
        $elem.empty();
      }
    }

    /**
    * CLEAR
    * removes content from element
    * @param {string} state: execute or params
    */
  }, {
    key: "_setState",
    value: function _setState(state) {
      var O = this;
      _log('PANEL SIM / _setState: ' + state);
      if (state && O._state != state) {
        if (state == 'execution') {
          O._$modalExecution.show();
          O._$modalParams.hide();
          O._$modalNav.hide();
        } else {
          O._$modalExecution.hide();
          O._$modalParams.show();
          O._$modalNav.show();
        }
        // set sim modal state
        O._state = state;
      }
    }
  }, {
    key: "_setSavedState",
    value: function _setSavedState(state) {
      // set sim modal state
      this._savedState = state;
    }
  }, {
    key: "_getRandomInt",
    value: function _getRandomInt(max) {
      return Math.floor(Math.random() * max);
    }
  }]);
}();

},{}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.APPTable = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/*

version: 1.0.0
author: sascha obermller
date: 07.12.2020

*/
var APPTable = exports.APPTable = /*#__PURE__*/function () {
  function APPTable(settings, $container, metadata, uploadDates, executionTimes) {
    _classCallCheck(this, APPTable);
    var O = this;
    O._$container = $container;
    O._$wrapper = null;
    O.totalRows = 0;
    // defaults
    O._opts = $.extend(true, {}, {
      attributes: {},
      // attribute : value pairs for <table>
      classes: '',
      // string of classes for <table>
      cols: [],
      // cols definition as array
      tableData: null,
      // table data
      ids: {
        // ids for specific table elements
        table: 'tGrid',
        thead: 'tHead',
        tbody: 'tRows'
      },
      responsive: true,
      // wrap table with .table-responsive
      rowActions: [],
      rowSelectable: false,
      // 'single', // 'multiple', //
      showToggle: true,
      // show card view toggle
      wrapper: false,
      // 'card'
      on: {
        // hooks/callbacks on specific events
        afterInit: null,
        afterPopulate: null,
        selectRow: null,
        selectAllRow: null,
        deselectRow: null
      }
    }, settings);
    O._metadata = metadata;
    O._uploadDates = uploadDates;
    O._executionTimes = executionTimes;
    // basic init actions
    O._create();

    // callback
    if ($.isFunction(O.opts.on.afterInit)) {
      O.opts.on.afterInit.call(O, O);
    }
  }
  return _createClass(APPTable, [{
    key: "opts",
    get: function get() {
      return this._opts;
    },
    set: function set(settings) {
      this._opts = $.extend(true, {}, this.opts, settings);
    }
  }, {
    key: "addRow",
    value: function addRow(rowIndex, rowData, tableData, isMainTable, isEdit) {
      var O = this;
      tableData = O._tableData;
      // row
      var $tr = $('<tr data-row-id="' + rowIndex + '"></tr>');
      if (isEdit) O._$tbody.find('tr:nth(' + rowIndex + ')').replaceWith($tr);else $tr.appendTo(O._$tbody);
      // rows selectable
      if (O.opts.rowSelectable) {
        // add selectable attribrutes
        $tr.data('selectable', '');
        $tr.data('selected', false);

        // add row click actions
        $tr.on('click', function (event) {
          // activate row not on click on buttons, actions or links in the table
          if (!$(event.target).is('a, button, .action') && !$(event.target).parent().is('a, button, .action')) {
            // select row
            O._handleRowSelect($tr);
          }
        });
      }

      // complete table data by adding row element to certain row data
      if (isMainTable) {
        tableData[rowIndex].el = $tr;
      }
      if (O._opts.data) {
        $('<td class="active"><input type="checkbox" class="select-item checkbox" name="select-item" /></td>').appendTo($tr);
      }

      // create cols
      $.each(O.opts.cols, function (j, col) {
        var data;
        if (rowData.cells) data = rowData.cells[j];else data = rowData[col.field];
        var $td = $('<td></td>').appendTo($tr);
        if (data && data.length > 60) {
          col.collapsable = "true";
        }
        col.classes && col.classes.td ? $td.addClass(col.classes.td) : null; // classes
        col.collapsable ? $td.attr('data-td-collapse', col.collapsable) : null; // data collapsable
        col.label ? $td.attr('data-label', col.label) : null; // add data-label for toggle view cards
        col.field ? $td.attr('data-id', col.field) : null;

        // td attributes
        if (col.attributes && col.attributes.td) {
          $.each(col.attributes.td, function (attr, val) {
            attr && val ? $td.attr(attr, val) : '';
          });
        }

        // check for function that format the data
        if (rowData.type && rowData.type == 'date-array') {
          col.formatter = '_list';
        }
        if (col.formatter) {
          if ($.isFunction(col.formatter)) {
            data = col.formatter.call(O, data);
          } else if (_formatter && _formatter.hasOwnProperty(col.formatter)) {
            data = _formatter[col.formatter].call(O, data);
          }
        }

        // fill td with data
        $td.html(data);
      });
      // create row actions 
      if (O.opts.rowActions && O.opts.rowActions.length > 0) {
        // create action col
        var $tdActions = $('<td class="td-actions"></td>').appendTo($tr);

        // create row actions 
        $.each(O.opts.rowActions, function (j, action) {
          // create action element
          var $action = $('<button class="action action-outline-secondary"></button>').attr('id', action.idPrefix + rowIndex).attr('hidden', action.hidden).attr('role', action.role);
          // .appendTo( $tdActions );

          // create action icon
          $action.$icon = $('<i class="feather"></i>').appendTo($action);
          // set icon by class
          action.icon ? $action.$icon.addClass(action.icon) : null;

          // set tooltip and title
          if (action.title) {
            $action.attr('data-tooltip', '').attr('aria-label', action.title).attr('title', action.title);
          }

          // action on click
          if (action.on) {
            if (action.on.click && $.isFunction(action.on.click)) {
              // bind click action on action
              $action.on('click', function (event) {
                var actionIndex = $tr.attr('data-row-id');
                action.on.click.call(O, O, $action, actionIndex, rowData);
              });
            }
          }

          // add action type specific attributes
          if (action.type) {
            // create modal action
            if (action.type == 'modal') {
              $action.attr('data-toggle', 'modal').attr('data-target', action.target).attr('data-modal-id', rowIndex);
            }
          }
          // append to td
          $action.appendTo($tdActions);
        });

        // wrap actions with inner container of td
        $tdActions.wrapInner('<div class="td-actions-container"></div>');
      }
      O.totalRows = O._$tbody.find('tr').length;
    }
    /**
     * CREATE TABLE HEAD
     * @param
     */
  }, {
    key: "_create",
    value: (function () {
      var _create2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var O;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              O = this;
              _log('TABLE / _create', 'primary');

              // current state of view
              O._view = 'default'; // card; //

              // table rows
              O._tableData = O.opts.tableData;
              console.log("aaa ", O._tableData);

              // callback on create
              if ($.isFunction(O.opts.on.create)) {
                O.opts.on.create.call(O, O);
              }
              if (O._tableData) {
                // create table element
                O._$table = $('<table class="table table-striped table-hover"></table>').attr('id', O.opts.ids.table).attr('data-table', '').addClass(O.opts.classes).appendTo(O._$container);

                // wrapper
                if (O.opts.wrapper) {
                  // card
                  if (O.opts.wrapper == 'card') {
                    O._$wrapper = $('<div class="card card-table-main overflow-hidden"></div>');
                    O._$table.wrap(O._$wrapper);
                    O._$table.wrap('<div class="card-body p-0"></div>');
                  }
                }

                // responsive table wrapper
                if (O.opts.responsive) {
                  O._$table.wrap('<div class="table-responsive"></div>');
                }

                // custom classes
                O.opts.classes ? O._$table.addClass(O.opts.classes) : null;

                // card view toggle
                O.opts.showToggle ? O._$table.attr('data-show-toggle', O.opts.showToggle) : null; // bs table / data-show-toggle for view: table/list

                // custom table attributes
                $.each(O.opts.attributes, function (attr, val) {
                  O._$table.attr(attr, val);
                });

                // toolbar
                O._createTableToolbar();

                // create table head
                O._$thead = O._createTableHead(O.opts.cols).appendTo(O._$table);

                // create table head
                O._$tbody = O._createTableBody().appendTo(O._$table);

                // populate table
                O._populateTable(O._tableData);
              }

              // tooltips
              _appUI._initTooltips(O._$container);
            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _create() {
        return _create2.apply(this, arguments);
      }
      return _create;
    }()
    /**
     * CREATE TABLE HEAD
     * @param {array} cols
     */
    )
  }, {
    key: "_createTableHead",
    value: function _createTableHead(cols) {
      var O = this;
      _log('TABLE / _createTableHead');
      // thead
      var $thead = $('<thead></thead>');
      if (O._opts.data) {
        var $checkAll = $('<th class="active"><input type="checkbox" class="select-all checkbox" name="select-all" /></th>').appendTo($thead);
        $checkAll.click(function () {
          this.checked = !this.checked;
          var checked = this.checked;
          $("input.select-item").each(function (index, item) {
            $tr = $(item.closest("tr"));
            if (!$tr.is('.tr-hidden')) {
              $tr.addClass('tr-selected');
              $tr.data('selected', true);
              item.checked = checked;
              if ($.isFunction(O.opts.on.selectAllRow)) {
                var rowData = O._tableData[index];
                O.opts.on.selectAllRow.call(O, O, index, rowData);
              }
            }
          });
        });
      }
      // create th cols
      if (cols) {
        $.each(cols, function (i, col) {
          var $th = $('<th></th>').appendTo($thead);

          // th attributes

          col.label ? $th.html($th.html() + '<span>' + col.label + '</span>') : null;
          col.id ? $th.attr('id', col.id) : null; // id
          col.classes && col.classes.th ? $th.addClass(col.classes.th) : null; // classes
          col.field ? $th.attr('data-field', col.field) : null; // bs table / data-field identifier

          // add sort functionality
          if (col.sortable) {
            $th.attr('data-sortable', col.sortable);
            $th.on('click', function (event) {
              O._updateOrder($th);
            });
            col.sorter ? $th.attr('data-sorter', col.sorter) : null; // bs table / data-sorter function
          }

          // th custom attributes
          if (col.attribute && col.attributes.th) {
            $.each(col.attributes.th, function (attr, val) {
              $th.attr(attr, val);
            });
          }
        });

        // create row actions col
        if (O.opts.rowActions && O.opts.rowActions.length > 0) {
          var $th = $('<th></th>').attr('id', 'colActions').attr('data-field', 'actionsTable').appendTo($thead);
        }
        $thead.wrapInner('<tr></tr>');
      }
      return $thead;
    }

    /**
     * CREATE TABLE TOOLBAR
     * creates button bar above the table for responsive toggle
     */
  }, {
    key: "_createTableToolbar",
    value: function _createTableToolbar() {
      var O = this;
      _log('TABLE / _createTableToolbar');
      if (O.opts.showToggle || O.opts.showColumns) {
        O._$toolbar = $('<div class="table-toolbar"></div>');
        if (O.opts.responsive) {
          O._$toolbar.insertBefore(O._$table.parent());
        } else {
          O._$toolbar.insertBefore(O._$table);
        }
        // place button group
        O._$toolbar._$btnGroup = $('<div class="col-auto btn-group"></div>').appendTo(O._$toolbar).wrap('<div class="ml-auto row justify-content-end"></div>');

        // create toolbar buttons 
        // toggle view
        if (O.opts.showToggle) {
          O._$toolbar._$btnToggleView = $('<button class="btn btn-outline-secondary btn-sm btn-icon toggle-card" type="button"><i class="feather icon-pause"></i></button>').attr('aria-label', 'Toggle view').attr('title', 'Toggle view').attr('data-tooltip', '').attr('data-toggle-table-view', '').appendTo(O._$toolbar._$btnGroup);
          O._$toolbar._$btnToggleView.on('click', function (event) {
            O._toggleTableView();
          });
        }
        if (O._opts.editableToolbarbuttons) {
          $.each(O._opts.editableToolbarbuttons, function (index, element) {
            element.appendTo(O._$toolbar._$btnGroup);
          });
        }
      }
    }

    /**
     * CREATE TABLE BODY
     * @param {object} tableData: metadata object
     */
  }, {
    key: "_createTableBody",
    value: function _createTableBody() {
      var O = this;
      _log('TABLE / _createTableBody');

      // table body
      var $tbody = $('<tbody></tbody>');
      return $tbody;
    }

    /**
     * POPULATE TABLE
     * @param {object} tableData: data object
     */
  }, {
    key: "_populateTable",
    value: function _populateTable(tableData) {
      var _this = this;
      var O = this;
      _log('TABLE / _populateTable');
      O._clear();
      tableData = tableData || O._tableData;

      // create rows
      $.each(tableData, function (rowIndex, rowData) {
        _this.addRow(rowIndex, rowData, tableData, 'true');
      });

      // callback
      if ($.isFunction(O.opts.on.afterPopulate)) {
        O.opts.on.afterPopulate.call(O, O, O._tableData);
      }
    }

    /**
     * UPDATE ORDER
     * returns col index by field identifier
     * @param {string} field name of the column
     */
  }, {
    key: "_updateOrder",
    value: function _updateOrder($th) {
      var O = this;
      _log('TABLE / _updateOrder');
      var field = $th.data('field');
      var $rows = O._$tbody.find('tr').toArray();
      var col = O._getColIndexByField(field);

      // if selected item has alreay asc or desc class, just reverse contents
      if ($th.is('.asc') || $th.is('.desc')) {
        // toggle to other class
        $th.toggleClass('asc desc');

        // reverse the array
        O._$tbody.append($rows.reverse());
      }
      // otherwise perform a sort 
      else {
        // add class to header                            
        $th.addClass('asc');

        // remove asc or desc from all other headers
        $th.siblings().removeClass('asc desc');
        var fieldSorter = $th.data('sorter') || '_name';
        _log('sort by : ' + field + ' with ' + fieldSorter, 'level1');
        if (fieldSorter) {
          // fieldsorter is a function
          if ($.isFunction(fieldSorter)) {
            $rows.sort(function (a, b) {
              aa = $(a).find('td').eq(col).text(); // get text of column in row a
              bb = $(b).find('td').eq(col).text(); // get text of column in row b
              log(aa + ' / ' + bb);
              fieldSorter.call(aa, bb);
            });
          }
          // or fieldsorter is a sub routine of _sorter
          else if (_sorter && _sorter.hasOwnProperty(fieldSorter)) {
            // call sort() on rows array
            $rows.sort(function (a, b) {
              aa = $(a).find('td').eq(col).text(); // get text of column in row a
              bb = $(b).find('td').eq(col).text(); // get text of column in row b

              // call compare method
              return _sorter[fieldSorter](aa, bb);
            });
          }
          O._$tbody.append($rows);
        }
      }
    }

    /**
     * GET COL INDEX BY FIELD
     * returns col index by field identifier
     * @param {string} field name of the column
     */
  }, {
    key: "_getColIndexByField",
    value: function _getColIndexByField(field) {
      var O = this;
      var colIndex = -1;
      $.each(O.opts.cols, function (i, col) {
        if (field == col.field) {
          colIndex = i;
        }
      });
      return colIndex;
    }

    /**
     * CLEAR TABLE
     * removes table body rows
     */
  }, {
    key: "_clear",
    value: function _clear() {
      var O = this;
      _log('TABLE / _clear');
      if (O._$tbody) {
        O._$tbody.empty();
      }
    }

    /**
     * TOGGLE VIEW
     * change view of table <> card
     */
  }, {
    key: "_toggleTableView",
    value: function _toggleTableView(event) {
      var O = this;
      _log('TABLE / _toggleTableView');
      _log(O._view);
      // current state = default => set card view class
      if (O._view == 'default') {
        O._view = 'card';
        O._$table.addClass('table-view-card');
        // update toggles class
        O._$toolbar._$btnToggleView.removeClass('toggle-card').addClass('toggle-default');
      }
      // current state != default => set remove view class
      else {
        O._view = 'default';
        O._$table.removeClass('table-view-card');
        // update toggles class
        O._$toolbar._$btnToggleView.removeClass('toggle-default').addClass('toggle-card');
      }
    }

    /**
     * SELECT ROW
     * select or deselect a certain row
     * @param {dom object} $tr: jquery element 
     */
  }, {
    key: "_handleRowSelect",
    value: function _handleRowSelect($tr) {
      var O = this;
      // rows selectable and tr exists
      if (O.opts.rowSelectable && $tr) {
        // get current state
        var isSelected = $tr.data('selected');
        // already selected
        if (isSelected) {
          O._deselectRow($tr);
          $tr.find("input.checkbox").prop('checked', false);
        } else {
          // deselect all
          if (O.opts.rowSelectable == 'single') {
            O._deselectAllRows();
            O._selectRow($tr);
          } else {
            O._selectRow($tr);
          }
          $tr.find("input.checkbox").prop('checked', true);
        }
      }
    }

    /**
     * SELECT ROW
     * select a certain row
     * @param {dom object} $tr: jquery element 
     */
  }, {
    key: "_selectRow",
    value: function _selectRow($tr) {
      var O = this;
      _log('TABLE / _selectRow : ' + $tr.data('row-id'));
      if ($tr) {
        var rowIndex = $tr.data('row-id');
        var rowData = O._tableData[rowIndex];
        // add class marker
        $tr.addClass('tr-selected');
        $tr.data('selected', true);

        // callback on select row
        if ($.isFunction(O.opts.on.selectRow)) {
          O.opts.on.selectRow.call(O, O, rowIndex, rowData);
        }
      }
    }

    /**
     * DESELECT ROW
     * deselect a certain row
     * @param {dom object} $tr: jquery element 
     */
  }, {
    key: "_deselectRow",
    value: function _deselectRow($tr) {
      var O = this;
      _log('TABLE / _deselectRow : ' + $tr.data('row-id'));
      if ($tr) {
        var rowIndex = $tr.data('row-id');
        var rowData = O._tableData[rowIndex];

        // remove class marker
        $tr.removeClass('tr-selected');
        $tr.data('selected', false);

        // callback on de-select row
        if ($.isFunction(O.opts.on.deselectRow)) {
          O.opts.on.deselectRow.call(O, O, rowIndex, rowData);
        }
      }
    }

    /**
     * DESELECT ALL ROWS
     * deselect all rows
     */
  }, {
    key: "_deselectAllRows",
    value: function _deselectAllRows() {
      var O = this;
      _log('TABLE / _deselectAllRows');
      O._$table.find('.tr-selected').each(function (i, tr) {
        var $tr = $(tr);
        // remove class marker
        $tr.removeClass('tr-selected');
        $tr.data('selected', false);
      });
    }

    /**
     * GET SELECTD ROWS
     * deselect all rows
     * @return {object} tabledData filtered by rows selected
     */
  }, {
    key: "_getSelectedRows",
    value: function _getSelectedRows() {
      var O = this;
      _log('TABLE / _getSelectedRows');
      var selectedRows = [];

      // check all table rows
      $.each(O._tableData, function (i, row) {
        // row is currently selected and not hidden
        if (row.el.is('.tr-selected') && !row.el.is('.tr-hidden')) {
          selectedRows.push(row);
        }
      });
      return selectedRows;
    }

    /**
     * UPDATE STRIPES
     * updates stripe classes for each row
     */
  }, {
    key: "_updateStripes",
    value: function _updateStripes() {
      var O = this;
      _log('TABLE / _updateStripes');
      if (O._$table.is('.table-striped')) {
        // update stripes
        O._$tbody.find('tr:not(.tr-hidden)').each(function (i, tr) {
          var $tr = $(tr);
          $tr.removeClass('tr-odd tr-even');
          if ((i + 1) % 2 == 0) {
            $tr.addClass('tr-even');
          } else {
            $tr.addClass('tr-odd');
          }
        });
      }
    }
  }]);
}();

},{}],53:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.APPTableMT = void 0;
var _APPTable2 = require("./APPTable.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*

version: 1.0.0
author: sascha obermller
date: 06.12.2020

*/
var APPTableMT = exports.APPTableMT = /*#__PURE__*/function (_APPTable) {
  function APPTableMT(settings, $container, metadata, uploadDates, executionTimes) {
    _classCallCheck(this, APPTableMT);
    // defaults maintable
    var tableSettings = $.extend(true, {}, {
      classes: 'table-main',
      ids: {
        table: 'mtGrid',
        thead: 'mtHead',
        tbody: 'mtRows',
        filter: 'mtFilter'
      },
      rowActions: [],
      rowSelectable: false,
      //'multiple', // 'single', // 
      wrapper: 'card',
      on: {
        afterInit: null,
        selectRow: null,
        selectAllRow: null,
        deselectRow: null,
        updateFilter: null
      }
    }, settings);
    return _callSuper(this, APPTableMT, [tableSettings, $container, metadata, uploadDates, executionTimes]);
  }
  _inherits(APPTableMT, _APPTable);
  return _createClass(APPTableMT, [{
    key: "_create",
    value: function () {
      var _create2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var O;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              O = this;
              _log('TABLE MAIN / _create', 'primary');
              O._facets = {}; // column facets
              O._filtered = []; // all hidden/filtered rows

              // current state of view
              O._view = 'default'; // card; //

              // loader
              O._loader = _appUI._createLoader({
                classes: 'loader-page'
              }, O._$container);
              O._loader._setState(true);
              if (O._metadata) {
                _context.next = 10;
                break;
              }
              _context.next = 10;
              return O._createData();
            case 10:
              if (!(!O._uploadDates || O._uploadDates.length == 0)) {
                _context.next = 13;
                break;
              }
              _context.next = 13;
              return O._createDataMetadata();
            case 13:
              _context.next = 15;
              return O._prepareDataTable();
            case 15:
              // set loader
              O._loader._setState(false);

              // callback on create
              if ($.isFunction(O.opts.on.create)) {
                O.opts.on.create.call(O, O);
              }
              if (O._tableData) {
                // create filter
                O._createFilter();

                // create table element
                O._$table = $('<table class="table table-striped table-hover table-main"></table>').appendTo(O._$container).attr('id', O.opts.ids.table);

                // wrapper
                if (O.opts.wrapper) {
                  // card
                  if (O.opts.wrapper == 'card') {
                    O._$table.add(O._$filter).wrapAll($('<div class="card card-table-main overflow-hidden"></div>'));
                    O._$table.wrap('<div class="card-body p-0"></div>');
                    O._$filter.wrap('<div class="card-header p-0"></div>');
                  }
                }

                // responsive table wrapper
                if (O.opts.responsive) {
                  O._$table.wrap('<div class="table-responsive"></div>');
                }

                // card view toggle
                O.opts.showToggle ? O._$table.attr('data-show-toggle', O.opts.showToggle) : null; // bs table / data-show-toggle for view: table/list

                // custom table attributes
                $.each(O.opts.attributes, function (attr, val) {
                  O._$table.attr(attr, val);
                });

                // toolbar
                O._createTableToolbar();

                // create table head
                O._$thead = O._createTableHead(O.opts.cols).appendTo(O._$table);

                // create table head
                O._$tbody = O._createTableBody(O._tableData).appendTo(O._$table);

                // populate table
                O._populateTable(O._tableData);
                _appUI._initTdCollapse(O._$table);

                // set counter
                O._updateFilter();
              }

              // tooltips
              _appUI._initTooltips(O._$container);
            case 19:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _create() {
        return _create2.apply(this, arguments);
      }
      return _create;
    }()
    /**
     * _refresh
     * _refresh the table after editing.
     * @param {string} query
     */
  }, {
    key: "_refresh",
    value: (function () {
      var _refresh2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(index, modelMetadata) {
        var O, rowData, modelName, software, environment, hazard, modelType;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              O = this;
              rowData = O._tableData[index];
              rowData.modelMetadata = modelMetadata;
              modelName = O._getData(modelMetadata, 'generalInformation', 'name');
              rowData.el.find('td[data-label="Model"]').html(modelName);
              software = O._getData(modelMetadata, 'generalInformation', 'software');
              rowData.el.find('td[data-label="Software"]').html(software);
              environment = O._getScopeData(modelMetadata, 'scope', 'product', 'productName');
              rowData.el.find('td[data-label="Environment"]').html(environment);
              hazard = O._getScopeData(modelMetadata, 'scope', 'hazard', 'hazardName');
              rowData.el.find('td[data-label="Hazard"]').html(hazard);
              //let modelType = modelMetadata['modelType'];
              modelType = "Generic model";
              if (modelMetadata['generalInformation']['modelCategory']) {
                modelType = modelMetadata['generalInformation']['modelCategory']['modelClass'] ? modelMetadata['generalInformation']['modelCategory']['modelClass'] : "Generic model";
              }

              // special case: (Data) -> Data model
              if (modelType === "(Data)") {
                modelType = "Data model";
              }
              rowData.el.find('td[data-label="Type"]').html(modelType);
              // update sets
              if (software) O._updateSet('software', software);
              if (environment) {
                environment.forEach(function (x) {
                  O._updateSet('environment', x);
                });
              }
              if (hazard) {
                hazard.forEach(function (x) {
                  O._updateSet('hazard', x);
                });
              }
              if (modelType) O._updateSet('modelType', modelType);
            case 19:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _refresh(_x, _x2) {
        return _refresh2.apply(this, arguments);
      }
      return _refresh;
    }()
    /**
     * CREATE DATA
     * create tabledata
     */
    )
  }, {
    key: "_createData",
    value: (function () {
      var _createData2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var O;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              O = this;
              _log('TABLE MAIN / _createData');
              _context3.next = 4;
              return _fetchData._json(window._endpoints.metadata);
            case 4:
              O._metadata = _context3.sent;
              //O._app._getMetadata();

              _log(O._tableData);
            case 6:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function _createData() {
        return _createData2.apply(this, arguments);
      }
      return _createData;
    }())
  }, {
    key: "_createDataMetadata",
    value: function () {
      var _createDataMetadata2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        var O;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              O = this;
              _log('TABLE MAIN / _createDataMetadata');

              //O._uploadDates = await _fetchData._array( window._endpoints.uploadDate, O._metadata.length ); //O._app._getUploadDates( window._endpoints.uploadDate, O._metadata.length );
              //O._executionTimes = await _fetchData._array( window._endpoints.executionTime, O._metadata.length ); //O._app._getExecutionTimes( window._endpoints.executionTime, O._metadata.length );
              _context4.next = 4;
              return _fetchData._json(window._endpoints.uploadDate);
            case 4:
              O._uploadDates = _context4.sent;
              _context4.next = 7;
              return _fetchData._json(window._endpoints.executionTime);
            case 7:
              O._executionTimes = _context4.sent;
              //O._app._getExecutionTimes( window._endpoints.executionTime, O._metadata.length );

              _log(O._tableData);
            case 9:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function _createDataMetadata() {
        return _createDataMetadata2.apply(this, arguments);
      }
      return _createDataMetadata;
    }()
  }, {
    key: "_prepareDataTable",
    value: function () {
      var _prepareDataTable2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var O, _loop, identifier, i;
        return _regeneratorRuntime().wrap(function _callee5$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _log('TABLE MAIN / _prepareDataTable', 'primary');
              O = this; // prepare table data
              O._tableData = [];
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
                var modelMetadata, rowData;
                return _regeneratorRuntime().wrap(function _loop$(_context5) {
                  while (1) switch (_context5.prev = _context5.next) {
                    case 0:
                      modelMetadata = O._metadata[i]; // full metadata of model
                      identifier = modelMetadata['generalInformation']['identifier'];
                      rowData = {
                        modelMetadata: modelMetadata,
                        // storess full model metadata for callbacks/hooks
                        cells: [],
                        // will contain raw cell value
                        el: null // will be added later in _populateTable
                      }; // model data container for table output
                      // create table data of models for output

                      $.each(O.opts.cols, function (j, col) {
                        var data = null;
                        if (col.field == 'modelName') {
                          data = O._getData(modelMetadata, 'generalInformation', 'name');
                        } else if (col.field == 'software') {
                          data = O._getData(modelMetadata, 'generalInformation', 'software');
                        } else if (col.field == 'hazard') {
                          data = O._getScopeData(modelMetadata, 'scope', 'hazard', 'hazardName');
                          // if formatter is not list join array
                          if (col.formatter != '_list') {
                            data = Array.from(data).join(' ');
                          }
                          // let joiner = col.formatter == 'list' ? '||' ' ';
                          // data = Array.from( data ).join( '' );
                        } else if (col.field == 'environment') {
                          data = O._getScopeData(modelMetadata, 'scope', 'product', 'productName');
                          // if formatter is not list join array
                          if (col.formatter != '_list') {
                            data = Array.from(data).join(' ');
                          }
                        } else if (col.field == 'modelType') {
                          data = "Generic model";
                          if (modelMetadata['generalInformation']['modelCategory']) {
                            data = modelMetadata['generalInformation']['modelCategory']['modelClass'] ? modelMetadata['generalInformation']['modelCategory']['modelClass'] : "Generic model";
                          }
                          // special case: (Data) -> Data model
                          if (data === "(Data)") {
                            data = "Data model";
                          }
                        } else if (col.field == 'executionTime') {
                          data = O._executionTimes[identifier] ? O._executionTimes[identifier] : "";
                        } else if (col.field == 'uploadDate') {
                          data = O._uploadDates[identifier] ? O._uploadDates[identifier] : "";
                        }
                        rowData.cells.push(data);
                      });
                      O._tableData.push(rowData);
                    case 5:
                    case "end":
                      return _context5.stop();
                  }
                }, _loop);
              });
              i = 0;
            case 5:
              if (!(i < O._metadata.length)) {
                _context6.next = 10;
                break;
              }
              return _context6.delegateYield(_loop(), "t0", 7);
            case 7:
              i++;
              _context6.next = 5;
              break;
            case 10:
              _log(O._tableData);
            case 11:
            case "end":
              return _context6.stop();
          }
        }, _callee5, this);
      }));
      function _prepareDataTable() {
        return _prepareDataTable2.apply(this, arguments);
      }
      return _prepareDataTable;
    }()
    /**
     * CREATE FILTER
     * @param
     */
  }, {
    key: "_createFilter",
    value: function _createFilter() {
      var O = this;
      _log('TABLE MAIN / _createFilter');

      // prepare sets for filter
      O._sets = O._sets || {};
      O._sets.software = new Set();
      O._sets.environment = new Set();
      O._sets.hazard = new Set();
      O._sets.modelType = new Set();
      for (var i = 0; i < O._metadata.length; i++) {
        var modelMetadata = O._metadata[i];
        var software = O._getData(modelMetadata, 'generalInformation', 'software');
        var environment = O._getScopeData(modelMetadata, 'scope', 'product', 'productName');
        var hazard = O._getScopeData(modelMetadata, 'scope', 'hazard', 'hazardName');
        //let modelType = modelMetadata['modelType'];

        var modelType = "Generic model";
        if (modelMetadata['generalInformation']['modelCategory']) {
          modelType = modelMetadata['generalInformation']['modelCategory']['modelClass'] ? modelMetadata['generalInformation']['modelCategory']['modelClass'] : "Generic model"; //_modelMetadata2['modelType'];				
        }
        // special case: (Data) -> Data model
        if (modelType === "(Data)") {
          modelType = "Data model";
        }

        // update sets
        if (software) O._updateSet('software', software);
        if (environment) {
          environment.forEach(function (x) {
            O._updateSet('environment', x);
          });
        }
        if (hazard) {
          hazard.forEach(function (x) {
            O._updateSet('hazard', x);
          });
        }
        if (modelType) O._updateSet('modelType', modelType);
      }

      // create table element
      O._$filter = $('<div class="filter">').attr('id', O.opts.ids.filter).appendTo(O._$container);

      // navbar
      var $navbar = $('<nav class="navbar navbar-expand-lg row justify-content-between"></nav>').appendTo(O._$filter);

      // navbar toggle
      var $navbarToggle = $('<button class="action action-pure collapsed" type="button" data-tooltip data-toggle="collapse" data-target="#mainTableFilterFacets" aria-controls="mainTableFilter" aria-expanded="false" title="Toggle Filter" aria-label="Toggle Filter"><span class="feather icon-sliders"></span></button>');
      $navbarToggle.appendTo($navbar).wrap('<div class="navbar-toggler col-auto order-1 filter-toggler"></div>');

      // divider 1
      $navbar.append('<div class="col-divider order-2 d-block d-lg-none"></div>');

      // filter search
      O._$search = $('<input id="mainTableFilterSearch" class="form-control form-control-plaintext search-input" type="search" placeholder="Search Models" aria-label="Search Models" />').appendTo($navbar).wrap('<div class="col col-xxs-auto order-3 filter-search">').wrap('<div class="search w-100"></div>');

      // search clear button
      O._$searchClear = $('<button class="search-clear" data-clear="#mainTableFilterSearch"><i class="feather icon-x"></i></button>').insertAfter(O._$search);

      // custom search
      O._$search.on('keyup, change', function (event) {
        // get the query by updating filter
        O._updateFilter();
      });

      // divider 2
      $navbar.append('<div class="col-divider order-4 d-none d-xxs-block"></div>');

      // facets
      O._$facets = $('<div id="mainTableFilterFacets" class="collapse navbar-collapse row mt-1 mt-lg-0 facets"></div>');
      O._$facets.appendTo($navbar).wrap('<div class="col-12 col-lg-8 order-5 order-xss-6 order-lg-5 filter-facets">');
      // create all facets of cols
      $.each(O.opts.cols, function (i, col) {
        if (col.field && col.facet) {
          var $facet = $('<select class="form-control form-control-sm" style="" multiple="multiple"></select>');
          $facet.appendTo(O._$facets);

          // crate facet wrapper
          var $facetWrapper = $('<div class="col-12 col-xs-6 col-md-3 facet"></div>');
          col.facet.tooltip && col.facet.placeholder ? $facetWrapper.attr('data-tooltip', col.facet.tooltip) : null;
          col.facet.tooltip && col.facet.placeholder ? $facetWrapper.attr('title', 'Filter by ' + col.facet.placeholder) : null;
          $facet.wrap($facetWrapper);

          // set unique id
          if (col.id) {
            $facet.id = col.id + 'Facet';
          } else {
            $facet.id = 'facet-' + $.now();
          }

          // facet attributes
          $facet.attr('id', $facet.id);
          col.facet.select2 ? $facet.attr('data-sel2', col.facet.select2) : null;
          col.facet.select2SingleRow ? $facet.attr('data-sel2-choice-single-row', col.facet.select2SingleRow) : null;
          col.facet.placeholder ? $facet.attr('data-placeholder', col.facet.placeholder) : null;
          col.facet.maxSelectable ? $facet.attr('data-maximum-selection-length', col.facet.maxSelectable) : null;

          // create action on filter facet
          $facet.on('change', function (event) {
            O._updateFilter();
          });
          O._facets[col.field] = {
            el: $facet
          };

          // populate facet select
          if (col.id && O._sets[col.field]) {
            _appUI._populateSelect($facet, O._sets[col.field]);
          }
        }
      });

      // facets clear
      var $facetsClear = $('<button class="action action-pure" data-tooltip title="Clear Filter"><i class="feather icon-x"></i></button>').appendTo(O._$facets).wrap('<div class="facets-clear"></div>');

      // set clear options of facets clear
      var facetsIds = [];
      $.each(O._facets, function (i, item) {
        facetsIds.push('#' + item.el.id);
      });
      $facetsClear.attr('data-clear', facetsIds.join(','));

      // init facets functions
      _appUI._initClear(O._$navbar);
      _appUI._initSelect2(O._$facets);

      // result counter
      O._$counter = $('<small id="mainTableCounter"></small>').appendTo($navbar).wrap('<div class="col-auto align-items-center order-6 order-xxs-4 order-lg-6 mt-2 mt-xxs-0 filter-counter">');
    }

    /**
     * SET COUNTER
     * set main table result counter
     * @param {boolean} state: false=hide, true=show
     */
  }, {
    key: "_updateCounter",
    value: function _updateCounter() {
      var O = this;
      var counterText = '';

      // filtered items?
      if (O._tableData.length - O._filtered.length > 0) {
        counterText = O._filtered.length + '/' + O._tableData.length;
      } else {
        counterText = O._filtered.length;
      }
      // append default label text
      counterText += ' models';

      // set counter text to elem
      counterText && O._$counter ? O._$counter.html(counterText) : null;
    }

    /**
     * SEARCH
     * search on enpoint for query
     * @param {string} query
     */
  }, {
    key: "_search",
    value: (function () {
      var _search2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(query) {
        var O, result;
        return _regeneratorRuntime().wrap(function _callee6$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              O = this;
              _log('TABLE MAIN / _search : ' + query, 'secondary');
              O._loader._setState(true);

              // fetch result from endpoint
              _context7.next = 5;
              return _fetchData._json(window._endpoints.search, query);
            case 5:
              result = _context7.sent;
              O._highlight(query);
              O._loader._setState(false);
              return _context7.abrupt("return", result);
            case 9:
            case "end":
              return _context7.stop();
          }
        }, _callee6, this);
      }));
      function _search(_x3) {
        return _search2.apply(this, arguments);
      }
      return _search;
    }()
    /**
     * HIGHLIGHT
     * highlight text matching query
     * @param {string} query
     */
    )
  }, {
    key: "_highlight",
    value: function _highlight(query) {
      var O = this;
      if (query && query.length > 0 && query != '%20') {
        $.each(O._tableData, function (rowIndex, rowData) {
          rowData.el.find('td').each(function (j, td) {
            var $td = $(td);
            if (!$td.is('.td-actions')) {
              var value = $td.html();
              value = _formatter._searchHighlight(value, query);
              $td.html(value);
            }
          });
        });
      }
    }

    /**
     * UPDATE FILTER
     * updates all filter and counter
     */
  }, {
    key: "_updateFilter",
    value: (function () {
      var _updateFilter2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        var _this = this;
        var O, searchQuery, searchResult;
        return _regeneratorRuntime().wrap(function _callee7$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              O = this;
              _log('TABLE MAIN / _updateFilter');
              O._filtered = []; // stores all hidden/filtered rows
              if (!O._$filter) {
                _context8.next = 16;
                break;
              }
              // clear on update
              // remove all highlighting
              O._$table.find('mark').contents().unwrap();

              // search 
              searchQuery = O._$search.val() == undefined || O._$search.val() == '' ? '%20' : O._$search.val().trim().toLowerCase();
              searchResult = [];
              if (!searchQuery) {
                _context8.next = 11;
                break;
              }
              _context8.next = 10;
              return O._search(searchQuery);
            case 10:
              searchResult = _context8.sent;
            case 11:
              // check each row for matchings
              $.each(O._tableData, function (rowIndex, rowData) {
                // initale state for each row 
                // match = true : will be shown
                var rowMatchesFilter = true;

                // if search result is empty, no match was found
                if (searchResult.length == 0) {
                  rowMatchesFilter = false;
                }
                // filter by search
                if (searchResult.length > 0 && !searchResult.includes(rowIndex)) {
                  rowMatchesFilter = false;
                }

                // filter by cols
                if (rowMatchesFilter) {
                  $.each(O._facets, function (field, facet) {
                    var facetValue = facet.el.val();
                    if ($.isArray(facetValue) && facetValue.length > 0) {
                      // get according col index
                      var colIndex = _get(_getPrototypeOf(APPTableMT.prototype), "_getColIndexByField", _this).call(_this, field);
                      var cellData = rowData.cells[colIndex];
                      if (cellData instanceof Set) {
                        var cellMatches = false;
                        $.each(facetValue, function (i, val) {
                          // check set for matching one of the facet values
                          //cellData.has( val ) ? cellMatches = true : null;
                          var _iterator = _createForOfIteratorHelper(cellData),
                            _step;
                          try {
                            for (_iterator.s(); !(_step = _iterator.n()).done;) {
                              var element = _step.value;
                              element.includes(val.trim()) ? cellMatches = true : null;
                            }
                          } catch (err) {
                            _iterator.e(err);
                          } finally {
                            _iterator.f();
                          }
                        });
                        if (!cellMatches) {
                          rowMatchesFilter = false;
                        }
                      } else {
                        if (!cellData.includes(facetValue)) {
                          // row data does not match
                          rowMatchesFilter = false;
                        }
                      }
                    }
                  });
                }

                // _log( 'row '+ rowIndex + ' > '+ rowMatchesFilter );
                if (rowMatchesFilter && !O._filtered.includes(rowIndex)) {
                  O._filtered.push(rowIndex); // row matches all filter facets citeria
                }

                // apply filter class on each row
                if (rowMatchesFilter) {
                  rowData.el.removeClass('tr-hidden');
                } else {
                  rowData.el.addClass('tr-hidden');
                }
              });
              O._updateStripes();

              // TO DO 
              // re-populate facets with visible sets only ?

              _log(O._filtered);

              // callback
              if ($.isFunction(O.opts.on.updateFilter)) {
                O.opts.on.updateFilter.call(O, O, O._filtered);
              }
              O._updateCounter();
            case 16:
            case "end":
              return _context8.stop();
          }
        }, _callee7, this);
      }));
      function _updateFilter() {
        return _updateFilter2.apply(this, arguments);
      }
      return _updateFilter;
    }()
    /**
     * GET SET
     * @param {string} name: name of the set 
     */
    )
  }, {
    key: "_getSet",
    value: function _getSet(name) {
      var O = this;
      // _log( 'TABLE MT / _getSet' );

      if (name in O._sets) {
        return O._sets.name;
      } else {
        return O._sets;
      }
    }

    /**
     * UPDATE SET
     * @param {string} name: name of the set 
     * @param {string} data: new data 
     */
  }, {
    key: "_updateSet",
    value: function _updateSet(name, data) {
      var O = this;
      _log('TABLE MT / _updateSet');
      if (name) {
        O._sets[name].add(data);
      }
    }

    /**
     * GET DATA
     * get a metadata property or return empty string if missing.
     * @param {object} modelMetadata: whole metadata of a model
     * @param {string} toplevel: name of the metadata component. it can be
     *  *generalInformation*, *scope*, *dataBackground* or *modelMath*.
     * @param {string} name: name of the metadata property 
     */
  }, {
    key: "_getData",
    value: function _getData(modelMetadata, toplevel, name) {
      var O = this;
      // _log( 'TABLE MT / _getData' );

      try {
        return modelMetadata[toplevel][name];
      } catch (err) {
        return 'no information for ' + name;
      }
    }

    /**
     * GET SCOPEDATA
     * get metadata property or return empty string if missing.
     * @param {object} modelMetadata: whole metadata of a model
     * @param {string} toplevel: name of the metadata component. It can be
     *  *generalInformation*, *scope*, *dataBackground* or *modelMath*.
     * @param {string} sublevel: Name of metadata comonent like *product*, *hazard*
     * @param {string} name: name of the metadata property 
     */
  }, {
    key: "_getScopeData",
    value: function _getScopeData(modelMetadata, toplevel, sublevel, name) {
      var O = this;
      // _log( 'TABLE MT / _getScopeData' );

      try {
        var subs = modelMetadata[toplevel][sublevel];
        names = new Set();
        subs.forEach(function (it) {
          var element = it[name];
          if (!element) element = it['name'];
          names.add(element);
        });
        return names;
      } catch (err) {
        return new Set().add('no information');
      }
    }

    /**
        * GET COL INDEX BY FIELD 
     * (adjusted for checkbox column which add +1 column)
        * returns col index by field identifier
        * @param {string} field name of the column
        */
  }, {
    key: "_getColIndexByField",
    value: function _getColIndexByField(field) {
      var O = this;
      console.log("_getColIndexByField child");
      var colIndex = -1;
      $.each(O.opts.cols, function (i, col) {
        if (field == col.field) {
          colIndex = i + 1;
        }
      });
      return colIndex;
    }
  }]);
}(_APPTable2.APPTable);

},{"./APPTable.js":52}],54:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.APPUI = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/*

version: 1.0.0
author: sascha obermller
date: 04.12.2020

*/
var APPUI = exports.APPUI = /*#__PURE__*/function () {
  function APPUI(settings) {
    _classCallCheck(this, APPUI);
    var O = this;
    O._debug = true;
    // defaults
    O._opts = $.extend(true, {}, {
      on: {
        afterInit: null
      }
    }, settings);
  }
  return _createClass(APPUI, [{
    key: "opts",
    get: function get() {
      return this._opts;
    },
    set: function set(settings) {
      this._opts = $.extend(true, {}, this.opts, settings);
    }

    /**
     * CREATE TABLE HEAD
     * @param {array} settings
     */
  }, {
    key: "_createTableHead",
    value: function _createTableHead(settings) {
      // thead
      var $thead = $('<thead></thead>');
      if (settings) {
        // thead id
        settings.id ? $thead.attr('id', settings.id) : null;

        // create th cols
        if (settings.cols) {
          $.each(settings.cols, function (i, col) {
            var $th = $('<th></th>').appendTo($thead);
            // th attributes
            col.label ? $th.html('<span>' + col.label + '</span>') : null;
            col.id ? $th.attr('id', col.id) : null; // id
            col.classes && col.classes.th ? $th.addClass(col.classes.th) : null; // classes
            col.field ? $th.attr('data-field', col.field) : null; // bs table / data-field identifier
            col.sortable ? $th.attr('data-sortable', col.sortable) : null; // bs table / data-sortable
            col.switchable ? $th.attr('data-switchable', col.switchable) : null; // bs table / data-switchable
            col.sorter ? $th.attr('data-sorter', col.sorter) : null; // bs table / data-sorter function

            // th custom attributes
            if (col.attribute && col.attributes.th) {
              $.each(col.attributes.th, function (attr, val) {
                $th.attr(attr, val);
              });
            }
          });
          $thead.wrapInner('<tr></tr>');
        }
      }
      return $thead;
    }

    /**
     * CREATE MODAL
     * @param {array} settings
     * @param {jquery selector/object} $container: append to this
     */
  }, {
    key: "_createModal",
    value: function _createModal(settings, $container) {
      var O = this;
      _log('UI / _createModal');
      return new APPModal(settings, $container);
    }

    /**
     * CREATE LOADER
     * create page loader
     * @param {array} settings
     * @param {jquery selector/object} $container: append to this
     */
  }, {
    key: "_createLoader",
    value: function _createLoader(settings, $container) {
      var O = this;
      _log('UI / _createLoader');
      var loader = {};
      loader._$el = $('<div class="loader loading"></div>').appendTo($container);
      // optional classes
      settings.classes ? loader._$el.addClass(settings.classes) : null;
      loader._setState = function (state) {
        _log('UI / loader._setState : ' + state);
        state ? loader._$el.addClass('loading') : loader._$el.removeClass('loading');
      };
      return loader;
    }

    /**
     * CREATE ALERT
     * create alert and place it into $container
     * @param {array} settings
     * @param {jquery selector/object} $container: append to this
     */
  }, {
    key: "_createAlert",
    value: function _createAlert(msg, settings, $container) {
      var O = this;
      _log('UI / _createAlert');
      var $alert = $('<div class="alert fade">' + msg + '</div>').appendTo($container);

      // alert type
      settings.type ? $alert.addClass('alert-' + settings.type) : $alert.addClass('alert-info'); // bs type: primary, secondary, success, danger, warning, info
      settings.state ? $alert.addClass(settings.state) : $alert.addClass('show'); // hide or show
      settings.classes ? $alert.addClass(settings.classes) : null;

      // dismissable
      if (settings.dismissable) {
        $alert.addClass('alert-dismissable');
        // close button
        $alert.append('<button type="button" class="close close-sm" data-dismiss="alert" aria-label="Close"><i class="feather icon-x" aria-hidden="true"></i></button>');
      }
      return $alert;
    }
  }, {
    key: "_precision",
    value: function _precision(param) {
      var step = 1;
      // add case if parameter is integer (no decimal point)
      var decimals = param.includes(".") ? param.substring(param.indexOf('.') + 1).length : 0;
      for (var j = 0; j < decimals; j++) {
        step = step / 10;
      }
      return step;
    }
    /**
     * POPULATE SELECT
     *
     * @param {element} select: dom element
     * @param {array} options: array of possible values
     */
  }, {
    key: "_populateSelect",
    value: function _populateSelect($select, options) {
      var O = this;
      if ($select) {
        options.forEach(function (entry) {
          $select.append('<option value="' + entry + '">' + entry + '</option>');
        });
      }
    }

    /**
     * POPULATE SELECT BY ID
     *
     * @param {string} selectID: element id
     * @param {array} options: array of possible values
     */
  }, {
    key: "_populateSelectByID",
    value: function _populateSelectByID(selectID, options) {
      var O = this;
      var $select = $(selectID);
      O._populateSelect($select, options);
    }

    /**
     * CREATE TOOLTIPS
     * initialize tooltips on all elements with data-attribute [data-tooltip]
     * @param {string/jquery selector} container: dom-element that contains the elements to init
     */
  }, {
    key: "_initTooltips",
    value: function _initTooltips(container) {
      var O = this;
      _log('UI / _initTooltips');
      var $elems = $(container).length > 0 ? $(container).find('[data-tooltip]') : $('[data-tooltip]');
      $elems.each(function (i, el) {
        var $el = $(el);
        // create tooltips
        $el.tooltip({
          offset: 10
        });
      });
    }

    /**
     * INIT TOGGLE TD
     * adds a collapsable container on element <td data-td-collapse>, when td's content height is higher than defined min-height
     * must be initiated before bs table init
     * @param {string/jquery selector} container: dom-element that contains the elements to init
     */
  }, {
    key: "_initTdCollapse",
    value: function _initTdCollapse($table) {
      var O = this;
      _log('UI / _initTdCollapse');
      var minH = 100;
      var $tds = $table.find('td[data-td-collapse="true"]');
      $tds.each(function (i, td) {
        var $td = $(td); // td
        $td.wrapInner('<div></div>');

        // check for content higher than min height
        if ($td.children().outerHeight() > minH) {
          // create unique id
          var collapseId = 'tdCollapse' + jQuery.now();
          // wrap inner with collapse container
          $td.wrapInner('<div id="' + collapseId + '" class="collapse td-collapse"></div>');
          // create toggle
          var $collapseToggle = $('<a href="#" class="td-collapse-toggle collapsed" data-target="#' + collapseId + '" data-toggle="collapse" aria-expanded="false" aria-controls="' + collapseId + '"></a>').appendTo($td);
          // create collapse
          $('#' + collapseId).collapse({
            toggle: false
          });
        }
      });
    }

    /**
     * INIT SELECT2
     * initialize select2 lib on element <select data-sel2 >
     * @param {string/jquery selector} container: dom-element that contains the elements to init
     */
  }, {
    key: "_initSelect2",
    value: function _initSelect2(container) {
      var O = this;
      _log('UI / _initSelect2');
      var $elems = $(container).length > 0 ? $(container).find('select[data-sel2]') : $('select[data-sel2]');
      $elems.each(function (i, el) {
        var $el = $(el); // select

        var select2Defaults = {
          dropdownParent: $el.parent(),
          dropdownAutoWidth: false,
          // minimumResultsForSearch	: Infinity,
          width: '100%'
        };
        // check for settings by attributes
        // select size
        if (el.hasAttribute('data-sel2-size') && $el.data('sel2-size') == 'sm' || $el.hasClass('form-control-sm') || $el.hasClass('custom-select-sm')) {
          select2Defaults.selectionCssClass = 'select2-selection--sm';
          select2Defaults.dropdownCssClass = 'select2-dropdown--sm';
        }
        // check allow clear attr
        if (el.hasAttribute('data-allow-clear') && $el.data('allow-clear') == true) {
          select2Defaults.selectionCssClass += ' select2-selection--clear';
        }
        // check custom max height attr
        if (el.hasAttribute('data-sel2-max-height')) {
          select2Defaults.selectionCssClass += ' select2-selection--max-height';
        }
        // check custom choice single row
        if (el.hasAttribute('data-sel2-choice-single-row')) {
          select2Defaults.selectionCssClass += ' select2-selection--choice-single-row';
        }
        // check max selection length attr
        if (el.hasAttribute('data-maximum-selection-length') && $el.data('maximum-selection-length') == '1') {
          select2Defaults.selectionCssClass += ' select2-selection--max-sel-1';
        }
        // create select2

        window[$($el).attr('id')] = $el.select2(select2Defaults);

        // $( window ).on( 'resize', function() {
        // 	$el.select2( select2Defaults );
        // } );
      });
    }

    /**
     * INIT CLEAR
     * initialize clear function
     * data-clear attribute should contain targets for clear as jquery selector
     * @param {string/jquery selector} container: dom-element that contains the elements to init
     */
  }, {
    key: "_initClear",
    value: function _initClear(container) {
      var O = this;
      _log('UI / _initClear');
      var $elems = $(container).length > 0 ? $(container).find('[data-clear]') : $('[data-clear]');
      $elems.each(function (i, el) {
        var $clear = $(el); // button or a
        // set clear targets
        $clear.targets = $clear.data('clear');
        if ($($clear.targets)) {
          $clear.state = false;
          $($clear.targets).on('change keyup', function (event) {
            $clear.state = false;
            // check all target's state
            $.each($($clear.targets), function (j, target) {
              if ($(target).val().length > 0) {
                $clear.addClass('visible');
                $clear.state = true;
              }
            });
            if ($clear.state) {
              $clear.addClass('visible');
            } else {
              $clear.removeClass('visible');
            }
          });
          // add event to clear
          $clear.on('click', function (event) {
            // iterate all targets and reset
            $.each($($clear.targets), function (j, target) {
              var $target = $(target);
              if ($target.is('select')) {
                $target.val('').trigger('change');
              } else if ($target.is('input')) {
                $target.val('').trigger('change');
              }
            });
            // hide clear
            $clear.state = false;
            $clear.removeClass('visible');
          });
        } else {
          $clear.remove();
        }
      });
    }

    /**
     * INIT TOUCHSSPIN
     * initialize touchspin lib on element <input type="text" data-touchspin >
     * @param {string/jquery selector} container: dom-element that contains the elements to init
     */
  }, {
    key: "_initTouchspin",
    value: function _initTouchspin(container) {
      var O = this;
      _log('UI / _initTouchspin');
      var $elems = $(container).length > 0 ? $(container).find('input[data-touchspin]') : $('input[data-touchspin]');
      $elems.each(function (i, el) {
        var $el = $(el); // input

        var touchspinDefaults = {
          buttondown_class: "btn btn-outline-secondary",
          buttonup_class: "btn btn-outline-secondary",
          decimals: 0,
          initval: 0,
          mousewheel: true,
          min: null,
          forcestepdivisibility: 'none',
          step: 1
        };

        // check for settings by attributes
        // min & max
        if (el.hasAttribute('data-touchspin-min')) {
          touchspinDefaults.min = $el.data('touchspin-min');
        }
        if (el.hasAttribute('data-touchspin-max')) {
          touchspinDefaults.max = $el.data('touchspin-max');
        }
        // step
        if (el.hasAttribute('data-touchspin-step')) {
          touchspinDefaults.step = $el.data('touchspin-step');
        }
        // decimals
        if (el.hasAttribute('data-touchspin-decimals')) {
          touchspinDefaults.decimals = $el.data('touchspin-decimals');
        }
        // initial value
        if (el.hasAttribute('data-touchspin-initval')) {
          touchspinDefaults.initval = $el.data('touchspin-initval');
        }
        // prefix & postfix
        if (el.hasAttribute('data-touchspin-prefix')) {
          touchspinDefaults.prefix = $el.data('touchspin-prefix');
        }
        if (el.hasAttribute('data-touchspin-postfix')) {
          touchspinDefaults.postfix = $el.data('touchspin-postfix');
        }
        _log(touchspinDefaults);
        // create touchspin
        $el.TouchSpin(touchspinDefaults);
        $el.on('change', function (event) {
          if (isNaN(event.currentTarget.value)) {
            $el.trigger('touchspin.destroy');
          } else {
            $el.TouchSpin(touchspinDefaults);
          }
        });
      });
    }

    /**
     * INIT DATEPICKER
     * initialize jquery.datepicker lib on element <input type="text" data-datepicker >
     * @param {array} settings: setting for datepicker
     * @param {string/jquery selector} container: dom-element that contains the elements to init
     */
  }, {
    key: "_initDatepicker",
    value: function _initDatepicker(container) {
      var O = this;
      _log('UI / _initDatepicker');
      var $elems = $(container).length > 0 ? $(container).find('[data-datepicker]') : $('[data-datepicker]');
      $elems.each(function (i, el) {
        var $el = $(el); // input or input group

        // create datepicker
        $el.datepicker({
          format: {
            toDisplay: function toDisplay(date, format, language) {
              var d = new Date(date);
              var day = d.getDate();
              var month = d.getMonth();
              var year = d.getFullYear();
              return year + '-' + month + '-' + day;
            },
            toValue: function toValue(date, format, language) {
              return date;
            }
          },
          todayHighlight: true
        });
      });
    }

    /**
     * INIT RANGESLIDER
     * initialize ion.rangeslider lib on element <input type="text" data-rangeslider >
     * @param {string/jquery selector} container: dom-element that contains the elements to init
     */
  }, {
    key: "_initRangeslider",
    value: function _initRangeslider(container) {
      var O = this;
      _log('UI / _initRangeslider');
      var $elems = $(container).length > 0 ? $(container).find('[data-rangeslider]') : $('[data-rangeslider]');
      $elems.each(function (i, el) {
        var $el = $(el); // input

        var rangesliderDefaults = {
          drag_interval: true
        };

        // check if inputs for rangeslider are set and exist as el
        // for double slider
        if (el.hasAttribute('data-type') && $el.data('type') == 'double') {
          // from input
          if (el.hasAttribute('data-control-double-from') && $($el.data('control-double-from')).length > 0) {
            $el.$inputDoubleFrom = $($el.data('control-double-from'));
            $el.$inputDoubleFrom.on('change', function (event) {
              var min = $el.data('rangeslider').result.min;
              var to = $el.data('rangeslider').result.to;
              var val = $el.$inputDoubleFrom.prop('value');
              // validate
              if (val < min) {
                val = min;
              } else if (val > to) {
                val = to;
              }
              $el.data('ionRangeSlider').update({
                from: val
              });
              $el.$inputDoubleFrom.val(val);
            });
          }
          // to input
          if (el.hasAttribute('data-control-double-to') && $($el.data('control-double-to')).length > 0) {
            $el.$inputDoubleTo = $($el.data('control-double-to'));
            $el.$inputDoubleTo.on('change', function (event) {
              var max = $el.data('rangeslider').result.max;
              var from = $el.data('rangeslider').result.from;
              var val = $el.$inputDoubleTo.prop('value');
              // validate
              if (val < from) {
                val = from;
              } else if (val > max) {
                val = max;
              }
              $el.data('rangeslider').update({
                to: val
              });
              $el.$inputDoubleTo.val(val);
            });
          }
          // if inputs for from/to, ad update routines
          if ($el.$inputDoubleFrom || $el.$inputDoubleTo) {
            rangesliderDefaults = $.merge({
              drag_interval: false,
              onStart: function onStart(data) {
                $el.updateInputs(data);
              },
              onChange: function onChange(data) {
                $el.updateInputs(data);
              },
              onFinish: function onFinish(data) {
                $el.updateInputs(data);
              }
            }, rangesliderDefaults);
            $el.updateInputs = function (data) {
              from = data.from;
              to = data.to;
              $el.$inputDoubleFrom.prop('value', from);
              $el.$inputDoubleTo.prop('value', to);
            };
          }
        }
        // for single slider
        else {
          // to do
          // from input
          if (el.hasAttribute('data-control-single') && $($el.data('control-single')).length > 0) {
            $el.$inputSingle = $($el.data('control-single'));
            $el.$inputSingle.on('change', function (event) {
              var min = $el.data('rangeslider').result.min;
              var max = $el.data('rangeslider').result.max;
              var val = $el.$inputSingle.prop('value');
              // validate
              if (val < min) {
                val = min;
              } else if (val > max) {
                val = max;
              }
              $el.data('rangeslider').update({
                from: val,
                step: O._precision(val)
              });
              $el.$inputSingle.val(val);
            });
          }
          // if inputs for from/to, ad update routines
          if ($el.$inputSingle) {
            rangesliderDefaults = $.merge({
              drag_interval: false,
              onStart: function onStart(data) {
                $el.updateInputs(data);
              },
              onChange: function onChange(data) {
                $el.updateInputs(data);
              },
              onFinish: function onFinish(data) {
                $el.updateInputs(data);
              }
            }, rangesliderDefaults);
            $el.updateInputs = function (data) {
              from = data.from;
              $el.$inputSingle.prop('value', from);
            };
          }
        }

        // create datepicker
        $el.ionRangeSlider(rangesliderDefaults);
        $el.data('rangeslider', $el.data('ionRangeSlider'));
      });
    }

    /**
     * INIT FORM VALIDATION
     * initialize validation on forms with data-atribute [data-validate]
     * @param {string/jquery selector} container: dom-element that contains the elements to init
     */
  }, {
    key: "_initFormValidation",
    value: function _initFormValidation(container) {
      var O = this;
      _log('UI / _initFormValidation');
      var $elems = $(container).length > 0 ? $(container).find('[data-validate]') : $('[data-validate]');
      $elems.each(function (i, el) {
        var $el = $(el); // form
        var $validations = $el.find('.validate-me');
        var validation = Array.prototype.filter.call($elems, function (form) {
          form.addEventListener('submit', function (event) {
            if (form.checkValidity() === false) {
              e.preventDefault();
              e.stopPropagation();
            }
            // added validation class to all form-groups in need of validation
            $validations.each(function (j, val) {
              $(val).addClass('was-validated');
            });
          }, false);
        });
      });
    }

    /**
     * INIT FORMS
     * combined initialization external lib items 
     * - touchspin
     * - select2
     * - datepicker
     * - ion rangeslider
     */
  }, {
    key: "_initFormItems",
    value: function _initFormItems(container) {
      var O = this;
      _log('UI / _initFormItems');
      O._initClear(container);
      O._initTouchspin(container);
      O._initSelect2(container);
      O._initDatepicker(container);
      O._initRangeslider(container);
    }
  }, {
    key: "_initAll",
    value:
    /**
     * INIT All
     * combined initialization of all external lib items 
     * - touchspin
     * - select2
     * - datepicker
     * - ion rangeslider
     */

    function _initAll() {
      var O = this;
      _log('UI / _initAll');
      O._initClear();
      O._initTouchspin();
      O._initSelect2();
      O._initDatepicker();
      O._initRangeslider();
      O._initFormValidation();
    }
  }]);
}();

},{}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrayForm = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Create a div to edit string arrays.
 * 
 * ```
 * <div class="panel panel-default">
 *   <div class="panel-heading clearfix">
 *     <h4 class="panel-title pull-left" style="padding-top:7.5px;">Title</h4>
 *     <div class="input-group">
 *       <p class="pull-right" /> <!-- gutter -->
 *       <div class="input-group-btn">
 *         <button type="button" class="btn btn-default" data-toggle="modal" data-target="#">
 *           <i class="glyphicon glyphicon-plus"></i>
 *         </button>
 *         <button class="btn btn-default"><i class="glyphicon glyphicon-remove"></i></button>
 *         <button class="btn btn-default"><i class="glyphicon glyphicon-trash"></i></button>
 *       </div>
 *      </div>
 *    </div>
 *   <table id="${table}" class="table"></table>
 * </div>
 * ```
 */
var ArrayForm = exports.ArrayForm = /*#__PURE__*/function () {
  function ArrayForm(name, mandatory, type, value, helperText, vocabulary, port) {
    _classCallCheck(this, ArrayForm);
    var O = this;
    O.group = document.createElement("div");
    O.mandatory = mandatory;
    O.simpleTable = new SimpleTable(type, value, vocabulary, port);
    O._create(name, mandatory, helperText);
  }
  return _createClass(ArrayForm, [{
    key: "_create",
    value: function _create(name, mandatory, helperText) {
      var O = this;
      if (name) {
        // formgroup
        $formGroup = $('<div class="form-group row"></div>');

        // label
        var $label = $('<label class="col-form-label col-form-label-sm col-9 col-xs-3 order-1 sim-param-label"></label>').attr('for', 'input_' + name.replace(/[\W_]+/g, "_")).appendTo($formGroup);
        $label.text(name + (mandatory ? "*" : ""));

        // field
        var $field = $('<div class="col-12 col-xs-7 col-md-6 order-3 order-xs-2 sim-param-field"></div>').appendTo($formGroup);

        // actions
        var $actions = $('<div class="col-3 col-xs-auto order-2 order-xs-3 sim-param-actions"></div>').appendTo($formGroup);

        // create param metadata action
        if (helperText) {
          // action metadata list
          var $actionMetadata = $('<button class="action action-pure float-right" type="button"><i class="feather icon-info"></i></button>').attr('data-toggle', 'collapse').attr('data-target', '#paramMetadata_' + name.replace(/[\W_]+/g, "_")).attr('aria-expanded', false).attr('aria-controls', 'paramMetadata_' + name.replace(/[\W_]+/g, "_")).attr('title', 'Show Metadata').appendTo($actions);
        }

        // create actions            
        var header = $('<div class="card-header"></div>');

        // Create card in group
        var panelDiv = document.createElement("div");
        panelDiv.classList.add("card");
        header.appendTo($(panelDiv));
        panelDiv.appendChild(O.simpleTable.table);
        _$actionTrash = $('<button type="button" class="action action-pure float-right"><i class="feather icon-trash-2"></i></button>').attr('id', 'simActionRemove').attr('data-tooltip', '').attr('title', 'Trash').appendTo(header).on('click', function (event) {
          O.simpleTable.trash();
        });

        // remove
        _$actionRemove = $('<button type="button" class="action action-pure float-right"><i class="feather icon-delete"></i></button>').attr('id', 'simActionRemove').attr('data-tooltip', '').attr('title', 'Remove').appendTo(header).on('click', function (event) {
          O.simpleTable.remove();
        });

        // add
        _$actionAdd = $('<button type="button" class="action action-pure float-right"><i class="feather icon-plus"></i></button>').attr('id', 'actionAdd').attr('data-tooltip', '').attr('title', 'Add').appendTo(header).on('click', function (event) {
          O.simpleTable.add();
        });
        $(panelDiv).appendTo($field);

        // create validation container
        O.$validationContainer = $('<div class="validation-message mt-1"></div>').appendTo($field);

        // create param metadata list
        if (helperText) {
          // metadata table
          var $metadataContainer = $('<div class="collapse param-metadata"></div>').attr('id', 'paramMetadata_' + name.replace(/[\W_]+/g, "_")).attr('aria-expanded', false).appendTo($field);
          $metadataContainer.append(_createHelperMetadataText(helperText));
        }
        O.group = $formGroup;
      }
    }
  }, {
    key: "value",
    get: function get() {
      var O = this;
      return O.simpleTable.value;
    },
    set: function set(newValue) {
      var O = this;
      O.simpleTable.trash();
      newValue.forEach(function (item) {
        return O.simpleTable._createRow(item);
      });
    }
  }, {
    key: "onblurHandler",
    value: function onblurHandler() {
      var O = this;
      var can_emit_Event = (typeof attr === "undefined" ? "undefined" : _typeof(attr)) === (typeof undefined === "undefined" ? "undefined" : _typeof(undefined)) || attr === false;
      _log(' onblurHandler' + can_emit_Event);
      if (can_emit_Event) {
        window.editEventBus.broadcast('MetadataChanged');
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      var O = this;
      O.simpleTable.trash();
    }

    /**
     * @return {boolean} If the textarea is valid.
     */
  }, {
    key: "validate",
    value: function validate() {
      var O = this;
      var isValid = true;
      if (O.mandatory) {
        isValid = O.simpleTable.value.length > 0 ? true : false;
      }
      if (!isValid) {
        O.$validationContainer.text("At least one row is required");
        O.group.addClass('has-error');
        O.group.addClass('is-invalid');
        O.$validationContainer.css("display", "block");
      } else {
        O.onblurHandler();
      }
      return isValid;
    }
  }]);
}();

},{}],56:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Dialog = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Create a Bootstrap 3 modal dialog.
 */
var Dialog = exports.Dialog = /*#__PURE__*/function () {
  /**
   * Create a Bootstrap 3 modal dialog.
   * 
   * ```
   * <div class="modal-fade">
   *   <div class="modal-dialog" role="document">
   *     <div class="modal-content">
   *       <div class="modal-header">
   *         <button>
   *           <span>
   *         </button>
   *         <h4 class="modal-title">title</h4>
   *       </div>
   *       <div class="modal-body">
   *         <form>...</form>
   *       </div>
   *       <div class="modal-footer">
   *         <button type="button">Close</button>
   *         <button type="button">Save changes</button>
   *       </div>
   *     </div>
   *   </div>
   * </div>
   * ```
   * 
   * @param {id} id Dialog id
   * @param {title} title Dialog title
   * @param {formData} formData Object with form data
   */
  function Dialog(id, title, formData, port) {
    _classCallCheck(this, Dialog);
    var O = this;
    O.inputs = {}; // Hash of inputs by id

    // Index of the row currently edited. It is -1 if no row is being edited.
    // This is the case of when a new row is added.
    O.editedRow = -1;
    O.modal = document.createElement("div");
    O.create(id, title, formData, port);
  }
  return _createClass(Dialog, [{
    key: "create",
    value: function create(id, title, formData, port) {
      var O = this;
      // modal body
      var form = $('<form class="form-striped" no-immidiate-submit></form>');
      formData.forEach(function (prop) {
        var inputForm = createForm(prop, null, port);
        if (inputForm) {
          $(inputForm.group).appendTo(form);
          O.inputs[prop.id] = inputForm;
        }
      });
      var modalBody = $('<div class="modal-body p-0 sim-params"></div>');
      var modalinnerBody = $('<div class="tab-content h-100"></div>');
      form.appendTo(modalinnerBody);
      modalinnerBody.appendTo(modalBody);

      // modal action
      // nav
      var _$modalNav = $('<div class="modal-body sim-select"></div>');

      // navbar
      var _$navBar = $('<nav class="navbar sim-select">');
      _$navBar.appendTo(_$modalNav);
      _$navBar.wrap('<form></form>');

      //  select label
      $('<label class="col-4 col-md-3 sim-select-label" >' + title.replace("Add", "") + '</label>').appendTo(_$navBar);

      //  select actions
      var _$dialogActions = $('<div class="col-8"></div>');
      _$dialogActions.appendTo(_$navBar);
      var $actionGroup1 = $('<div class="col-12"></div>').appendTo(_$dialogActions);
      var closeButton = $('<button type="button" class="btn btn-icon btn-outline-light"><i class="feather icon-x"></i></button>');
      closeButton.attr('id', 'simActionclose');
      closeButton.attr('data-tooltip', '');
      closeButton.attr('title', 'close');
      closeButton.attr('data-dismiss', 'modal');
      closeButton.appendTo($actionGroup1);
      // col divider
      $('<div class="col-divider ml-auto ml-xs-0"></div>').appendTo($actionGroup1);
      var saveButton = $('<button type="button" class="btn btn-icon btn-outline-light"><i class="feather icon-save"></i></button>');
      saveButton.attr('id', 'save');
      saveButton.attr('data-tooltip', '');
      saveButton.attr('title', 'Save changes');
      saveButton.appendTo($actionGroup1);
      saveButton.on('click', function (event) {
        // Validate inputs and stop saving if errors are found.
        var hasError = false;
        Object.values(O.inputs).forEach(function (input) {
          if (!input.validate()) hasError = true;
        });
        if (hasError) return;
        $(O.modal).modal('hide');

        // Retrieve data and clear inputs
        var data = {};
        for (var inputId in O.inputs) {
          var currentInput = O.inputs[inputId];
          if (currentInput.type && currentInput.type == "checkbox") {
            data[inputId] = $(currentInput.input[0]).is(":checked");
          } else {
            data[inputId] = currentInput.value; // Save input value
          }
          currentInput.clear(); // Clear input
        }
        if (O.editedRow != -1) {
          O.panel.save(O.editedRow, data);
          O.editedRow = -1;
          Object.values(O.inputs).forEach(function (input) {
            return input.clear();
          }); // Clear inputs
        } else {
          O.panel.add(data);
        }
      });
      $actionGroup1.wrapInner('<div class="row justify-content-end align-items-center"></div>');
      var content = document.createElement("div");
      content.classList.add("modal-content");
      content.innerHTML = "<div class=\"modal-header\">\n                                <h1 class=\"modal-title\">".concat(title, "</h1>\n                                <button type=\"button\" class=\"action action-pure action-lg ml-2\" data-dismiss=\"modal\" aria-label=\"Close\"><i class=\"feather icon-x\"></i></button>\n                                </div>");
      _$navBar.appendTo($(content));
      modalBody.appendTo($(content));
      var modalDialog = document.createElement("div");
      modalDialog.classList.add("modal-dialog", "modal-xl");
      modalDialog.setAttribute("role", "document");
      modalDialog.appendChild(content);
      O.modal.classList.add("modal", "fade", "modal-sim");
      O.modal.id = id;
      O.modal.tabIndex = -1;
      O.modal.setAttribute("role", "dialog");
      O.modal.appendChild(modalDialog);
      _appUI._initFormItems(form);
    }
  }]);
}();

},{}],57:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventObserver = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * The observer class maintains a list of its observers and notifies them automatically of any state changes,
 * by calling one of their methods.
 * version: 1.0.0
 * author: Ahmad Swaid 
 * date: 07.12.2020 
 */
var EventObserver = exports.EventObserver = /*#__PURE__*/function () {
  function EventObserver() {
    _classCallCheck(this, EventObserver);
    var O = this;
    O.observers = []; //list of observed events (callback functions)
    O.registeredID = [];
  }
  return _createClass(EventObserver, [{
    key: "subscribe",
    value: function subscribe(id, observer) {
      var O = this;
      //add new events
      if (!O.registeredID.includes(id)) {
        O.observers.push({
          id: id,
          callback: observer
        }); //get list of observed events and push new item to array
        O.registeredID.push(id);
      }
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(observer) {
      var O = this;
      O.observers = O.observers.filter(function (subscriber) {
        return subscriber !== observer;
      }); //returns a new list with filtered entries
    }
  }, {
    key: "broadcast",
    value: function broadcast(event) {
      var O = this;
      _log("Sending event ", event);
      O.observers.forEach(function (subscriber) {
        subscriber.callback(event);
      });
    }
  }]);
}();

},{}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FormPanel = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Simple panel for non nested data like General information, study, etc.
 */
var FormPanel = exports.FormPanel = /*#__PURE__*/function () {
  function FormPanel(title, formData, data, port) {
    _classCallCheck(this, FormPanel);
    _log('FormPanel /' + title, 'primary');
    var O = this;
    O.panel = $('<div class="panel-body"></div>');
    O.inputs = {};
    O._create(title, formData, data, port);
  }

  /**
   * ```
   * <div class="panel panel-default">
   *   <div class="panel-heading">
   *     <h3 class="panel-title">Some title</h3>
   *   </div>
   *   <div class="panel-body">
   *     <form></form>
   *   </div>
   * </div>
   * ```
   * @param {*} title 
   * @param {*} formData 
   */
  return _createClass(FormPanel, [{
    key: "_create",
    value: function _create(title, formData, data, port) {
      var O = this;
      var form = $('<form class="form-striped"></form>');
      formData.forEach(function (prop) {
        var inputForm = createForm(prop, data ? data[prop.id] : null, port, title === "Parameter" ? true : false);
        if (inputForm) {
          $(inputForm.group).appendTo(form);
          O.inputs[prop.id] = inputForm;
        }
      });
      form.appendTo(O.panel);
      // init form items' functions: touchspin, range, select2 ...
      _appUI._initFormItems(form);
    }
  }, {
    key: "validate",
    value: function validate() {
      var O = this;
      var isValid = true;
      Object.values(O.inputs).forEach(function (input) {
        if (!input.validate()) isValid = false;
      });
      return isValid;
    }
  }, {
    key: "data",
    get: function get() {
      var O = this;
      var data = {};
      Object.entries(O.inputs).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          id = _ref2[0],
          input = _ref2[1];
        return data[id] = input.value;
      });
      return data;
    }
  }]);
}();

},{}],59:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InputForm = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Bootstrap 3 form-group for an input.
 */
var InputForm = exports.InputForm = /*#__PURE__*/function () {
  /**
   * Create a Bootstrap 3 form-group.
   * 
   * ```
   * <div class="form-group row">
   *   <label>name</label>
   *   <div class="col-sm-10">
   *     <input type="text">
   *   </div>
   * </div>`;
   * ```
   * 
   * If type === checkbox
   * ```
   * <div class="form-group row">
   *   <label >name</label>
   *   <div class="col-sm-10">
   *     <input class="form-check-input" type="checkbox" checked="">
         *	 </div>
     * </div>
   * ```
   * 
   * @param {string} name Property name
   * @param {boolean} mandatory `true` if mandatory, `false` if optional.
   * @param {string} type Property type: text, url, checkbox, etc.
   * @param {string} helperText Tooltip
   * @param {string} value Initial value of the property.
   * @param {Array} vocabulary Vocabulary name.
   */
  function InputForm(name, mandatory, type, helperText, value, port) {
    var vocabulary = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
    var sid = arguments.length > 7 ? arguments[7] : undefined;
    _classCallCheck(this, InputForm);
    var O = this;
    O.name = name;
    O.mandatory = mandatory;
    O.type = type;
    O.helperText = helperText;
    O.isSID = !_isNull(sid) && !_isUndefined(sid);
    O.group = null;
    O._create(name, mandatory, type, helperText, value, vocabulary, port);
  }

  /**
   * @param {string} name Property name
   * @param {boolean} mandatory `true` if mandatory, `false` if optional.
   * @param {string} type Property type: text, url, checkbox, etc.
   * @param {string} helperText Tooltip
   * @param {string} value Initial value of the property.
   * @param {Array} vocabulary Vocabulary name.
   */
  return _createClass(InputForm, [{
    key: "_create",
    value: function _create(name, mandatory, type, helperText, value, vocabulary, port) {
      var O = this;
      O._createFormField(name, mandatory, type, helperText, value, vocabulary, port);
    }
    /**
     * CREATE FORM FIELD
     * create field as form group
     * @param {array} param
     */
  }, {
    key: "_createFormField",
    value: function _createFormField(name, mandatory, type, helperText, value, vocabulary, port) {
      var O = this;
      _log('PANEL SIM / _createFormField');
      _log(name);
      if (name) {
        // formgroup
        var $formGroup = $('<div class="form-group row"></div>');

        // label
        var $label = $('<label class="col-form-label col-form-label-sm col-9 col-xs-3 order-1 sim-param-label"></label>');
        $label.attr('for', 'input_' + name.replace(/[\W_]+/g, "_"));
        $label.appendTo($formGroup);
        $label.text(name + (mandatory ? "*" : ""));

        // field
        var $field = $('<div class="col-12 col-xs-7 col-md-6 order-3 order-xs-2 sim-param-field"></div>').appendTo($formGroup);

        // actions
        var $actions = $('<div class="col-3 col-xs-auto order-2 order-xs-3 sim-param-actions"></div>').appendTo($formGroup);

        // input item
        O.input = null;

        // create param metadata action
        if (helperText) {
          // action metadata list
          var $actionMetadata = $('<button class="action action-pure float-right" type="button"><i class="feather icon-info"></i></button>');
          $actionMetadata.attr('data-toggle', 'collapse');
          $actionMetadata.attr('data-target', '#metadata_' + name.replace(/[\W_]+/g, "_"));
          $actionMetadata.attr('aria-expanded', false);
          $actionMetadata.attr('aria-controls', 'metadata_' + name.replace(/[\W_]+/g, "_"));
          $actionMetadata.attr('title', 'Show Metadata');
          $actionMetadata.appendTo($actions);
        }
        if (type) {
          // numeric
          if (type == 'number') {
            var $inputGroup = $('<div class="input-group input-group-sm"></div>').appendTo($field);
            O.input = $('<input type="text" />').attr('id', 'input_' + name.replace(/[\W_]+/g, "_")).attr('aria-invalid', false).attr('data-min', parseFloat(Number.MIN_SAFE_INTEGER)) // min value
            .attr('data-max', parseFloat(Number.MAX_SAFE_INTEGER)) // max value
            .appendTo($inputGroup);

            // touchspin
            O.input.addClass('form-control form-control-sm').attr('data-touchspin', '');
            // add postfix to touchspin

            //O.input.attr( 'data-touchspin-postfix', type );
          }
          // string or others
          //<input class="custom-control-input" type="checkbox" id="switchExample1" name="switchExample1" checked />
          else if (type == 'checkbox') {
            O.input = $('<input type="checkbox" class="form-check-input" style="width: auto;" />').attr('id', 'input_' + name.replace(/[\W_]+/g, "_")).appendTo($field);
          }
          // string or others
          else {
            O.input = $('<input type="text" class="form-control form-control-sm" />').attr('id', 'input_' + name.replace(/[\W_]+/g, "_")).appendTo($field);
          }
        }
        if (type === "date") {
          O.input.attr('type', 'date');
          //O.input.attr('data-datepicker','');
        }
        if (type === "year_date") {
          O.input.datepicker({
            format: " yyyy",
            // Notice the Extra space at the beginning
            viewMode: "years",
            minViewMode: "years"
          });
        }
        if (type === "date" && typeof value != "string") {
          var day = ("" + value[2]).length > 1 ? "" + value[2] : "0" + value[2];
          var month = ("" + value[1]).length > 1 ? "" + value[1] : "0" + value[1];
          O.input.val(value[0] + "-" + month + "-" + day);
        } else if (type === "checkbox") {
          O.input.checked = value;
        } else {
          O.input.val(value);
        }

        // Add autocomplete to input with vocabulary
        if (vocabulary) {
          // addControlledVocabulary(O.input, vocabulary, port);
          addControlledVocabulary(O.input, vocabulary);
        }
        O.input.on("blur", function () {
          O.validate(O.value);
        });
        // create validation container
        O.input.$validationContainer = $('<div class="validation-message mt-1"></div>').appendTo($field);

        // create  metadata list
        if (helperText) {
          // metadata table
          var $metadataContainer = $('<div class="collapse param-metadata"></div>').attr('id', 'metadata_' + name.replace(/[\W_]+/g, "_")).attr('aria-expanded', false).appendTo($field);
          $metadataContainer.append(_createHelperMetadataText(helperText));
        }
        O.group = $formGroup;
      }
    }
  }, {
    key: "value",
    get: function get() {
      var O = this;
      if (O.type === "date") {
        if (O.input.val()) {
          var value = "";
          if (O.input.val().includes("-")) value = O.input.val().split("-");else value = O.input.val().split(".");
          var day = ("" + value[2]).length > 1 ? "" + value[2] : "0" + value[2];
          var month = ("" + value[1]).length > 1 ? "" + value[1] : "0" + value[1];
          return value[0] + "-" + month + "-" + day;
        }
      } else if (O.type === "checkbox") {
        return O.input.is(":checked") ? "true" : "false";
      } else if (O.type === "year_date") {
        return O.input.val().trim();
      } else {
        return O.input.val();
      }
    },
    set: function set(newValue) {
      var O = this;
      if (O.type === "checkbox") {
        console.log(newValue);
        O.input.selected(newValue == 'true' ? true : false);
      } else {
        O.val(newValue);
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      var O = this;
      if (O.type !== "checkbox") O.input.val("");else O.input.checked = false;
      if (O.input.$validationContainer) {
        O.input.$validationContainer.css("display", "none");
      }

      // Remove validation classes
      O.group.removeClass("has-success has-error");
    }
  }, {
    key: "onblurHandler",
    value: function onblurHandler() {
      var O = this;
      var closestForm = O.input.closest("form");
      var attr = closestForm.attr('no-immidiate-submit');
      var can_emit_Event = _typeof(attr) === (typeof undefined === "undefined" ? "undefined" : _typeof(undefined)) || attr === false;
      _log(' onblurHandler' + can_emit_Event);
      if (can_emit_Event) {
        window.editEventBus.broadcast('MetadataChanged');
      }
    }
    /**
     * @returns {boolean} If the input is valid.
     */
  }, {
    key: "validate",
    value: function validate() {
      var O = this;
      _log('PANEL  / _validateForm');
      var validationErrors = [];
      // remove error classes
      O.input.find('.has-error').removeClass('has-error');
      O.input.find('.is-invalid').removeClass('is-invalid');
      O.input.find('.validation-message').empty();
      O.input.$validationContainer.text('');
      var isValid = true;
      if (!O.mandatory) {
        isValid = true;
      } else if (O.isSID) {
        var fieldValue = O.input.val();
        var idRegexp = /^[A-Za-z_^s]\w*$/;
        // name fits regexp
        if (!idRegexp.test(fieldValue)) {
          O.input.$validationContainer.text('Parameter ID is not a valid (SId)');
          isValid = false;
        }
      } else {
        isValid = O.input.val() ? true : false;
        if (!isValid) {
          //remove "required" message
          //O.input.$validationContainer.text("required");
          isValid = true;
        }
      }
      // check if mail has correct structure, provided there is a value
      if (O.input.val() && O.type === "email") {
        if (O.input.val().trim()) {
          isValid = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/.test(O.input.val());
          O.input.$validationContainer.text("Not a valid email value");
        }
      }
      if (!isValid) {
        O.input.parents('.form-group').addClass('has-error');
        O.input.$validationContainer.addClass('is-invalid');
        O.input.$validationContainer.css("display", "block");
      } else {
        O.onblurHandler();
      }
      return isValid;
    }
  }]);
}();

},{}],60:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SelectForm = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Bootstrap 3 form with a select.
 */
var SelectForm = exports.SelectForm = /*#__PURE__*/function () {
  /**
   * Create a Bootstrap 3 form-group with a select.
   * 
   * ```
   * <div class="form-group row">
   *   <label>name</label>
   *   <select class="form-control">
   *     <option>1</option>
   *     <option>2</option>
   *   </select>
   * </div>```
   * <select id="select2ExampleS2" class="form-control form-control-sm" style="width: 100%;" data-sel2 data-placeholder="Select">
  *									<option value="1">Option 1</option>
  *									<option value="2">Option 2</option>
  *									<option value="3">Option 3 with very long title lorem ipsum dolor sit amet</option>
  *								</select>
   */
  function SelectForm(name, mandatory, helperText, value, port) {
    var vocabulary = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    _classCallCheck(this, SelectForm);
    var O = this;
    O.group = document.createElement("div");
    O._create(name, mandatory, helperText, value, port, vocabulary);
  }
  return _createClass(SelectForm, [{
    key: "_create",
    value: function _create(name, mandatory, helperText, value, port, vocabulary) {
      var O = this;
      // formgroup
      var $formGroup = $('<div class="form-group row"></div>');

      // label
      var $label = $('<label class="col-form-label col-form-label-sm col-9 col-xs-3 order-1 sim-param-label"></label>').attr('for', 'selectInput_' + name.replace(/[\W_]+/g, "_")).appendTo($formGroup);
      $label.text(name + (mandatory ? "*" : ""));

      // field
      var $field = $('<div class="col-12 col-xs-7 col-md-6 order-3 order-xs-2 "></div>').appendTo($formGroup);

      // actions
      var $actions = $('<div class="col-3 col-xs-auto order-2 order-xs-3 sim-param-actions"></div>').appendTo($formGroup);

      // input item
      O.input = null;

      // create param metadata action
      if (helperText) {
        // action metadata list
        var $actionMetadata = $('<button class="action action-pure float-right" type="button"><i class="feather icon-info"></i></button>').attr('data-toggle', 'collapse').attr('data-target', '#paramMetadata_' + name.replace(/[\W_]+/g, "_")).attr('aria-expanded', false).attr('aria-controls', 'paramMetadata_' + name.replace(/[\W_]+/g, "_")).attr('title', 'Show Metadata').appendTo($actions);
      }
      O.input = $('<select class="form-control form-control-sm" style="width: 100%;" data-sel2 data-placeholder="Select"/>').attr('id', 'selectInput_' + name.replace(/[\W_]+/g, "_")).appendTo($field);
      // Add options from vocabulary. The option matching value is selected.
      // if(window._endpoints.controlledVocabularyEndpoint){

      //     fetch(window._endpoints.controlledVocabularyEndpoint+`${vocabulary}`)
      //         .then(response => response.json())
      //         .then(data => {
      //                 O.input.append(data.map(item => `<option>${item}</option>`).join(""));

      //     }).catch(error => {
      //         if(port >= 0){
      //             fetch(`http://localhost:${port}/getAllNames/${vocabulary}`)
      //                 .then(response => response.json())
      //                 .then(data => {
      //                         O.input.append(data.map(item => `<option>${item}</option>`).join(""));

      //             });
      //         }
      //     });

      // }
      // else if(port >= 0){
      //     fetch(`http://localhost:${port}/getAllNames/${vocabulary}`)
      //         .then(response => response.json())
      //         .then(data => {
      //                 O.input.append(data.map(item => `<option>${item}</option>`).join(""));

      //         });
      // }
      if (window.vocabularies[vocabulary]) {
        var html = window.vocabularies[vocabulary].map(function (item) {
          return "<option>".concat(item, "</option>");
        }).join("");
        O.input.append(html);
      }
      O.input.val(value);
      O.input.trigger('change');
      // create validation container
      O.input.$validationContainer = $('<div class="validation-message mt-1"></div>').appendTo($field);

      // create param metadata list
      if (helperText) {
        // metadata table
        var $metadataContainer = $('<div class="collapse param-metadata"></div>').attr('id', 'paramMetadata_' + name.replace(/[\W_]+/g, "_")).attr('aria-expanded', false).appendTo($field);
        $metadataContainer.append(_createHelperMetadataText(helperText));
      }
      O.group = $formGroup;
    }
  }, {
    key: "value",
    get: function get() {
      var O = this;
      if (O.input.val() && O.input.val() != '(Data)') return O.input.val();else return O.input.find("option[data-select2-id]").text();
    },
    set: function set(newValue) {
      var O = this;
      O.select.val(newValue);
    }
  }, {
    key: "onblurHandler",
    value: function onblurHandler() {
      var O = this;
      var closestForm = O.input.closest("form");
      var attr = closestForm.attr('no-immidiate-submit');
      var can_emit_Event = _typeof(attr) === (typeof undefined === "undefined" ? "undefined" : _typeof(undefined)) || attr === false;
      _log(' onblurHandler' + can_emit_Event);
      if (can_emit_Event) {
        window.editEventBus.broadcast('MetadataChanged');
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      var O = this;
    }

    /**
     * @returns {boolean} If the input is valid.
     */
  }, {
    key: "validate",
    value: function validate() {
      var O = this;
      var isValid;
      O.input.find('.has-error').removeClass('has-error');
      O.input.find('.is-invalid').removeClass('is-invalid');
      O.input.find('.validation-message').empty();
      if (!O.mandatory) {
        isValid = true;
      } else {
        isValid = O.input.value ? true : false;
      }
      if (!isValid) {
        O.input.$validationContainer.text("required");
        O.input.parents('.form-group').addClass('has-error');
        O.input.addClass('is-invalid');
        O.input.$validationContainer.css("display", "block");
      } else {
        O.onblurHandler();
      }
      return isValid;
    }
  }]);
}();

},{}],61:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SimpleTable = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var SimpleTable = exports.SimpleTable = /*#__PURE__*/function () {
  function SimpleTable(type, data, vocabulary, port) {
    _classCallCheck(this, SimpleTable);
    var O = this;
    O.type = type === "text-array" ? "text" : "date";
    O.vocabulary = vocabulary;
    O.port = port;
    O.table = document.createElement("table");
    O.table.className = "table";
    O.table.innerHTML = "<thead><thead>";
    O.body = document.createElement("tbody");
    O.table.appendChild(O.body);
    data.forEach(function (value) {
      return O._createRow(value);
    });
  }

  /**
   * Create new row to enter data if the last row value is not empty.
   */
  return _createClass(SimpleTable, [{
    key: "add",
    value: function add() {
      var O = this;
      // If it has no rows or the last row value is not empty
      if (!O.body.lastChild || O.body.lastChild.lastChild.firstChild.value) {
        O._createRow();
      }
    }
  }, {
    key: "remove",
    value: function remove() {
      var O = this;
      // Find checked rows and delete them
      Array.from(O.body.children).forEach(function (row) {
        // Get checkbox (tr > td > input)
        var checkbox = row.firstChild.firstChild;
        if (checkbox.checked) {
          O.body.removeChild(row);
        }
      });
    }

    /**
     * Remove every row in the table
     */
  }, {
    key: "trash",
    value: function trash() {
      var O = this;
      O.body.innerHTML = "";
    }
  }, {
    key: "_createRow",
    value: function _createRow() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      var O = this;
      var input = document.createElement("input");
      input.type = O.type;
      input.className = "form-control";
      if ($(input).attr('type') === "date" && typeof value != "string" && value !== null) {
        var day = ("" + value[2]).length > 1 ? "" + value[2] : "0" + value[2];
        var month = ("" + value[1]).length > 1 ? "" + value[1] : "0" + value[1];
        $(input).val(value[0] + "-" + month + "-" + day);
      } else if ($(input).is(':checkbox')) {
        $(input).checked = value;
      } else {
        $(input).val(value);
      }

      // Add autocomplete to input with vocabulary
      if (O.vocabulary) {
        addControlledVocabulary(input, O.vocabulary, O.port);
      }

      // If enter is pressed when the input if focused, lose focus and add a
      // new row (like clicking the add button). The new input from calling add
      // is focused.
      input.addEventListener("keyup", function (event) {
        if (event.key === "Enter") {
          input.blur();
          O.add();
        }
      });

      // Create cell with input
      var inputCell = document.createElement("td");
      inputCell.appendChild(input);

      // Create row with checkbox and input
      var newRow = document.createElement("tr");
      newRow.innerHTML = '<td><input type="checkbox"></td>';
      newRow.appendChild(inputCell);

      // Add row
      O.body.appendChild(newRow);
      input.focus(); // Focus the new input      
    }
  }, {
    key: "value",
    get: function get() {
      var O = this;
      var data = [];
      O.body.childNodes.forEach(function (tr) {
        var inputCell = tr.lastChild; // 2nd cell (with input)
        var input = inputCell.firstChild; // <input>
        data.push(input.value);
      });
      return data;
    }
  }]);
}();

},{}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TablePanel = void 0;
var _Dialog = require("./Dialog.js");
var _APPTable = require("./APPTable.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
 * Create a Bootstrap 3 panel with controls in the heading and a table as body.
 * 
 * ```
 * <div class="panel panel-default">
 *   <div class="panel-heading clearfix">
 *     <h4 class="panel-title pull-left" style="padding-top:7.5px;">${title}</h4>
 *     <div class="input-group">
 *       <p class="pull-right" /> <!-- gutter -->
 *       <div class="input-group-btn">
 *         <button type="button" class="btn btn-default" data-toggle="modal" data-target="#${dialog}">
 *           <i class="glyphicon glyphicon-plus"></i>
 *         </button>
 *         <button class="btn btn-default"><i class="glyphicon glyphicon-remove"></i></button>
 *         <button class="btn btn-default"><i class="glyphicon glyphicon-trash"></i></button>
 *       </div>
 *     </div>
 *   </div>
 *   <table class="table">
 *     <tr>
 *       <th><input type="checkbox"></th>
 *     </tr>
 *   </table>
 * </div>`
 * ```
 */
var TablePanel = exports.TablePanel = /*#__PURE__*/function () {
  /**
   * Create a TablePanel.
   * 
   * @param {string} title Panel title.
   * @param {object} formData Related data from the UI schema.
   * @param {object} data Initial data of the table.
   */
  function TablePanel(title, formData, data, port) {
    _classCallCheck(this, TablePanel);
    var O = this;
    O.panel = document.createElement("div");

    // Register this panel in dialog (TODO: this should be done in Dialog's constr)
    // O.dialog = dialog;
    O.dialog = new _Dialog.Dialog(title + "Dialog", "Add " + title, formData, port);
    O.dialog.panel = this;
    O.tablePanel = O._createComplexPanel(data, formData, title, O.dialog);
    O.table = O.tablePanel.find("table.table-striped");
    O.data = data ? data : []; // Initialize null or undefined data
    O._create(title, O.dialog, formData);
  }

  /**
   * Create UI of the TablePanel.
   * 
   * @param {string} title Panel title.  
   * @param {Dialog} dialog Reference to Dialog object. This Dialog is later
   *   used for adding new entries and editing existing ones. 
   * @param {object} formData Related data from the UI schema.
   */
  return _createClass(TablePanel, [{
    key: "_create",
    value: function _create(title, dialog, formData) {
      var O = this;
      // panel
      O.panel.classList.add("panel", "panel-default");
      O.tablePanel.appendTo($(O.panel));
    }
    /**
     * CREATE COMPLEX PANEL
     * create complex tab-pane for specific menu
     * table has in metadata and schema defined cols
     * @param {array} menu
     * @param {object} modelHandler: object of class Model
     */
  }, {
    key: "_createComplexPanel",
    value: function _createComplexPanel(data, formData, title, dialog) {
      var O = this;

      // tab-pane
      var $panel = $('<div class="tab-pane h-100" role="tabpanel"></div>').attr('id', 'table' + title);
      // Add button
      var addButton = $('<button class="btn btn-outline-secondary btn-sm btn-icon" type="button"><i class="feather icon-plus"></i></button>').attr('aria-label', "Add a " + title).attr('title', "Add a " + title);
      addButton.on('click', function (event) {
        Object.values(dialog.inputs).forEach(function (input) {
          return input.clear();
        });
        $(dialog.modal).modal('show');
      });
      var removeAllButton = $('<button class="btn btn-outline-secondary btn-sm btn-icon" type="button"><i class="feather icon-trash"></i></button>').attr('aria-label', "Remove all ".concat(title, "(s)")).attr('title', "Remove all ".concat(title, "(s)"));
      removeAllButton.on('click', function (event) {
        O.removeAll();
      });

      // table settings
      var tableSettings = {
        cols: [],
        tableData: [],
        responsive: true,
        showToggle: true,
        rowActions: [{
          type: 'link',
          idPrefix: 'mtActionMerge_',
          icon: 'icon-arrow-up',
          title: 'Move Up',
          on: {
            click: function click(o, $action, rowIndex, rowData) {
              _log('on > clicktrash', 'hook');
              _log(o);
              _log($action);
              _log(rowIndex);
              _log(rowData);
              O.moveTo(rowIndex, 'up');
            }
          }
        }, {
          type: 'link',
          idPrefix: 'mtActionMerge_',
          icon: 'icon-arrow-down',
          title: 'Move down',
          on: {
            click: function click(o, $action, rowIndex, rowData) {
              _log('on > clickMoveTO ', 'hook');
              _log(o);
              _log($action);
              _log(rowIndex);
              _log(rowData);
              O.moveTo(rowIndex, 'down');
            }
          }
        }, {
          type: 'link',
          idPrefix: 'mtActionMerge_',
          icon: 'icon-trash',
          title: 'Trash',
          on: {
            click: function click(o, $action, rowIndex, rowData) {
              _log('on > clicktrash', 'hook');
              _log(o);
              _log($action);
              _log(rowIndex);
              _log(rowData);
              O.remove(rowIndex);
            }
          }
        }, {
          type: 'link',
          idPrefix: 'mtActionEdit_',
          icon: 'icon-edit-2',
          title: 'Edit',
          on: {
            click: function click(o, $action, rowIndex, rowData) {
              _log('on > clickEdit', 'hook');
              _log(o);
              _log($action);
              _log(rowIndex);
              _log(rowData);
              O.edit(rowIndex, rowData, dialog);
            }
          }
        }],
        editableToolbarbuttons: [addButton, removeAllButton]
      };

      // set table cols
      $.each(formData, function (i, prop) {
        tableSettings.cols.push({
          label: prop.label,
          field: prop.id,
          sortable: true,
          switchable: true
        });
      });

      // set table row data
      $.each(data, function (i, item) {
        // row each item
        var rowData = {
          cells: []
        };
        // cells
        $.each(formData, function (j, prop) {
          var data = item[prop.id];
          data = _checkUndefinedContent(data);
          // cell each prop
          rowData.cells.push(data);
        });
        tableSettings.tableData.push(rowData);
      });
      // create table
      O.panelTable = new _APPTable.APPTable(tableSettings, $panel);
      $panel.data('table', O.panelTable);
      return $panel;
    }
  }, {
    key: "add",
    value: function add(data, index, isEdit) {
      var O = this;
      data.el ? delete data.el : null;
      var keys = [];
      $.each(O.panelTable.opts.cols, function (index, key) {
        keys.push(key.field);
      });
      // set table row data
      var rowData = {
        cells: []
      };
      // cells
      $.each(data, function (j, value) {
        // cell each prop
        rowData.cells.push(value);
      });
      if (isEdit) {
        O.panelTable._tableData.splice(index, 1, rowData);
        O.data.splice(index, 1, data); // add data
        O.panelTable.addRow(index, rowData, O.panelTable._tableData, 'true', isEdit);
      } else {
        O.panelTable._tableData.push(rowData);
        O.data.push(data); // add data
        O.panelTable.addRow(O.panelTable._tableData.length - 1, rowData, O.panelTable._tableData, 'true', false);
      }
      window.editEventBus.broadcast('MetadataChanged');
    }
  }, {
    key: "edit",
    value: function edit(index, originalData, dialog) {
      var O = this;
      var keys = [];
      $.each(O.panelTable.opts.cols, function (index, key) {
        keys.push(key.field);
      });
      var _loop = function _loop(indexx) {
        var input = dialog.inputs[keys[indexx]].input;
        if (input) {
          if (input.attr('type') === "date") {
            var value = originalData.cells[indexx];
            if (value) {
              var day = ("" + value[2]).length > 1 ? "" + value[2] : "0" + value[2];
              var month = ("" + value[1]).length > 1 ? "" + value[1] : "0" + value[1];
              dialog.inputs[keys[indexx]].input.val(value[0] + "-" + month + "-" + day);
            }
          } else if (input.attr('type') === "checkbox") {
            dialog.inputs[keys[indexx]].input.prop('checked', originalData.cells[indexx]);
          } else {
            dialog.inputs[keys[indexx]].input.val(originalData.cells[indexx]);
            if (dialog.inputs[keys[indexx]].input.trigger) {
              dialog.inputs[keys[indexx]].input.trigger('change');
            }
          }
        } else if (Array.isArray(originalData.cells[indexx]) && dialog.inputs[keys[indexx]].simpleTable) {
          $.each(originalData.cells[indexx], function (j, val) {
            dialog.inputs[keys[indexx]].simpleTable._createRow(val);
          });
        }
      };
      for (var indexx in keys) {
        _loop(indexx);
      }
      dialog.editedRow = index;
      $(dialog.modal).modal('show');
      //window.editEventBus.broadcast('MetadataChanged');
    }
  }, {
    key: "save",
    value: function save(index, originalData) {
      var O = this;
      console.log(originalData);
      O.add(originalData, index, true);
      _appUI._initTdCollapse(O.table);
    }
  }, {
    key: "remove",
    value: function remove(index) {
      var O = this;
      $(O.panelTable._$tbody).find('tr').eq(index).remove();
      ;
      O.data.splice(index, 1);
      O.panelTable._tableData.splice(index, 1);
      $.each($(O.panelTable._$tbody).find('tr'), function (rowindex, row) {
        $(row).attr('data-row-id', rowindex);
      });
      window.editEventBus.broadcast('MetadataChanged');
    }
  }, {
    key: "moveTo",
    value: function moveTo(index, command) {
      var O = this;
      var row = $(O.panelTable._$tbody).find('tr').eq(index);
      if (command === 'up') {
        row.insertBefore(row.prev());
        O.moveElement(O.data, index, --index);
      } else if (command === 'down') {
        row.insertAfter(row.next());
        O.moveElement(O.data, index, ++index);
      }
      $.each($(O.panelTable._$tbody).find('tr'), function (rowindex, row) {
        $(row).attr('data-row-id', rowindex);
      });
      window.editEventBus.broadcast('MetadataChanged');
    }
  }, {
    key: "moveElement",
    value: function moveElement(arr, old_index, new_index) {
      if (new_index >= arr.length) {
        var k = new_index - arr.length + 1;
        while (k--) {
          arr.push(undefined);
        }
      }
      arr.splice(new_index, 0, arr.splice(old_index, 1)[0]);
    }
  }, {
    key: "removeAll",
    value: function removeAll() {
      var O = this;
      O.data = []; // Clear data
      O.panelTable._tableData = []; // Clear data
      O.panelTable._clear(); // Empty table
      window.editEventBus.broadcast('MetadataChanged');
    }
  }]);
}();

},{"./APPTable.js":52,"./Dialog.js":56}],63:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextareaForm = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * Create a Bootstrap 3 form-group for a textarea. 
 */
var TextareaForm = exports.TextareaForm = /*#__PURE__*/function () {
  /**
   * Create a Bootstrap 3 form-group.
   * 
   * ```
   * <div class="form-group row">
   *   <label>name</label>
   *   <textarea class="form-control" rows="3"></textarea>
   * </div>
   * ```
   */

  function TextareaForm(name, mandatory, helperText, value) {
    _classCallCheck(this, TextareaForm);
    var O = this;
    O.name = name;
    O.mandatory = mandatory;
    O.helperText = helperText;
    O.textarea = $('<textarea row="6" class="form-control form-control-sm" />').attr('id', 'area_' + name.replace(/[\W_]+/g, "_"));
    O._create(name, mandatory, helperText, value);
  }

  /**
   * @param {string} name Property name
   * @param {boolean} mandatory `true` if mandatory, `false` if optional.
   * @param {string} helperText Tooltip
   * @param {string} value Initial value of the property.
   */
  return _createClass(TextareaForm, [{
    key: "_create",
    value: function _create(name, mandatory, helperText, value) {
      var O = this;
      // formgroup
      var $formGroup = $('<div class="form-group row"></div>');

      // label
      var $label = $('<label class="col-form-label col-form-label-sm col-9 col-xs-3 order-1 sim-param-label"></label>').attr('for', 'areaInput_' + name.replace(/[\W_]+/g, "_")).appendTo($formGroup);
      $label.text(name + (mandatory ? "*" : ""));

      // field
      var $field = $('<div class="col-12 col-xs-7 col-md-6 order-3 order-xs-2 "></div>').appendTo($formGroup);

      // actions
      var $actions = $('<div class="col-3 col-xs-auto order-2 order-xs-3 sim-param-actions"></div>').appendTo($formGroup);

      // input item
      O.input = null;

      // create param metadata action
      if (helperText) {
        // action metadata list
        var $actionMetadata = $('<button class="action action-pure float-right" type="button"><i class="feather icon-info"></i></button>').attr('data-toggle', 'collapse').attr('data-target', '#paramMetadata_' + name.replace(/[\W_]+/g, "_")).attr('aria-expanded', false).attr('aria-controls', 'paramMetadata_' + name.replace(/[\W_]+/g, "_")).attr('title', 'Show Metadata').appendTo($actions);
      }
      O.input = $('<textarea type="text" row="6" class="form-control" />').attr('id', 'areaInput_' + name.replace(/[\W_]+/g, "_")).appendTo($field);
      O.input.val(value);

      // create validation container
      O.input.$validationContainer = $('<div class="validation-message mt-1"></div>').appendTo($field);

      // create param metadata list
      if (helperText) {
        // metadata table
        var $metadataContainer = $('<div class="collapse param-metadata"></div>').attr('id', 'paramMetadata_' + name.replace(/[\W_]+/g, "_")).attr('aria-expanded', false).appendTo($field);
        $metadataContainer.append(_createHelperMetadataText(helperText));
      }
      O.group = $formGroup;
    }
  }, {
    key: "value",
    get: function get() {
      var O = this;
      return O.input.val();
    },
    set: function set(newValue) {
      var O = this;
      O.input.val(newValue);
    }
  }, {
    key: "onblurHandler",
    value: function onblurHandler() {
      var O = this;
      var closestForm = O.input.closest("form");
      var attr = closestForm.attr('no-immidiate-submit');
      var can_emit_Event = _typeof(attr) === (typeof undefined === "undefined" ? "undefined" : _typeof(undefined)) || attr === false;
      _log(' onblurHandler' + can_emit_Event);
      if (can_emit_Event) {
        window.editEventBus.broadcast('MetadataChanged');
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      var O = this;
      O.input.val("");
    }

    /**
     * @return {boolean} If the textarea is valid.
     */
  }, {
    key: "validate",
    value: function validate() {
      var O = this;
      var isValid;
      O.input.find('.has-error').removeClass('has-error');
      O.input.find('.is-invalid').removeClass('is-invalid');
      O.input.find('.validation-message').empty();
      if (!O.mandatory) {
        isValid = true;
      } else {
        isValid = O.input.val() ? true : false;
      }
      if (!isValid) {
        O.input.$validationContainer.text("required");
        O.input.parents('.form-group').addClass('has-error');
        O.input.addClass('is-invalid');
        O.input.$validationContainer.css("display", "block");
      } else {
        O.onblurHandler();
      }
      return isValid;
    }
  }]);
}();

},{}],64:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "APPLandingpage", {
  enumerable: true,
  get: function get() {
    return _APPLandingpage.APPLandingpage;
  }
});
Object.defineProperty(exports, "APPMTDetails", {
  enumerable: true,
  get: function get() {
    return _APPMTDetails.APPMTDetails;
  }
});
Object.defineProperty(exports, "APPMTEditableDetails", {
  enumerable: true,
  get: function get() {
    return _APPMTEditableDetails.APPMTEditableDetails;
  }
});
Object.defineProperty(exports, "APPModal", {
  enumerable: true,
  get: function get() {
    return _APPModal.APPModal;
  }
});
Object.defineProperty(exports, "APPModalMTDetails", {
  enumerable: true,
  get: function get() {
    return _APPModalMTDetails.APPModalMTDetails;
  }
});
Object.defineProperty(exports, "APPModalMTSimulations", {
  enumerable: true,
  get: function get() {
    return _APPModalMTSimulations.APPModalMTSimulations;
  }
});
Object.defineProperty(exports, "APPSimulation", {
  enumerable: true,
  get: function get() {
    return _APPSimulation.APPSimulation;
  }
});
Object.defineProperty(exports, "APPTable", {
  enumerable: true,
  get: function get() {
    return _APPTable.APPTable;
  }
});
Object.defineProperty(exports, "APPTableMT", {
  enumerable: true,
  get: function get() {
    return _APPTableMT.APPTableMT;
  }
});
Object.defineProperty(exports, "APPUI", {
  enumerable: true,
  get: function get() {
    return _APPUI.APPUI;
  }
});
Object.defineProperty(exports, "ApiClient", {
  enumerable: true,
  get: function get() {
    return _ApiClient.ApiClient;
  }
});
Object.defineProperty(exports, "ArrayForm", {
  enumerable: true,
  get: function get() {
    return _ArrayForm.ArrayForm;
  }
});
Object.defineProperty(exports, "Assay", {
  enumerable: true,
  get: function get() {
    return _Assay.Assay;
  }
});
Object.defineProperty(exports, "AssayView", {
  enumerable: true,
  get: function get() {
    return _AssayView.AssayView;
  }
});
Object.defineProperty(exports, "ConsumptionModel", {
  enumerable: true,
  get: function get() {
    return _ConsumptionModel.ConsumptionModel;
  }
});
Object.defineProperty(exports, "ConsumptionModelScope", {
  enumerable: true,
  get: function get() {
    return _ConsumptionModelScope.ConsumptionModelScope;
  }
});
Object.defineProperty(exports, "ConsumptionModelScopeView", {
  enumerable: true,
  get: function get() {
    return _ConsumptionModelScopeView.ConsumptionModelScopeView;
  }
});
Object.defineProperty(exports, "ConsumptionModelView", {
  enumerable: true,
  get: function get() {
    return _ConsumptionModelView.ConsumptionModelView;
  }
});
Object.defineProperty(exports, "Contact", {
  enumerable: true,
  get: function get() {
    return _Contact.Contact;
  }
});
Object.defineProperty(exports, "ContactView", {
  enumerable: true,
  get: function get() {
    return _ContactView.ContactView;
  }
});
Object.defineProperty(exports, "DataModel", {
  enumerable: true,
  get: function get() {
    return _DataModel.DataModel;
  }
});
Object.defineProperty(exports, "DataModelGeneralInformation", {
  enumerable: true,
  get: function get() {
    return _DataModelGeneralInformation.DataModelGeneralInformation;
  }
});
Object.defineProperty(exports, "DataModelGeneralInformationView", {
  enumerable: true,
  get: function get() {
    return _DataModelGeneralInformationView.DataModelGeneralInformationView;
  }
});
Object.defineProperty(exports, "DataModelModelMath", {
  enumerable: true,
  get: function get() {
    return _DataModelModelMath.DataModelModelMath;
  }
});
Object.defineProperty(exports, "DataModelModelMathView", {
  enumerable: true,
  get: function get() {
    return _DataModelModelMathView.DataModelModelMathView;
  }
});
Object.defineProperty(exports, "DataModelView", {
  enumerable: true,
  get: function get() {
    return _DataModelView.DataModelView;
  }
});
Object.defineProperty(exports, "Dialog", {
  enumerable: true,
  get: function get() {
    return _Dialog.Dialog;
  }
});
Object.defineProperty(exports, "DietaryAssessmentMethod", {
  enumerable: true,
  get: function get() {
    return _DietaryAssessmentMethod.DietaryAssessmentMethod;
  }
});
Object.defineProperty(exports, "DietaryAssessmentMethodView", {
  enumerable: true,
  get: function get() {
    return _DietaryAssessmentMethodView.DietaryAssessmentMethodView;
  }
});
Object.defineProperty(exports, "DoseResponseModel", {
  enumerable: true,
  get: function get() {
    return _DoseResponseModel.DoseResponseModel;
  }
});
Object.defineProperty(exports, "DoseResponseModelGeneralInformation", {
  enumerable: true,
  get: function get() {
    return _DoseResponseModelGeneralInformation.DoseResponseModelGeneralInformation;
  }
});
Object.defineProperty(exports, "DoseResponseModelGeneralInformationView", {
  enumerable: true,
  get: function get() {
    return _DoseResponseModelGeneralInformationView.DoseResponseModelGeneralInformationView;
  }
});
Object.defineProperty(exports, "DoseResponseModelModelMath", {
  enumerable: true,
  get: function get() {
    return _DoseResponseModelModelMath.DoseResponseModelModelMath;
  }
});
Object.defineProperty(exports, "DoseResponseModelModelMathView", {
  enumerable: true,
  get: function get() {
    return _DoseResponseModelModelMathView.DoseResponseModelModelMathView;
  }
});
Object.defineProperty(exports, "DoseResponseModelScope", {
  enumerable: true,
  get: function get() {
    return _DoseResponseModelScope.DoseResponseModelScope;
  }
});
Object.defineProperty(exports, "DoseResponseModelScopeView", {
  enumerable: true,
  get: function get() {
    return _DoseResponseModelScopeView.DoseResponseModelScopeView;
  }
});
Object.defineProperty(exports, "DoseResponseModelView", {
  enumerable: true,
  get: function get() {
    return _DoseResponseModelView.DoseResponseModelView;
  }
});
Object.defineProperty(exports, "EventObserver", {
  enumerable: true,
  get: function get() {
    return _EventObserver.EventObserver;
  }
});
Object.defineProperty(exports, "Exposure", {
  enumerable: true,
  get: function get() {
    return _Exposure.Exposure;
  }
});
Object.defineProperty(exports, "ExposureModel", {
  enumerable: true,
  get: function get() {
    return _ExposureModel.ExposureModel;
  }
});
Object.defineProperty(exports, "ExposureModelScope", {
  enumerable: true,
  get: function get() {
    return _ExposureModelScope.ExposureModelScope;
  }
});
Object.defineProperty(exports, "ExposureModelScopeView", {
  enumerable: true,
  get: function get() {
    return _ExposureModelScopeView.ExposureModelScopeView;
  }
});
Object.defineProperty(exports, "ExposureModelView", {
  enumerable: true,
  get: function get() {
    return _ExposureModelView.ExposureModelView;
  }
});
Object.defineProperty(exports, "ExposureView", {
  enumerable: true,
  get: function get() {
    return _ExposureView.ExposureView;
  }
});
Object.defineProperty(exports, "FormPanel", {
  enumerable: true,
  get: function get() {
    return _FormPanel.FormPanel;
  }
});
Object.defineProperty(exports, "GenericModel", {
  enumerable: true,
  get: function get() {
    return _GenericModel.GenericModel;
  }
});
Object.defineProperty(exports, "GenericModelDataBackground", {
  enumerable: true,
  get: function get() {
    return _GenericModelDataBackground.GenericModelDataBackground;
  }
});
Object.defineProperty(exports, "GenericModelDataBackgroundView", {
  enumerable: true,
  get: function get() {
    return _GenericModelDataBackgroundView.GenericModelDataBackgroundView;
  }
});
Object.defineProperty(exports, "GenericModelGeneralInformation", {
  enumerable: true,
  get: function get() {
    return _GenericModelGeneralInformation.GenericModelGeneralInformation;
  }
});
Object.defineProperty(exports, "GenericModelGeneralInformationView", {
  enumerable: true,
  get: function get() {
    return _GenericModelGeneralInformationView.GenericModelGeneralInformationView;
  }
});
Object.defineProperty(exports, "GenericModelModelMath", {
  enumerable: true,
  get: function get() {
    return _GenericModelModelMath.GenericModelModelMath;
  }
});
Object.defineProperty(exports, "GenericModelModelMathView", {
  enumerable: true,
  get: function get() {
    return _GenericModelModelMathView.GenericModelModelMathView;
  }
});
Object.defineProperty(exports, "GenericModelScope", {
  enumerable: true,
  get: function get() {
    return _GenericModelScope.GenericModelScope;
  }
});
Object.defineProperty(exports, "GenericModelScopeView", {
  enumerable: true,
  get: function get() {
    return _GenericModelScopeView.GenericModelScopeView;
  }
});
Object.defineProperty(exports, "GenericModelView", {
  enumerable: true,
  get: function get() {
    return _GenericModelView.GenericModelView;
  }
});
Object.defineProperty(exports, "Hazard", {
  enumerable: true,
  get: function get() {
    return _Hazard.Hazard;
  }
});
Object.defineProperty(exports, "HazardView", {
  enumerable: true,
  get: function get() {
    return _HazardView.HazardView;
  }
});
Object.defineProperty(exports, "HealthModel", {
  enumerable: true,
  get: function get() {
    return _HealthModel.HealthModel;
  }
});
Object.defineProperty(exports, "HealthModelScope", {
  enumerable: true,
  get: function get() {
    return _HealthModelScope.HealthModelScope;
  }
});
Object.defineProperty(exports, "HealthModelScopeView", {
  enumerable: true,
  get: function get() {
    return _HealthModelScopeView.HealthModelScopeView;
  }
});
Object.defineProperty(exports, "HealthModelView", {
  enumerable: true,
  get: function get() {
    return _HealthModelView.HealthModelView;
  }
});
Object.defineProperty(exports, "InputForm", {
  enumerable: true,
  get: function get() {
    return _InputForm.InputForm;
  }
});
Object.defineProperty(exports, "Laboratory", {
  enumerable: true,
  get: function get() {
    return _Laboratory.Laboratory;
  }
});
Object.defineProperty(exports, "LaboratoryView", {
  enumerable: true,
  get: function get() {
    return _LaboratoryView.LaboratoryView;
  }
});
Object.defineProperty(exports, "Model", {
  enumerable: true,
  get: function get() {
    return _Model.Model;
  }
});
Object.defineProperty(exports, "ModelCategory", {
  enumerable: true,
  get: function get() {
    return _ModelCategory.ModelCategory;
  }
});
Object.defineProperty(exports, "ModelCategoryView", {
  enumerable: true,
  get: function get() {
    return _ModelCategoryView.ModelCategoryView;
  }
});
Object.defineProperty(exports, "ModelEquation", {
  enumerable: true,
  get: function get() {
    return _ModelEquation.ModelEquation;
  }
});
Object.defineProperty(exports, "ModelEquationView", {
  enumerable: true,
  get: function get() {
    return _ModelEquationView.ModelEquationView;
  }
});
Object.defineProperty(exports, "ModelView", {
  enumerable: true,
  get: function get() {
    return _ModelView.ModelView;
  }
});
Object.defineProperty(exports, "OtherModel", {
  enumerable: true,
  get: function get() {
    return _OtherModel.OtherModel;
  }
});
Object.defineProperty(exports, "OtherModelDataBackground", {
  enumerable: true,
  get: function get() {
    return _OtherModelDataBackground.OtherModelDataBackground;
  }
});
Object.defineProperty(exports, "OtherModelDataBackgroundView", {
  enumerable: true,
  get: function get() {
    return _OtherModelDataBackgroundView.OtherModelDataBackgroundView;
  }
});
Object.defineProperty(exports, "OtherModelGeneralInformation", {
  enumerable: true,
  get: function get() {
    return _OtherModelGeneralInformation.OtherModelGeneralInformation;
  }
});
Object.defineProperty(exports, "OtherModelGeneralInformationView", {
  enumerable: true,
  get: function get() {
    return _OtherModelGeneralInformationView.OtherModelGeneralInformationView;
  }
});
Object.defineProperty(exports, "OtherModelModelMath", {
  enumerable: true,
  get: function get() {
    return _OtherModelModelMath.OtherModelModelMath;
  }
});
Object.defineProperty(exports, "OtherModelModelMathView", {
  enumerable: true,
  get: function get() {
    return _OtherModelModelMathView.OtherModelModelMathView;
  }
});
Object.defineProperty(exports, "OtherModelScope", {
  enumerable: true,
  get: function get() {
    return _OtherModelScope.OtherModelScope;
  }
});
Object.defineProperty(exports, "OtherModelScopeView", {
  enumerable: true,
  get: function get() {
    return _OtherModelScopeView.OtherModelScopeView;
  }
});
Object.defineProperty(exports, "OtherModelView", {
  enumerable: true,
  get: function get() {
    return _OtherModelView.OtherModelView;
  }
});
Object.defineProperty(exports, "Parameter", {
  enumerable: true,
  get: function get() {
    return _Parameter.Parameter;
  }
});
Object.defineProperty(exports, "ParameterView", {
  enumerable: true,
  get: function get() {
    return _ParameterView.ParameterView;
  }
});
Object.defineProperty(exports, "PopulationGroup", {
  enumerable: true,
  get: function get() {
    return _PopulationGroup.PopulationGroup;
  }
});
Object.defineProperty(exports, "PopulationGroupView", {
  enumerable: true,
  get: function get() {
    return _PopulationGroupView.PopulationGroupView;
  }
});
Object.defineProperty(exports, "PredictiveModel", {
  enumerable: true,
  get: function get() {
    return _PredictiveModel.PredictiveModel;
  }
});
Object.defineProperty(exports, "PredictiveModelDataBackground", {
  enumerable: true,
  get: function get() {
    return _PredictiveModelDataBackground.PredictiveModelDataBackground;
  }
});
Object.defineProperty(exports, "PredictiveModelDataBackgroundView", {
  enumerable: true,
  get: function get() {
    return _PredictiveModelDataBackgroundView.PredictiveModelDataBackgroundView;
  }
});
Object.defineProperty(exports, "PredictiveModelGeneralInformation", {
  enumerable: true,
  get: function get() {
    return _PredictiveModelGeneralInformation.PredictiveModelGeneralInformation;
  }
});
Object.defineProperty(exports, "PredictiveModelGeneralInformationView", {
  enumerable: true,
  get: function get() {
    return _PredictiveModelGeneralInformationView.PredictiveModelGeneralInformationView;
  }
});
Object.defineProperty(exports, "PredictiveModelModelMath", {
  enumerable: true,
  get: function get() {
    return _PredictiveModelModelMath.PredictiveModelModelMath;
  }
});
Object.defineProperty(exports, "PredictiveModelModelMathView", {
  enumerable: true,
  get: function get() {
    return _PredictiveModelModelMathView.PredictiveModelModelMathView;
  }
});
Object.defineProperty(exports, "PredictiveModelScope", {
  enumerable: true,
  get: function get() {
    return _PredictiveModelScope.PredictiveModelScope;
  }
});
Object.defineProperty(exports, "PredictiveModelScopeProduct", {
  enumerable: true,
  get: function get() {
    return _PredictiveModelScopeProduct.PredictiveModelScopeProduct;
  }
});
Object.defineProperty(exports, "PredictiveModelScopeProductView", {
  enumerable: true,
  get: function get() {
    return _PredictiveModelScopeProductView.PredictiveModelScopeProductView;
  }
});
Object.defineProperty(exports, "PredictiveModelScopeView", {
  enumerable: true,
  get: function get() {
    return _PredictiveModelScopeView.PredictiveModelScopeView;
  }
});
Object.defineProperty(exports, "PredictiveModelView", {
  enumerable: true,
  get: function get() {
    return _PredictiveModelView.PredictiveModelView;
  }
});
Object.defineProperty(exports, "ProcessModel", {
  enumerable: true,
  get: function get() {
    return _ProcessModel.ProcessModel;
  }
});
Object.defineProperty(exports, "ProcessModelScope", {
  enumerable: true,
  get: function get() {
    return _ProcessModelScope.ProcessModelScope;
  }
});
Object.defineProperty(exports, "ProcessModelScopeView", {
  enumerable: true,
  get: function get() {
    return _ProcessModelScopeView.ProcessModelScopeView;
  }
});
Object.defineProperty(exports, "ProcessModelView", {
  enumerable: true,
  get: function get() {
    return _ProcessModelView.ProcessModelView;
  }
});
Object.defineProperty(exports, "Product", {
  enumerable: true,
  get: function get() {
    return _Product.Product;
  }
});
Object.defineProperty(exports, "ProductView", {
  enumerable: true,
  get: function get() {
    return _ProductView.ProductView;
  }
});
Object.defineProperty(exports, "QraModel", {
  enumerable: true,
  get: function get() {
    return _QraModel.QraModel;
  }
});
Object.defineProperty(exports, "QraModelView", {
  enumerable: true,
  get: function get() {
    return _QraModelView.QraModelView;
  }
});
Object.defineProperty(exports, "QualityMeasures", {
  enumerable: true,
  get: function get() {
    return _QualityMeasures.QualityMeasures;
  }
});
Object.defineProperty(exports, "QualityMeasuresView", {
  enumerable: true,
  get: function get() {
    return _QualityMeasuresView.QualityMeasuresView;
  }
});
Object.defineProperty(exports, "Reference", {
  enumerable: true,
  get: function get() {
    return _Reference.Reference;
  }
});
Object.defineProperty(exports, "ReferenceView", {
  enumerable: true,
  get: function get() {
    return _ReferenceView.ReferenceView;
  }
});
Object.defineProperty(exports, "RiskModel", {
  enumerable: true,
  get: function get() {
    return _RiskModel.RiskModel;
  }
});
Object.defineProperty(exports, "RiskModelView", {
  enumerable: true,
  get: function get() {
    return _RiskModelView.RiskModelView;
  }
});
Object.defineProperty(exports, "SelectForm", {
  enumerable: true,
  get: function get() {
    return _SelectForm.SelectForm;
  }
});
Object.defineProperty(exports, "SimpleTable", {
  enumerable: true,
  get: function get() {
    return _SimpleTable.SimpleTable;
  }
});
Object.defineProperty(exports, "Study", {
  enumerable: true,
  get: function get() {
    return _Study.Study;
  }
});
Object.defineProperty(exports, "StudySample", {
  enumerable: true,
  get: function get() {
    return _StudySample.StudySample;
  }
});
Object.defineProperty(exports, "StudySampleView", {
  enumerable: true,
  get: function get() {
    return _StudySampleView.StudySampleView;
  }
});
Object.defineProperty(exports, "StudyView", {
  enumerable: true,
  get: function get() {
    return _StudyView.StudyView;
  }
});
Object.defineProperty(exports, "TablePanel", {
  enumerable: true,
  get: function get() {
    return _TablePanel.TablePanel;
  }
});
Object.defineProperty(exports, "TextareaForm", {
  enumerable: true,
  get: function get() {
    return _TextareaForm.TextareaForm;
  }
});
Object.defineProperty(exports, "ToxicologicalModel", {
  enumerable: true,
  get: function get() {
    return _ToxicologicalModel.ToxicologicalModel;
  }
});
Object.defineProperty(exports, "ToxicologicalModelScope", {
  enumerable: true,
  get: function get() {
    return _ToxicologicalModelScope.ToxicologicalModelScope;
  }
});
Object.defineProperty(exports, "ToxicologicalModelScopeView", {
  enumerable: true,
  get: function get() {
    return _ToxicologicalModelScopeView.ToxicologicalModelScopeView;
  }
});
Object.defineProperty(exports, "ToxicologicalModelView", {
  enumerable: true,
  get: function get() {
    return _ToxicologicalModelView.ToxicologicalModelView;
  }
});
var _ApiClient = require("./ApiClient");
var _EventObserver = require("./app/EventObserver.js");
var _ArrayForm = require("./app/ArrayForm.js");
var _InputForm = require("./app/InputForm.js");
var _SelectForm = require("./app/SelectForm.js");
var _SimpleTable = require("./app/SimpleTable.js");
var _TablePanel = require("./app/TablePanel.js");
var _TextareaForm = require("./app/TextareaForm.js");
var _FormPanel = require("./app/FormPanel.js");
var _Dialog = require("./app/Dialog.js");
var _APPTable = require("./app/APPTable.js");
var _APPTableMT = require("./app/APPTableMT.js");
var _APPModal = require("./app/APPModal.js");
var _APPModalMTDetails = require("./app/APPModalMTDetails.js");
var _APPMTEditableDetails = require("./app/APPMTEditableDetails.js");
var _APPModalMTSimulations = require("./app/APPModalMTSimulations.js");
var _APPSimulation = require("./app/APPSimulation.js");
var _APPUI = require("./app/APPUI.js");
var _APPMTDetails = require("./app/APPMTDetails.js");
var _APPLandingpage = require("./app/APPLandingpage.js");
var _Assay = require("./model/Assay");
var _ConsumptionModel = require("./model/ConsumptionModel");
var _ConsumptionModelScope = require("./model/ConsumptionModelScope");
var _Contact = require("./model/Contact");
var _DataModel = require("./model/DataModel");
var _DataModelGeneralInformation = require("./model/DataModelGeneralInformation");
var _DataModelModelMath = require("./model/DataModelModelMath");
var _DietaryAssessmentMethod = require("./model/DietaryAssessmentMethod");
var _DoseResponseModel = require("./model/DoseResponseModel");
var _DoseResponseModelGeneralInformation = require("./model/DoseResponseModelGeneralInformation");
var _DoseResponseModelModelMath = require("./model/DoseResponseModelModelMath");
var _DoseResponseModelScope = require("./model/DoseResponseModelScope");
var _Exposure = require("./model/Exposure");
var _ExposureModel = require("./model/ExposureModel");
var _ExposureModelScope = require("./model/ExposureModelScope");
var _GenericModel = require("./model/GenericModel");
var _GenericModelDataBackground = require("./model/GenericModelDataBackground");
var _GenericModelGeneralInformation = require("./model/GenericModelGeneralInformation");
var _GenericModelModelMath = require("./model/GenericModelModelMath");
var _GenericModelScope = require("./model/GenericModelScope");
var _Hazard = require("./model/Hazard");
var _HealthModel = require("./model/HealthModel");
var _HealthModelScope = require("./model/HealthModelScope");
var _Laboratory = require("./model/Laboratory");
var _Model = require("./model/Model");
var _ModelCategory = require("./model/ModelCategory");
var _ModelEquation = require("./model/ModelEquation");
var _OtherModel = require("./model/OtherModel");
var _OtherModelDataBackground = require("./model/OtherModelDataBackground");
var _OtherModelGeneralInformation = require("./model/OtherModelGeneralInformation");
var _OtherModelModelMath = require("./model/OtherModelModelMath");
var _OtherModelScope = require("./model/OtherModelScope");
var _Parameter = require("./model/Parameter");
var _PopulationGroup = require("./model/PopulationGroup");
var _PredictiveModel = require("./model/PredictiveModel");
var _PredictiveModelDataBackground = require("./model/PredictiveModelDataBackground");
var _PredictiveModelGeneralInformation = require("./model/PredictiveModelGeneralInformation");
var _PredictiveModelModelMath = require("./model/PredictiveModelModelMath");
var _PredictiveModelScope = require("./model/PredictiveModelScope");
var _PredictiveModelScopeProduct = require("./model/PredictiveModelScopeProduct");
var _ProcessModel = require("./model/ProcessModel");
var _ProcessModelScope = require("./model/ProcessModelScope");
var _Product = require("./model/Product");
var _QraModel = require("./model/QraModel");
var _QualityMeasures = require("./model/QualityMeasures");
var _Reference = require("./model/Reference");
var _RiskModel = require("./model/RiskModel");
var _Study = require("./model/Study");
var _StudySample = require("./model/StudySample");
var _ToxicologicalModel = require("./model/ToxicologicalModel");
var _ToxicologicalModelScope = require("./model/ToxicologicalModelScope");
var _AssayView = require("./model/AssayView");
var _ConsumptionModelView = require("./model/ConsumptionModelView");
var _ConsumptionModelScopeView = require("./model/ConsumptionModelScopeView");
var _ContactView = require("./model/ContactView");
var _DataModelView = require("./model/DataModelView");
var _DataModelGeneralInformationView = require("./model/DataModelGeneralInformationView");
var _DataModelModelMathView = require("./model/DataModelModelMathView");
var _DietaryAssessmentMethodView = require("./model/DietaryAssessmentMethodView");
var _DoseResponseModelView = require("./model/DoseResponseModelView");
var _DoseResponseModelGeneralInformationView = require("./model/DoseResponseModelGeneralInformationView");
var _DoseResponseModelModelMathView = require("./model/DoseResponseModelModelMathView");
var _DoseResponseModelScopeView = require("./model/DoseResponseModelScopeView");
var _ExposureView = require("./model/ExposureView");
var _ExposureModelView = require("./model/ExposureModelView");
var _ExposureModelScopeView = require("./model/ExposureModelScopeView");
var _GenericModelView = require("./model/GenericModelView");
var _GenericModelDataBackgroundView = require("./model/GenericModelDataBackgroundView");
var _GenericModelGeneralInformationView = require("./model/GenericModelGeneralInformationView");
var _GenericModelModelMathView = require("./model/GenericModelModelMathView");
var _GenericModelScopeView = require("./model/GenericModelScopeView");
var _HazardView = require("./model/HazardView");
var _HealthModelView = require("./model/HealthModelView");
var _HealthModelScopeView = require("./model/HealthModelScopeView");
var _LaboratoryView = require("./model/LaboratoryView");
var _ModelView = require("./model/ModelView");
var _ModelCategoryView = require("./model/ModelCategoryView");
var _ModelEquationView = require("./model/ModelEquationView");
var _OtherModelView = require("./model/OtherModelView");
var _OtherModelDataBackgroundView = require("./model/OtherModelDataBackgroundView");
var _OtherModelGeneralInformationView = require("./model/OtherModelGeneralInformationView");
var _OtherModelModelMathView = require("./model/OtherModelModelMathView");
var _OtherModelScopeView = require("./model/OtherModelScopeView");
var _ParameterView = require("./model/ParameterView");
var _PopulationGroupView = require("./model/PopulationGroupView");
var _PredictiveModelView = require("./model/PredictiveModelView");
var _PredictiveModelDataBackgroundView = require("./model/PredictiveModelDataBackgroundView");
var _PredictiveModelGeneralInformationView = require("./model/PredictiveModelGeneralInformationView");
var _PredictiveModelModelMathView = require("./model/PredictiveModelModelMathView");
var _PredictiveModelScopeView = require("./model/PredictiveModelScopeView");
var _PredictiveModelScopeProductView = require("./model/PredictiveModelScopeProductView");
var _ProcessModelView = require("./model/ProcessModelView");
var _ProcessModelScopeView = require("./model/ProcessModelScopeView");
var _ProductView = require("./model/ProductView");
var _QraModelView = require("./model/QraModelView");
var _QualityMeasuresView = require("./model/QualityMeasuresView");
var _ReferenceView = require("./model/ReferenceView");
var _RiskModelView = require("./model/RiskModelView");
var _StudyView = require("./model/StudyView");
var _StudySampleView = require("./model/StudySampleView");
var _ToxicologicalModelView = require("./model/ToxicologicalModelView");
var _ToxicologicalModelScopeView = require("./model/ToxicologicalModelScopeView");

},{"./ApiClient":44,"./app/APPLandingpage.js":45,"./app/APPMTDetails.js":46,"./app/APPMTEditableDetails.js":47,"./app/APPModal.js":48,"./app/APPModalMTDetails.js":49,"./app/APPModalMTSimulations.js":50,"./app/APPSimulation.js":51,"./app/APPTable.js":52,"./app/APPTableMT.js":53,"./app/APPUI.js":54,"./app/ArrayForm.js":55,"./app/Dialog.js":56,"./app/EventObserver.js":57,"./app/FormPanel.js":58,"./app/InputForm.js":59,"./app/SelectForm.js":60,"./app/SimpleTable.js":61,"./app/TablePanel.js":62,"./app/TextareaForm.js":63,"./model/Assay":65,"./model/AssayView":66,"./model/ConsumptionModel":67,"./model/ConsumptionModelScope":68,"./model/ConsumptionModelScopeView":69,"./model/ConsumptionModelView":70,"./model/Contact":71,"./model/ContactView":72,"./model/DataModel":73,"./model/DataModelGeneralInformation":74,"./model/DataModelGeneralInformationView":75,"./model/DataModelModelMath":76,"./model/DataModelModelMathView":77,"./model/DataModelView":78,"./model/DietaryAssessmentMethod":79,"./model/DietaryAssessmentMethodView":80,"./model/DoseResponseModel":81,"./model/DoseResponseModelGeneralInformation":82,"./model/DoseResponseModelGeneralInformationView":83,"./model/DoseResponseModelModelMath":84,"./model/DoseResponseModelModelMathView":85,"./model/DoseResponseModelScope":86,"./model/DoseResponseModelScopeView":87,"./model/DoseResponseModelView":88,"./model/Exposure":89,"./model/ExposureModel":90,"./model/ExposureModelScope":91,"./model/ExposureModelScopeView":92,"./model/ExposureModelView":93,"./model/ExposureView":94,"./model/GenericModel":95,"./model/GenericModelDataBackground":96,"./model/GenericModelDataBackgroundView":97,"./model/GenericModelGeneralInformation":98,"./model/GenericModelGeneralInformationView":99,"./model/GenericModelModelMath":100,"./model/GenericModelModelMathView":101,"./model/GenericModelScope":102,"./model/GenericModelScopeView":103,"./model/GenericModelView":104,"./model/Hazard":105,"./model/HazardView":106,"./model/HealthModel":107,"./model/HealthModelScope":108,"./model/HealthModelScopeView":109,"./model/HealthModelView":110,"./model/Laboratory":111,"./model/LaboratoryView":112,"./model/Model":113,"./model/ModelCategory":114,"./model/ModelCategoryView":115,"./model/ModelEquation":116,"./model/ModelEquationView":117,"./model/ModelView":118,"./model/OtherModel":119,"./model/OtherModelDataBackground":120,"./model/OtherModelDataBackgroundView":121,"./model/OtherModelGeneralInformation":122,"./model/OtherModelGeneralInformationView":123,"./model/OtherModelModelMath":124,"./model/OtherModelModelMathView":125,"./model/OtherModelScope":126,"./model/OtherModelScopeView":127,"./model/OtherModelView":128,"./model/Parameter":129,"./model/ParameterView":130,"./model/PopulationGroup":131,"./model/PopulationGroupView":132,"./model/PredictiveModel":133,"./model/PredictiveModelDataBackground":134,"./model/PredictiveModelDataBackgroundView":135,"./model/PredictiveModelGeneralInformation":136,"./model/PredictiveModelGeneralInformationView":137,"./model/PredictiveModelModelMath":138,"./model/PredictiveModelModelMathView":139,"./model/PredictiveModelScope":140,"./model/PredictiveModelScopeProduct":141,"./model/PredictiveModelScopeProductView":142,"./model/PredictiveModelScopeView":143,"./model/PredictiveModelView":144,"./model/ProcessModel":145,"./model/ProcessModelScope":146,"./model/ProcessModelScopeView":147,"./model/ProcessModelView":148,"./model/Product":149,"./model/ProductView":150,"./model/QraModel":151,"./model/QraModelView":152,"./model/QualityMeasures":153,"./model/QualityMeasuresView":154,"./model/Reference":155,"./model/ReferenceView":156,"./model/RiskModel":157,"./model/RiskModelView":158,"./model/Study":159,"./model/StudySample":160,"./model/StudySampleView":161,"./model/StudyView":162,"./model/ToxicologicalModel":163,"./model/ToxicologicalModelScope":164,"./model/ToxicologicalModelScopeView":165,"./model/ToxicologicalModelView":166}],65:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Assay = void 0;
var _ApiClient = require("../ApiClient");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Assay model module.
 * @module model/Assay
 * @version 1.0.0
 */
var Assay = exports.Assay = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>Assay</code>.
   * @alias module:model/Assay
   * @class
   * @param name {} A name given to the assay
   */
  function Assay(name) {
    _classCallCheck(this, Assay);
    this.name = name;
  }

  /**
   * Constructs a <code>Assay</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/Assay} obj Optional instance to populate.
   * @return {module:model/Assay} The populated <code>Assay</code> instance.
   */
  return _createClass(Assay, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new Assay();
        if (data.hasOwnProperty('contaminationRange')) obj.contaminationRange = _ApiClient.ApiClient.convertToType(data['contaminationRange'], 'String');
        if (data.hasOwnProperty('uncertaintyValue')) obj.uncertaintyValue = _ApiClient.ApiClient.convertToType(data['uncertaintyValue'], 'String');
        if (data.hasOwnProperty('fatPercentage')) obj.fatPercentage = _ApiClient.ApiClient.convertToType(data['fatPercentage'], 'String');
        if (data.hasOwnProperty('name')) obj.name = _ApiClient.ApiClient.convertToType(data['name'], 'String');
        if (data.hasOwnProperty('description')) obj.description = _ApiClient.ApiClient.convertToType(data['description'], 'String');
        if (data.hasOwnProperty('moisturePercentage')) obj.moisturePercentage = _ApiClient.ApiClient.convertToType(data['moisturePercentage'], 'String');
        if (data.hasOwnProperty('leftCensoredData')) obj.leftCensoredData = _ApiClient.ApiClient.convertToType(data['leftCensoredData'], 'String');
        if (data.hasOwnProperty('detectionLimit')) obj.detectionLimit = _ApiClient.ApiClient.convertToType(data['detectionLimit'], 'String');
        if (data.hasOwnProperty('quantificationLimit')) obj.quantificationLimit = _ApiClient.ApiClient.convertToType(data['quantificationLimit'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * Range of result of the analytical measure reported in the unit specified by the variable Hazard unit
 * @member {String} contaminationRange
 */
Assay.prototype.contaminationRange = undefined;

/**
 * Indicate the expanded uncertainty (usually 95% confidence interval) value associated with the measurement expressed in the unit reported in the field Hazard unit
 * @member {String} uncertaintyValue
 */
Assay.prototype.uncertaintyValue = undefined;

/**
 * Percentage of fat in the original sample
 * @member {String} fatPercentage
 */
Assay.prototype.fatPercentage = undefined;

/**
 * A name given to the assay
 * @member {String} name
 */
Assay.prototype.name = undefined;

/**
 * General description of the assay. Corresponds to the Protocol REF in ISA
 * @member {String} description
 */
Assay.prototype.description = undefined;

/**
 * Percentage of moisture in the original sample
 * @member {String} moisturePercentage
 */
Assay.prototype.moisturePercentage = undefined;

/**
 * Percentage of measures equal to LOQ and/or LOD
 * @member {String} leftCensoredData
 */
Assay.prototype.leftCensoredData = undefined;

/**
 * Limit of detection reported in the unit specified by the variable Hazard unit
 * @member {String} detectionLimit
 */
Assay.prototype.detectionLimit = undefined;

/**
 * Limit of quantification reported in the unit specified by the variable Hazard unit
 * @member {String} quantificationLimit
 */
Assay.prototype.quantificationLimit = undefined;

},{"../ApiClient":44}],66:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AssayView = void 0;
var _ApiClient = require("../ApiClient");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Assay View  module.
 * @module model/Assay
 * @version 1.0.0
 */
var AssayView = exports.AssayView = /*#__PURE__*/_createClass(function AssayView() {
  _classCallCheck(this, AssayView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63}],67:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConsumptionModel = void 0;
var _ApiClient = require("../ApiClient");
var _ConsumptionModelScope = require("./ConsumptionModelScope");
var _GenericModelDataBackground = require("./GenericModelDataBackground");
var _Model2 = require("./Model");
var _PredictiveModelGeneralInformation = require("./PredictiveModelGeneralInformation");
var _PredictiveModelModelMath = require("./PredictiveModelModelMath");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ConsumptionModel model module.
 * @module model/ConsumptionModel
 * @version 1.0.0
 */
var ConsumptionModel = exports.ConsumptionModel = /*#__PURE__*/function (_Model) {
  /**
   * Constructs a new <code>ConsumptionModel</code>.
   * @alias module:model/ConsumptionModel
   * @class
   * @extends module:model/Model
   * @param modelType {} 
   */
  function ConsumptionModel(modelType) {
    _classCallCheck(this, ConsumptionModel);
    return _callSuper(this, ConsumptionModel, [modelType]);
  }

  /**
   * Constructs a <code>ConsumptionModel</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/ConsumptionModel} obj Optional instance to populate.
   * @return {module:model/ConsumptionModel} The populated <code>ConsumptionModel</code> instance.
   */
  _inherits(ConsumptionModel, _Model);
  return _createClass(ConsumptionModel, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new ConsumptionModel();
        _Model2.Model.constructFromObject(data, obj);
        if (data.hasOwnProperty('dataBackground')) obj.dataBackground = _GenericModelDataBackground.GenericModelDataBackground.constructFromObject(data['dataBackground']);
        if (data.hasOwnProperty('modelMath')) obj.modelMath = _PredictiveModelModelMath.PredictiveModelModelMath.constructFromObject(data['modelMath']);
        if (data.hasOwnProperty('scope')) obj.scope = _ConsumptionModelScope.ConsumptionModelScope.constructFromObject(data['scope']);
        if (data.hasOwnProperty('generalInformation')) obj.generalInformation = _PredictiveModelGeneralInformation.PredictiveModelGeneralInformation.constructFromObject(data['generalInformation']);
      }
      return obj;
    }
  }]);
}(_Model2.Model);
/**
 * @member {module:model/GenericModelDataBackground} dataBackground
 */
ConsumptionModel.prototype.dataBackground = undefined;

/**
 * @member {module:model/PredictiveModelModelMath} modelMath
 */
ConsumptionModel.prototype.modelMath = undefined;

/**
 * @member {module:model/ConsumptionModelScope} scope
 */
ConsumptionModel.prototype.scope = undefined;

/**
 * @member {module:model/PredictiveModelGeneralInformation} generalInformation
 */
ConsumptionModel.prototype.generalInformation = undefined;

},{"../ApiClient":44,"./ConsumptionModelScope":68,"./GenericModelDataBackground":96,"./Model":113,"./PredictiveModelGeneralInformation":136,"./PredictiveModelModelMath":138}],68:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConsumptionModelScope = void 0;
var _ApiClient = require("../ApiClient");
var _PopulationGroup = require("./PopulationGroup");
var _Product = require("./Product");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ConsumptionModelScope model module.
 * @module model/ConsumptionModelScope
 * @version 1.0.0
 */
var ConsumptionModelScope = exports.ConsumptionModelScope = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>ConsumptionModelScope</code>.
   * @alias module:model/ConsumptionModelScope
   * @class
   */
  function ConsumptionModelScope() {
    _classCallCheck(this, ConsumptionModelScope);
  }

  /**
   * Constructs a <code>ConsumptionModelScope</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/ConsumptionModelScope} obj Optional instance to populate.
   * @return {module:model/ConsumptionModelScope} The populated <code>ConsumptionModelScope</code> instance.
   */
  return _createClass(ConsumptionModelScope, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new ConsumptionModelScope();
        if (data.hasOwnProperty('spatialInformation')) obj.spatialInformation = _ApiClient.ApiClient.convertToType(data['spatialInformation'], ['String']);
        if (data.hasOwnProperty('product')) obj.product = _ApiClient.ApiClient.convertToType(data['product'], [_Product.Product]);
        if (data.hasOwnProperty('populationGroup')) obj.populationGroup = _ApiClient.ApiClient.convertToType(data['populationGroup'], [_PopulationGroup.PopulationGroup]);
        if (data.hasOwnProperty('generalComment')) obj.generalComment = _ApiClient.ApiClient.convertToType(data['generalComment'], 'String');
        if (data.hasOwnProperty('temporalInformation')) obj.temporalInformation = _ApiClient.ApiClient.convertToType(data['temporalInformation'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * Spatial information (area) on which the model or data applies
 * @member {Array.<String>} spatialInformation
 */
ConsumptionModelScope.prototype.spatialInformation = undefined;

/**
 * @member {Array.<module:model/Product>} product
 */
ConsumptionModelScope.prototype.product = undefined;

/**
 * @member {Array.<module:model/PopulationGroup>} populationGroup
 */
ConsumptionModelScope.prototype.populationGroup = undefined;

/**
 * General comments on the scope of the study, data or model
 * @member {String} generalComment
 */
ConsumptionModelScope.prototype.generalComment = undefined;

/**
 * Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)
 * @member {String} temporalInformation
 */
ConsumptionModelScope.prototype.temporalInformation = undefined;

},{"../ApiClient":44,"./PopulationGroup":131,"./Product":149}],69:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConsumptionModelScopeView = void 0;
var _ApiClient = require("../ApiClient");
var _PopulationGroupView = require("./PopulationGroupView");
var _ProductView = require("./ProductView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ConsumptionModelScope View  module.
 * @module model/ConsumptionModelScope
 * @version 1.0.0
 */
var ConsumptionModelScopeView = exports.ConsumptionModelScopeView = /*#__PURE__*/_createClass(function ConsumptionModelScopeView() {
  _classCallCheck(this, ConsumptionModelScopeView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./PopulationGroupView":132,"./ProductView":150}],70:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConsumptionModelView = void 0;
var _ApiClient = require("../ApiClient");
var _ConsumptionModelScopeView = require("./ConsumptionModelScopeView");
var _GenericModelDataBackgroundView = require("./GenericModelDataBackgroundView");
var _ModelView2 = require("./ModelView");
var _PredictiveModelGeneralInformationView = require("./PredictiveModelGeneralInformationView");
var _PredictiveModelModelMathView = require("./PredictiveModelModelMathView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ConsumptionModel View  module.
 * @module model/ConsumptionModel
 * @version 1.0.0
 */
var ConsumptionModelView = exports.ConsumptionModelView = /*#__PURE__*/function (_ModelView) {
  function ConsumptionModelView(metadata, img, state, modelScript, visScript, readme) {
    var _this;
    _classCallCheck(this, ConsumptionModelView);
    _this = _callSuper(this, ConsumptionModelView, [metadata, img, modelScript, visScript, readme]);
    _this._schema = schemas.genericModel;
    if (state) {
      _this.panels = _this._createPanels();
    }
    _this._menu = [{
      "label": "General Information",
      "id": "generalInformation",
      "submenus": [{
        "label": "General Information",
        "id": "generalInformation"
      }, {
        "label": "Model Category",
        "id": "modelCategory"
      }, {
        "label": "Reference",
        "id": "reference"
      }, {
        "label": "Author",
        "id": "author"
      }, {
        "label": "Creator",
        "id": "creator"
      }]
    }, {
      "label": "Scope",
      "id": "scope",
      "submenus": [{
        "label": "Scope",
        "id": "scope"
      }, {
        "label": "Population Group",
        "id": "populationGroup"
      }, {
        "label": "Product",
        "id": "product"
      }]
    }, {
      "label": "Model Math",
      "id": "modelMath",
      "submenus": [{
        "label": "Model Math",
        "id": "modelMath"
      }, {
        "label": "Quality Measures",
        "id": "qualityMeasures"
      }, {
        "label": "Parameter",
        "id": "parameter",
        "submenus": [{
          "label": "Parameter",
          "id": "parameter"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }, {
        "label": "Model Equation",
        "id": "modelEquation",
        "submenus": [{
          "label": "Model Equation",
          "id": "modelEquation"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }]
    }, {
      "label": "Data Background",
      "id": "dataBackground",
      "submenus": [{
        "label": "Study Sample",
        "id": "studySample"
      }, {
        "label": "Dietary Assessment Method",
        "id": "dietaryAssessmentMethod"
      }, {
        "label": "Assay",
        "id": "assay"
      }, {
        "label": "Laboratory",
        "id": "laboratory"
      }, {
        "label": "Study",
        "id": "study"
      }]
    }];
    _this._panels = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
      study: {
        type: 'simple',
        schema: _this.jsonSchema.dataBackgroundstudy,
        metadata: _this._metadata.study
      },
      laboratory: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundlaboratory,
        metadata: _this._metadata.laboratory
      },
      assay: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundassay,
        metadata: _this._metadata.assay
      },
      dietaryAssessmentMethod: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgrounddietaryAssessmentMethod,
        metadata: _this._metadata.dietaryAssessmentMethod
      },
      studySample: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundstudySample,
        metadata: _this._metadata.studySample
      },
      modelMath: {
        type: 'simple',
        schema: _this.jsonSchema.modelMathmodelMath,
        metadata: _this._metadata.modelMath
      },
      modelEquation: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationmodelEquation,
        metadata: _this._metadata.modelEquation
      },
      reference: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationreference,
        metadata: _this._metadata.reference
      },
      parameter: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.parameterparameter,
        metadata: _this._metadata.parameter
      }
    }, "reference", {
      type: 'simple',
      schema: _this.jsonSchema.modelMath.parameterreference,
      metadata: _this._metadata.reference
    }), "qualityMeasures", {
      type: 'complex',
      schema: _this.jsonSchema.modelMathqualityMeasures,
      metadata: _this._metadata.qualityMeasures
    }), "scope", {
      type: 'simple',
      schema: _this.jsonSchema.scopescope,
      metadata: _this._metadata.scope
    }), "product", {
      type: 'complex',
      schema: _this.jsonSchema.scopeproduct,
      metadata: _this._metadata.product
    }), "populationGroup", {
      type: 'complex',
      schema: _this.jsonSchema.scopepopulationGroup,
      metadata: _this._metadata.populationGroup
    }), "generalInformation", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationgeneralInformation,
      metadata: _this._metadata.generalInformation
    }), "creator", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationcreator,
      metadata: _this._metadata.creator
    }), "author", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationauthor,
      metadata: _this._metadata.author
    }), "reference", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationreference,
      metadata: _this._metadata.reference
    }), "modelCategory", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationmodelCategory,
      metadata: _this._metadata.modelCategory
    });
    return _this;
  }
  _inherits(ConsumptionModelView, _ModelView);
  return _createClass(ConsumptionModelView, [{
    key: "metaData",
    get: function get() {
      try {
        this._metadata.dataBackground.study = this.panels.study.data;
        this._metadata.dataBackground.laboratory = this.panels.laboratory.data;
        this._metadata.dataBackground.assay = this.panels.assay.data;
        this._metadata.dataBackground.dietaryAssessmentMethod = this.panels.dietaryAssessmentMethod.data;
        this._metadata.dataBackground.studySample = this.panels.studySample.data;
        this._metadata.modelMath = this.panels.modelMath.data;
        this._metadata.modelMath.modelEquation = this.panels.modelEquation.data;
        this._metadata.modelMath.modelEquation.reference = this.panels.reference.data;
        this._metadata.modelMath.parameter = this.panels.parameter.data;
        this._metadata.modelMath.parameter.reference = this.panels.reference.data;
        this._metadata.modelMath.qualityMeasures = this.panels.qualityMeasures.data;
        this._metadata.scope = this.panels.scope.data;
        this._metadata.scope.product = this.panels.product.data;
        this._metadata.scope.populationGroup = this.panels.populationGroup.data;
        this._metadata.generalInformation = this.panels.generalInformation.data;
        this._metadata.generalInformation.creator = this.panels.creator.data;
        this._metadata.generalInformation.author = this.panels.author.data;
        this._metadata.generalInformation.reference = this.panels.reference.data;
        this._metadata.generalInformation.modelCategory = this.panels.modelCategory.data;
        this._metadata.modelType = "ConsumptionModel";
        this._metadata = metadataFix(this._metadata);
      } catch (error) {
        console.log(error);
      }
      return this._metadata;
    }
  }, {
    key: "jsonSchema",
    get: function get() {
      return {
        "dataBackground": {
          "study": [{
            "id": "identifier",
            "label": "Study identifier",
            "type": "text",
            "description": "A user defined identifier for the study"
          }, {
            "id": "protocolComponentsName",
            "label": "Components names",
            "type": "text",
            "description": "The names of the components used when carrying out this protocol"
          }, {
            "id": "designType",
            "label": "Design type",
            "type": "text",
            "description": "The type of study design being employed"
          }, {
            "id": "assayMeasurementType",
            "label": "Assay measurement type",
            "type": "text",
            "description": "The measurement being observed in this assay"
          }, {
            "id": "protocolComponentsType",
            "label": "Protocol components type",
            "type": "text",
            "description": "Description"
          }, {
            "id": "description",
            "label": "Study description",
            "type": "long-text",
            "description": "A brief description of the study aims"
          }, {
            "id": "assayTechnologyPlatform",
            "label": "Assay technology platform",
            "type": "text",
            "description": "The technology platform used"
          }, {
            "id": "assayTechnologyType",
            "label": "Assay technology type",
            "type": "text",
            "description": "The technology being employed to observe this measurement"
          }, {
            "id": "protocolType",
            "label": "Protocol type",
            "type": "text",
            "description": "The type of the protocol, preferably coming from an Ontology, e.g. Extraction Protocol"
          }, {
            "id": "title",
            "label": "Study title",
            "type": "long-text",
            "description": "A title for the study"
          }, {
            "id": "protocolDescription",
            "label": "Protocol description",
            "type": "long-text",
            "description": "A description of the protocol"
          }, {
            "id": "protocolParametersName",
            "label": "Parameters names",
            "type": "text",
            "description": "The parameters used when executing this protocol"
          }, {
            "id": "protocolName",
            "label": "Protocol name",
            "type": "text",
            "description": "The name of the protocol, e.g.Extraction Protocol"
          }, {
            "id": "protocolVersion",
            "label": "Protocol version",
            "type": "text",
            "description": "The version of the protocol used, where applicable."
          }, {
            "id": "protocolURI",
            "label": "Protocol URI",
            "type": "text",
            "description": "A URI to link out to a publication, web page, etc. describing the protocol"
          }, {
            "id": "accreditationProcedureForTheAssayTechnology",
            "label": "Accreditation procedure for assay",
            "type": "text",
            "description": "Accreditation procedure for the analytical method used"
          }],
          "laboratory": [{
            "id": "country",
            "label": "Laboratory country",
            "type": "text",
            "description": "Country where the laboratory is placed. (ISO 3166-1-alpha-2)"
          }, {
            "id": "name",
            "label": "Laboratory name",
            "type": "text",
            "description": "Laboratory code (National laboratory code if available) or Laboratory name "
          }, {
            "id": "accreditation",
            "label": "Laboratory accreditation",
            "description": "The laboratory accreditation to ISO/IEC 17025"
          }],
          "assay": [{
            "id": "contaminationRange",
            "label": "Range of contamination",
            "type": "text",
            "description": "Range of result of the analytical measure reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "uncertaintyValue",
            "label": "Uncertainty value",
            "type": "text",
            "description": "Indicate the expanded uncertainty (usually 95% confidence interval) value associated with the measurement expressed in the unit reported in the field Hazard unit"
          }, {
            "id": "fatPercentage",
            "label": "Percentage of fat",
            "type": "text",
            "description": "Percentage of fat in the original sample"
          }, {
            "id": "name",
            "label": "Assay name",
            "type": "text",
            "description": "A name given to the assay"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the assay. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "moisturePercentage",
            "label": "Percentage of moisture",
            "type": "text",
            "description": "Percentage of moisture in the original sample"
          }, {
            "id": "leftCensoredData",
            "label": "Left-censored data",
            "type": "text",
            "description": "Percentage of measures equal to LOQ and/or LOD"
          }, {
            "id": "detectionLimit",
            "label": "Limit of detection",
            "type": "text",
            "description": "Limit of detection reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "quantificationLimit",
            "label": "Limit of quantification",
            "type": "text",
            "description": "Limit of quantification reported in the unit specified by the variable Hazard unit"
          }],
          "dietaryAssessmentMethod": [{
            "id": "recordTypes",
            "label": "Type of records",
            "description": "Consumption occasion, mean of consumption, quantified and described as eaten, recipes for self-made"
          }, {
            "id": "numberOfFoodItems",
            "label": "Number of food items",
            "description": "Number of food items"
          }, {
            "id": "numberOfNonConsecutiveOneDay",
            "label": "Number of non-consecutive one-day",
            "type": "text",
            "description": "Number of non-consecutive one-day recorded"
          }, {
            "id": "softwareTool",
            "label": "Dietary software tool",
            "type": "text",
            "description": "Name of the software used to collect the data"
          }, {
            "id": "foodDescriptors",
            "label": "Food descriptors",
            "description": "Description using FoodEx2 facet"
          }, {
            "id": "collectionTool",
            "label": "Methodological tool to collect data",
            "type": "text",
            "description": "Food diaries, interview, 24-hour recall interview, food propensy questionnaire, portion size measurement aids, eating outside questionnaire"
          }],
          "studySample": [{
            "id": "sampleName",
            "label": "Name",
            "type": "text",
            "description": "An unambiguous ID given to the samples used in the assay"
          }, {
            "id": "samplingWeight",
            "label": "Sampling weight",
            "type": "text",
            "description": "Description of the method employed to compute sampling weight (nonresponse-adjusted weight)"
          }, {
            "id": "protocolOfSampleCollection",
            "label": "Protocol of sample collection",
            "type": "text",
            "description": "Additional protocol for sample and sample collection. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "samplingStrategy",
            "label": "Sampling strategy",
            "type": "text",
            "description": "Sampling strategy (ref. EUROSTAT - Typology of sampling strategy, version of July 2009)"
          }, {
            "id": "samplingSize",
            "label": "Sampling size",
            "type": "text",
            "description": "Number of units, full participants, partial participants, eligibles, not eligible, unresolved (eligibility status not resolved)"
          }, {
            "id": "lotSizeUnit",
            "label": "Lot size unit",
            "type": "text",
            "description": "Unit in which the lot size is expressed"
          }, {
            "id": "samplingPoint",
            "label": "Sampling point",
            "type": "text",
            "description": "Point in the food chain where the sample was taken. (Doc. ESTAT/F5/ES/155 Data dictionary of activities of the establishments)"
          }, {
            "id": "samplingMethod",
            "label": "Sampling method",
            "type": "text",
            "description": "Sampling method used to take the sample"
          }, {
            "id": "typeOfSamplingProgram",
            "label": "Type of sampling program",
            "type": "text",
            "description": "Indicate the type of programm for which the samples have been collected"
          }, {
            "id": "samplingPlan",
            "label": "Sampling plan",
            "type": "text",
            "description": "Description of data collection technique: stratified or complex sampling (several stages)"
          }]
        },
        "modelMath": {
          "modelEquation": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "modelEquation": [{
              "id": "modelEquation",
              "label": "Equation",
              "type": "text",
              "description": "The pointer to the file that holds the software code (e.g. R-script)"
            }, {
              "id": "name",
              "label": "Model equation name",
              "type": "text",
              "description": "A name given to the model equation"
            }, {
              "id": "modelHypothesis",
              "label": "Hypothesis of the model",
              "description": "Description of the hypothesis of the model"
            }, {
              "id": "modelEquationClass",
              "label": "Model equation class",
              "type": "text",
              "description": "Information on that helps to categorize model equations"
            }]
          },
          "parameter": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "parameter": [{
              "id": "subject",
              "label": "Parameter subject",
              "type": "text",
              "description": "Scope of the parameter, e.g. if it refers to an animal, a batch of animals, a batch of products, a carcass, a carcass skin etc"
            }, {
              "id": "maxValue",
              "label": "Value max",
              "type": "text",
              "description": "Numerical value of the maximum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "dataType",
              "label": "Data type",
              "type": "text",
              "description": "Information on the data format of the parameter, e.g. if it is a categorical variable: int, double, array of size x,y,z "
            }, {
              "id": "description",
              "label": "Description",
              "type": "text",
              "description": "General description of the parameter"
            }, {
              "id": "source",
              "label": "Parameter source",
              "type": "text",
              "description": "Information on the type of knowledge used to define the parameter value"
            }, {
              "id": "classification",
              "label": "Parameter classification",
              "type": "text",
              "description": "General classification of the parameter (e.g. Input, Constant, Output etc)"
            }, {
              "id": "distribution",
              "label": "Parameter distribution",
              "type": "text",
              "description": "Distribution describing the parameter variabilty. If no distribution selected this means the value provided in 'Parameter value' is a point estimate. In case a distribution is selected the value provided in 'Parameter value' is a string that the model code can parse in order to sample from the named distribution"
            }, {
              "id": "error",
              "label": "Error",
              "type": "text",
              "description": "Error of the parameter value"
            }, {
              "id": "variabilitySubject",
              "label": "Parameter variability subject",
              "type": "text",
              "description": "Information on which the variability is described. It can be variability between broiler in a flock, variability between all meat packages sold in Denmark, variability between days, etc."
            }, {
              "id": "unit",
              "label": "Unit",
              "type": "text",
              "description": "Unit of the parameter"
            }, {
              "id": "minValue",
              "label": "Value min",
              "type": "text",
              "description": "Numerical value of the minimum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "unitCategory",
              "label": "Unit category",
              "type": "text",
              "description": "General classification of the parameter unit"
            }, {
              "id": "name",
              "label": "Parameter name",
              "type": "text",
              "description": "A name given to the parameter"
            }, {
              "id": "id",
              "label": "Parameter ID",
              "type": "text",
              "description": "An unambiguous ID given to each of the parameters - preferably autogenerated by a software tool and compatible with SBML ID requirements, only letters from A to Z, numbers and '_'"
            }, {
              "id": "value",
              "label": "Value",
              "type": "text",
              "description": "A default value for the parameter. This is mandatory (needs to be provided) for all parameters of type 'Input'"
            }]
          },
          "qualityMeasures": [{
            "id": "rsquared",
            "label": "R squared",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sse",
            "label": "SSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "rmse",
            "label": "RMSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "aic",
            "label": "AIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sensitivityAnalysis",
            "label": "Sensitivity analysis",
            "type": "long-text",
            "description": "Description of the results of an sensitivity analysis, i.e. how independence assumptions are met or how variables will affect the output of model"
          }, {
            "id": "bic",
            "label": "BIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "mse",
            "label": "MSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }],
          "modelMath": [{
            "id": "fittingProcedure",
            "label": "Fitting procedure",
            "type": "text",
            "description": "Procedure used to fit the data to the model equation"
          }, {
            "id": "event",
            "label": "Event",
            "description": "Definition of time-dependent parameter changes"
          }]
        },
        "scope": {
          "product": [{
            "id": "expiryDate",
            "label": "Expiration date",
            "type": "date",
            "description": "Expiry date of food/product"
          }, {
            "id": "treatment",
            "label": "Treatment",
            "description": "Used to characterise a product/matrix based on the treatment or processes applied to the product or any indexed ingredient"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the product, matrix or environment for which the model or data applies"
          }, {
            "id": "productionDate",
            "label": "Production date",
            "type": "date",
            "description": "Date of production of food/product"
          }, {
            "id": "method",
            "label": "Method of production",
            "description": "Type of production for the product/ matrix"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "The product, matrix or environment (e.g food product, lab media, soil etc.) for which the model or data applies"
          }, {
            "id": "originCountry",
            "label": "Country of origin",
            "type": "text",
            "description": "Country of origin of the food/product (ISO 3166-1-alpha-2 country code)"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Detailed description of the product, matrix or environment for which the model or data applies"
          }, {
            "id": "packaging",
            "label": "Packaging",
            "description": "Describe container or wrapper that holds the product/matrix. Common type of packaging (paper or plastic bags, boxes, tinplate or aluminium cans, plastic trays, plastic bottles, glass bottles or jars)"
          }, {
            "id": "fisheriesArea",
            "label": "Fisheries area",
            "type": "text",
            "description": "Fisheries or aquaculture area specifying the origin of the sample (FAO Fisheries areas)."
          }, {
            "id": "originArea",
            "label": "Area of origin",
            "type": "text",
            "description": "Area of origin of the food/product (Nomenclature of territorial units for statistics  NUTS  coding system valid only for EEA and Switzerland)."
          }],
          "populationGroup": [{
            "id": "populationRiskFactor",
            "label": "Risk and population factors",
            "description": "Population risk factor that may influence the outcomes of the study, confounder should be included"
          }, {
            "id": "country",
            "label": "Country",
            "description": "Country on which the population group of the model or data applies"
          }, {
            "id": "populationSpan",
            "label": "Population span (years)",
            "description": "Temporal information on the exposure duration"
          }, {
            "id": "populationGender",
            "label": "Population gender",
            "type": "text",
            "description": "Description of the percentage of gender"
          }, {
            "id": "populationDescription",
            "label": "Description",
            "description": "Description of the population for which the model applies (demographic and socio-economic characteristics for example). Background information that are needed in the data analysis phase, size of household, education level, employment status, professional category, ethnicity, etc."
          }, {
            "id": "populationAge",
            "label": "Population age",
            "description": "Description of the range of age or group of age"
          }, {
            "id": "patternConsumption",
            "label": "Consumption pattern",
            "description": "Description of the consumption of different food items, frequency, portion size"
          }, {
            "id": "name",
            "label": "Population name",
            "type": "text",
            "description": "Name of the population for which the model or data applies"
          }, {
            "id": "season",
            "label": "Season",
            "description": "Distribution of surveyed people according to the season (influence consumption pattern)"
          }, {
            "id": "region",
            "label": "Region",
            "description": "Spatial information (area) on which the population group of the model or data applies"
          }, {
            "id": "targetPopulation",
            "label": "Target population",
            "type": "text",
            "description": "Population of individual that we are interested in describing and making statistical inferences about"
          }, {
            "id": "bmi",
            "label": "BMI",
            "description": "Description of the range of BMI or class of BMI or BMI mean"
          }, {
            "id": "specialDietGroups",
            "label": "Special diet groups",
            "description": "Description of sub-population with special diets (vegetarians, diabetics, group following special ethnic diets)"
          }],
          "scope": [{
            "id": "spatialInformation",
            "label": "Spatial information",
            "description": "Spatial information (area) on which the model or data applies"
          }, {
            "id": "generalComment",
            "label": "General comment",
            "type": "long-text",
            "description": "General comments on the scope of the study, data or model"
          }, {
            "id": "temporalInformation",
            "label": "Temporal information",
            "type": "long-text",
            "description": "Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)"
          }]
        },
        "generalInformation": {
          "creator": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "author": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "reference": [{
            "id": "date",
            "label": "Date",
            "type": "year_date",
            "description": "Temporal information on the publication date"
          }, {
            "id": "website",
            "label": "Website",
            "type": "text",
            "description": "A link to the publication website (different from DOI)"
          }, {
            "id": "issue",
            "label": "Issue",
            "type": "text",
            "description": "Data on the details of the issue in which the model or date has been described"
          }, {
            "id": "publicationType",
            "label": "Publication type",
            "type": "text",
            "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
          }, {
            "id": "abstract",
            "label": "Abstract",
            "type": "text",
            "description": "Abstract of the publication in which the model or the data has been described "
          }, {
            "id": "isReferenceDescription",
            "label": "Is_reference_description?",
            "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
          }, {
            "id": "title",
            "label": "Title",
            "type": "long-text",
            "description": "Title of publication in which the model or date has been described"
          }, {
            "id": "pmid",
            "label": "PubMed ID",
            "type": "text",
            "description": "The PubMed ID related to this publication"
          }, {
            "id": "volume",
            "label": "Volume",
            "type": "text",
            "description": "Data on the details of the volume in which the model or date has been described"
          }, {
            "id": "journal",
            "label": "Journal",
            "type": "long-text",
            "description": "Data on the details of the journal in which the model or date has been described"
          }, {
            "id": "authorList",
            "label": "Author list",
            "type": "long-text",
            "description": "Name and surname of the authors who contributed to this publication"
          }, {
            "id": "comment",
            "label": "Comment",
            "type": "long-text",
            "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
          }, {
            "id": "doi",
            "label": "Publication DOI",
            "type": "long-text",
            "description": "The DOI related to this publication"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The status of this publication, e.g. Published, Submitted, etc."
          }],
          "modelCategory": [{
            "id": "modelClassComment",
            "label": "Comment",
            "type": "long-text",
            "description": "Comment with further details on the model class"
          }, {
            "id": "basicProcess",
            "label": "Basic process",
            "description": "Defines the impact of the process on the hazard (so far only valid for process models and predictive models)"
          }, {
            "id": "modelClass",
            "label": "Model class",
            "type": "text",
            "description": "Type of model according to RAKIP classification"
          }, {
            "id": "modelSubClass",
            "label": "Subclass",
            "description": "Sub-classification of the model given the Model Class"
          }],
          "generalInformation": [{
            "id": "identifier",
            "label": "Identifier",
            "type": "text",
            "description": "An unambiguous ID given to the model or data. This can also be created automatically by a software tool"
          }, {
            "id": "software",
            "label": "Software",
            "type": "text",
            "description": "The program or software language in which the model has been implemented"
          }, {
            "id": "format",
            "label": "Format",
            "type": "text",
            "description": "File extension of the model or data file (including version number of format if applicable)"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the study, data or model"
          }, {
            "id": "language",
            "label": "Language",
            "type": "text",
            "description": "A language of the resource (some data or reports can be available in French language for example)"
          }, {
            "id": "source",
            "label": "Source",
            "type": "text",
            "description": "A source from which the model/data is derived"
          }, {
            "id": "availability",
            "label": "Availability",
            "type": "text",
            "description": "Availability of data or model, i.e. if the annotated model code / data is included in this FSK file"
          }, {
            "id": "creationDate",
            "label": "Creation date",
            "type": "date",
            "description": "Creation date/time of the FSK file"
          }, {
            "id": "url",
            "label": "URL",
            "type": "text",
            "description": "Web address referencing the resource location (data for example)"
          }, {
            "id": "objective",
            "label": "Objective",
            "type": "long-text",
            "description": "Objective of the model or data"
          }, {
            "id": "modificationDate",
            "label": "Modification date",
            "description": "Date/time of the last version of the FSK file"
          }, {
            "id": "rights",
            "label": "Rights",
            "type": "text",
            "description": "Rights granted for usage, distribution and modification of this FSK file"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "A name given to the model or data"
          }, {
            "id": "languageWrittenIn",
            "label": "Language written in",
            "type": "text",
            "description": "Software language used to write the model, e.g. R or MatLab"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The curation status of the model"
          }]
        }
      };
    }
    // Validate this.panels and return boolean
  }, {
    key: "validate",
    value: function validate() {
      var isValid = true;
      if (!this.panels.generalInformation.validate()) isValid = false;
      if (!this.panels.modelCategory.validate()) isValid = false;
      if (!this.panels.scopeGeneral.validate()) isValid = false;
      if (!this.panels.study.validate()) isValid = false;
      return isValid;
    }
  }, {
    key: "_createPanels",
    value: function _createPanels() {
      var port = window.port || -1;
      var schema = schemas.genericModel;
      return _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
        study: new _FormPanel.FormPanel("Study", this.jsonSchema.dataBackground.study, this._metadata.dataBackground ? this._metadata.dataBackground.study : {}, port),
        laboratory: new _TablePanel.TablePanel("Laboratory", this.jsonSchema.dataBackground.laboratory, this._metadata.dataBackground ? this._metadata.dataBackground.laboratory : {}, port),
        assay: new _TablePanel.TablePanel("Assay", this.jsonSchema.dataBackground.assay, this._metadata.dataBackground ? this._metadata.dataBackground.assay : {}, port),
        dietaryAssessmentMethod: new _TablePanel.TablePanel("Dietary Assessment Method", this.jsonSchema.dataBackground.dietaryAssessmentMethod, this._metadata.dataBackground ? this._metadata.dataBackground.dietaryAssessmentMethod : {}, port),
        studySample: new _TablePanel.TablePanel("Study Sample", this.jsonSchema.dataBackground.studySample, this._metadata.dataBackground ? this._metadata.dataBackground.studySample : {}, port),
        modelMath: new _FormPanel.FormPanel("Model Math", this.jsonSchema.modelMath.modelMath, this._metadata.modelMath, port),
        modelEquation: new _TablePanel.TablePanel("Model Equation", this.jsonSchema.modelMath.modelEquation.modelEquation, this._metadata.modelMath ? this._metadata.modelMath.modelEquation : {}, port),
        reference: new _TablePanel.TablePanel("Reference", this.jsonSchema.modelMath.modelEquation.reference, this._metadata.modelMath.modelEquation ? this._metadata.modelMath.modelEquation.reference : {}, port),
        parameter: new _TablePanel.TablePanel("Parameter", this.jsonSchema.modelMath.parameter.parameter, this._metadata.modelMath ? this._metadata.modelMath.parameter : {}, port)
      }, "reference", new _FormPanel.FormPanel("Reference", this.jsonSchema.modelMath.parameter.reference, this._metadata.modelMath.parameter ? this._metadata.modelMath.parameter.reference : {}, port)), "qualityMeasures", new _TablePanel.TablePanel("Quality Measures", this.jsonSchema.modelMath.qualityMeasures, this._metadata.modelMath ? this._metadata.modelMath.qualityMeasures : {}, port)), "scope", new _FormPanel.FormPanel("Scope", this.jsonSchema.scope.scope, this._metadata.scope, port)), "product", new _TablePanel.TablePanel("Product", this.jsonSchema.scope.product, this._metadata.scope ? this._metadata.scope.product : {}, port)), "populationGroup", new _TablePanel.TablePanel("Population Group", this.jsonSchema.scope.populationGroup, this._metadata.scope ? this._metadata.scope.populationGroup : {}, port)), "generalInformation", new _FormPanel.FormPanel("General Information", this.jsonSchema.generalInformation.generalInformation, this._metadata.generalInformation, port)), "creator", new _TablePanel.TablePanel("Creator", this.jsonSchema.generalInformation.creator, this._metadata.generalInformation ? this._metadata.generalInformation.creator : {}, port)), "author", new _TablePanel.TablePanel("Author", this.jsonSchema.generalInformation.author, this._metadata.generalInformation ? this._metadata.generalInformation.author : {}, port)), "reference", new _TablePanel.TablePanel("Reference", this.jsonSchema.generalInformation.reference, this._metadata.generalInformation ? this._metadata.generalInformation.reference : {}, port)), "modelCategory", new _FormPanel.FormPanel("Model Category", this.jsonSchema.generalInformation.modelCategory, this._metadata.generalInformation ? this._metadata.generalInformation.modelCategory : {}, port));
    }
  }]);
}(_ModelView2.ModelView);

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./ConsumptionModelScopeView":69,"./GenericModelDataBackgroundView":97,"./ModelView":118,"./PredictiveModelGeneralInformationView":137,"./PredictiveModelModelMathView":139}],71:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Contact = void 0;
var _ApiClient = require("../ApiClient");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Contact model module.
 * @module model/Contact
 * @version 1.0.0
 */
var Contact = exports.Contact = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>Contact</code>.
   * Object defined according to vCard standard 4.0
   * @alias module:model/Contact
   * @class
   * @param email {} The address for electronic mail communication.
   */
  function Contact(email) {
    _classCallCheck(this, Contact);
    this.email = email;
  }

  /**
   * Constructs a <code>Contact</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/Contact} obj Optional instance to populate.
   * @return {module:model/Contact} The populated <code>Contact</code> instance.
   */
  return _createClass(Contact, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new Contact();
        if (data.hasOwnProperty('country')) obj.country = _ApiClient.ApiClient.convertToType(data['country'], 'String');
        if (data.hasOwnProperty('zipCode')) obj.zipCode = _ApiClient.ApiClient.convertToType(data['zipCode'], 'String');
        if (data.hasOwnProperty('note')) obj.note = _ApiClient.ApiClient.convertToType(data['note'], 'String');
        if (data.hasOwnProperty('gender')) obj.gender = _ApiClient.ApiClient.convertToType(data['gender'], 'String');
        if (data.hasOwnProperty('givenName')) obj.givenName = _ApiClient.ApiClient.convertToType(data['givenName'], 'String');
        if (data.hasOwnProperty('timeZone')) obj.timeZone = _ApiClient.ApiClient.convertToType(data['timeZone'], 'String');
        if (data.hasOwnProperty('telephone')) obj.telephone = _ApiClient.ApiClient.convertToType(data['telephone'], 'String');
        if (data.hasOwnProperty('title')) obj.title = _ApiClient.ApiClient.convertToType(data['title'], 'String');
        if (data.hasOwnProperty('streetAddress')) obj.streetAddress = _ApiClient.ApiClient.convertToType(data['streetAddress'], 'String');
        if (data.hasOwnProperty('familyName')) obj.familyName = _ApiClient.ApiClient.convertToType(data['familyName'], 'String');
        if (data.hasOwnProperty('organization')) obj.organization = _ApiClient.ApiClient.convertToType(data['organization'], 'String');
        if (data.hasOwnProperty('region')) obj.region = _ApiClient.ApiClient.convertToType(data['region'], 'String');
        if (data.hasOwnProperty('email')) obj.email = _ApiClient.ApiClient.convertToType(data['email'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * Full name of the country in English
 * @member {String} country
 */
Contact.prototype.country = undefined;

/**
 * Postal code
 * @member {String} zipCode
 */
Contact.prototype.zipCode = undefined;

/**
 * Supplemental information or a comment
 * @member {String} note
 */
Contact.prototype.note = undefined;

/**
 * Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)
 * @member {String} gender
 */
Contact.prototype.gender = undefined;

/**
 * Given name
 * @member {String} givenName
 */
Contact.prototype.givenName = undefined;

/**
 * Time zone
 * @member {String} timeZone
 */
Contact.prototype.timeZone = undefined;

/**
 * The canonical number string for a telephone number for telephony communication.
 * @member {String} telephone
 */
Contact.prototype.telephone = undefined;

/**
 * Specifies the job title, functional position or function of the individual associated.
 * @member {String} title
 */
Contact.prototype.title = undefined;

/**
 * Physical delivery address
 * @member {String} streetAddress
 */
Contact.prototype.streetAddress = undefined;

/**
 * Family name or surname.
 * @member {String} familyName
 */
Contact.prototype.familyName = undefined;

/**
 * Organization information
 * @member {String} organization
 */
Contact.prototype.organization = undefined;

/**
 * State or province
 * @member {String} region
 */
Contact.prototype.region = undefined;

/**
 * The address for electronic mail communication.
 * @member {String} email
 */
Contact.prototype.email = undefined;

},{"../ApiClient":44}],72:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContactView = void 0;
var _ApiClient = require("../ApiClient");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Contact View  module.
 * @module model/Contact
 * @version 1.0.0
 */
var ContactView = exports.ContactView = /*#__PURE__*/_createClass(function ContactView() {
  _classCallCheck(this, ContactView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63}],73:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataModel = void 0;
var _ApiClient = require("../ApiClient");
var _DataModelGeneralInformation = require("./DataModelGeneralInformation");
var _DataModelModelMath = require("./DataModelModelMath");
var _GenericModelDataBackground = require("./GenericModelDataBackground");
var _GenericModelScope = require("./GenericModelScope");
var _Model2 = require("./Model");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The DataModel model module.
 * @module model/DataModel
 * @version 1.0.0
 */
var DataModel = exports.DataModel = /*#__PURE__*/function (_Model) {
  /**
   * Constructs a new <code>DataModel</code>.
   * @alias module:model/DataModel
   * @class
   * @extends module:model/Model
   * @param modelType {} 
   */
  function DataModel(modelType) {
    _classCallCheck(this, DataModel);
    return _callSuper(this, DataModel, [modelType]);
  }

  /**
   * Constructs a <code>DataModel</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/DataModel} obj Optional instance to populate.
   * @return {module:model/DataModel} The populated <code>DataModel</code> instance.
   */
  _inherits(DataModel, _Model);
  return _createClass(DataModel, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new DataModel();
        _Model2.Model.constructFromObject(data, obj);
        if (data.hasOwnProperty('dataBackground')) obj.dataBackground = _GenericModelDataBackground.GenericModelDataBackground.constructFromObject(data['dataBackground']);
        if (data.hasOwnProperty('modelMath')) obj.modelMath = _DataModelModelMath.DataModelModelMath.constructFromObject(data['modelMath']);
        if (data.hasOwnProperty('scope')) obj.scope = _GenericModelScope.GenericModelScope.constructFromObject(data['scope']);
        if (data.hasOwnProperty('generalInformation')) obj.generalInformation = _DataModelGeneralInformation.DataModelGeneralInformation.constructFromObject(data['generalInformation']);
      }
      return obj;
    }
  }]);
}(_Model2.Model);
/**
 * @member {module:model/GenericModelDataBackground} dataBackground
 */
DataModel.prototype.dataBackground = undefined;

/**
 * @member {module:model/DataModelModelMath} modelMath
 */
DataModel.prototype.modelMath = undefined;

/**
 * @member {module:model/GenericModelScope} scope
 */
DataModel.prototype.scope = undefined;

/**
 * @member {module:model/DataModelGeneralInformation} generalInformation
 */
DataModel.prototype.generalInformation = undefined;

},{"../ApiClient":44,"./DataModelGeneralInformation":74,"./DataModelModelMath":76,"./GenericModelDataBackground":96,"./GenericModelScope":102,"./Model":113}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataModelGeneralInformation = void 0;
var _ApiClient = require("../ApiClient");
var _Contact = require("./Contact");
var _Reference = require("./Reference");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The DataModelGeneralInformation model module.
 * @module model/DataModelGeneralInformation
 * @version 1.0.0
 */
var DataModelGeneralInformation = exports.DataModelGeneralInformation = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>DataModelGeneralInformation</code>.
   * @alias module:model/DataModelGeneralInformation
   * @class
   * @param identifier {} An unambiguous ID given to the model or data. This can also be created automatically by a software tool
   * @param creationDate {} Creation date/time of the FSK file
   * @param rights {} Rights granted for usage, distribution and modification of this FSK file
   * @param name {} A name given to the data
   */
  function DataModelGeneralInformation(identifiercreationDaterightsname) {
    _classCallCheck(this, DataModelGeneralInformation);
    this.identifier = identifier;
    this.creationDate = creationDate;
    this.rights = rights;
    this.name = name;
  }

  /**
   * Constructs a <code>DataModelGeneralInformation</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/DataModelGeneralInformation} obj Optional instance to populate.
   * @return {module:model/DataModelGeneralInformation} The populated <code>DataModelGeneralInformation</code> instance.
   */
  return _createClass(DataModelGeneralInformation, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new DataModelGeneralInformation();
        if (data.hasOwnProperty('identifier')) obj.identifier = _ApiClient.ApiClient.convertToType(data['identifier'], 'String');
        if (data.hasOwnProperty('creator')) obj.creator = _ApiClient.ApiClient.convertToType(data['creator'], [_Contact.Contact]);
        if (data.hasOwnProperty('author')) obj.author = _ApiClient.ApiClient.convertToType(data['author'], [_Contact.Contact]);
        if (data.hasOwnProperty('format')) obj.format = _ApiClient.ApiClient.convertToType(data['format'], 'String');
        if (data.hasOwnProperty('description')) obj.description = _ApiClient.ApiClient.convertToType(data['description'], 'String');
        if (data.hasOwnProperty('language')) obj.language = _ApiClient.ApiClient.convertToType(data['language'], 'String');
        if (data.hasOwnProperty('source')) obj.source = _ApiClient.ApiClient.convertToType(data['source'], 'String');
        if (data.hasOwnProperty('availability')) obj.availability = _ApiClient.ApiClient.convertToType(data['availability'], 'String');
        if (data.hasOwnProperty('creationDate')) obj.creationDate = _ApiClient.ApiClient.convertToType(data['creationDate'], 'Date');
        if (data.hasOwnProperty('url')) obj.url = _ApiClient.ApiClient.convertToType(data['url'], 'String');
        if (data.hasOwnProperty('objective')) obj.objective = _ApiClient.ApiClient.convertToType(data['objective'], 'String');
        if (data.hasOwnProperty('reference')) obj.reference = _ApiClient.ApiClient.convertToType(data['reference'], [_Reference.Reference]);
        if (data.hasOwnProperty('modificationDate')) obj.modificationDate = _ApiClient.ApiClient.convertToType(data['modificationDate'], ['Date']);
        if (data.hasOwnProperty('rights')) obj.rights = _ApiClient.ApiClient.convertToType(data['rights'], 'String');
        if (data.hasOwnProperty('name')) obj.name = _ApiClient.ApiClient.convertToType(data['name'], 'String');
        if (data.hasOwnProperty('status')) obj.status = _ApiClient.ApiClient.convertToType(data['status'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * An unambiguous ID given to the model or data. This can also be created automatically by a software tool
 * @member {String} identifier
 */
DataModelGeneralInformation.prototype.identifier = undefined;

/**
 * The person(s) that created this FSK file including all metadata
 * @member {Array.<module:model/Contact>} creator
 */
DataModelGeneralInformation.prototype.creator = undefined;

/**
 * Person(s) who generated the model code or generated the data set originally
 * @member {Array.<module:model/Contact>} author
 */
DataModelGeneralInformation.prototype.author = undefined;

/**
 * File extension of the model or data file (including version number of format if applicable)
 * @member {String} format
 */
DataModelGeneralInformation.prototype.format = undefined;

/**
 * General description of the study, data or model
 * @member {String} description
 */
DataModelGeneralInformation.prototype.description = undefined;

/**
 * A language of the resource (some data or reports can be available in French language for example)
 * @member {String} language
 */
DataModelGeneralInformation.prototype.language = undefined;

/**
 * A source from which the resource is derived
 * @member {String} source
 */
DataModelGeneralInformation.prototype.source = undefined;

/**
 * Availability of data or model, i.e. if the annotated model code / data is included in this FSK file
 * @member {String} availability
 */
DataModelGeneralInformation.prototype.availability = undefined;

/**
 * Creation date/time of the FSK file
 * @member {Date} creationDate
 */
DataModelGeneralInformation.prototype.creationDate = undefined;

/**
 * Web address referencing the resource location (data for example)
 * @member {String} url
 */
DataModelGeneralInformation.prototype.url = undefined;

/**
 * Objective of the model or data
 * @member {String} objective
 */
DataModelGeneralInformation.prototype.objective = undefined;

/**
 * @member {Array.<module:model/Reference>} reference
 */
DataModelGeneralInformation.prototype.reference = undefined;

/**
 * Date/time of the last version of the FSK file
 * @member {Array.<Date>} modificationDate
 */
DataModelGeneralInformation.prototype.modificationDate = undefined;

/**
 * Rights granted for usage, distribution and modification of this FSK file
 * @member {String} rights
 */
DataModelGeneralInformation.prototype.rights = undefined;

/**
 * A name given to the data
 * @member {String} name
 */
DataModelGeneralInformation.prototype.name = undefined;

/**
 * The status of the resource
 * @member {String} status
 */
DataModelGeneralInformation.prototype.status = undefined;

},{"../ApiClient":44,"./Contact":71,"./Reference":155}],75:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataModelGeneralInformationView = void 0;
var _ApiClient = require("../ApiClient");
var _ContactView = require("./ContactView");
var _ReferenceView = require("./ReferenceView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The DataModelGeneralInformation View  module.
 * @module model/DataModelGeneralInformation
 * @version 1.0.0
 */
var DataModelGeneralInformationView = exports.DataModelGeneralInformationView = /*#__PURE__*/_createClass(function DataModelGeneralInformationView() {
  _classCallCheck(this, DataModelGeneralInformationView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./ContactView":72,"./ReferenceView":156}],76:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataModelModelMath = void 0;
var _ApiClient = require("../ApiClient");
var _Parameter = require("./Parameter");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The DataModelModelMath model module.
 * @module model/DataModelModelMath
 * @version 1.0.0
 */
var DataModelModelMath = exports.DataModelModelMath = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>DataModelModelMath</code>.
   * @alias module:model/DataModelModelMath
   * @class
   * @param parameter {} 
   */
  function DataModelModelMath(parameter) {
    _classCallCheck(this, DataModelModelMath);
    this.parameter = parameter;
  }

  /**
   * Constructs a <code>DataModelModelMath</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/DataModelModelMath} obj Optional instance to populate.
   * @return {module:model/DataModelModelMath} The populated <code>DataModelModelMath</code> instance.
   */
  return _createClass(DataModelModelMath, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new DataModelModelMath();
        if (data.hasOwnProperty('parameter')) obj.parameter = _ApiClient.ApiClient.convertToType(data['parameter'], [_Parameter.Parameter]);
      }
      return obj;
    }
  }]);
}();
/**
 * @member {Array.<module:model/Parameter>} parameter
 */
DataModelModelMath.prototype.parameter = undefined;

},{"../ApiClient":44,"./Parameter":129}],77:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataModelModelMathView = void 0;
var _ApiClient = require("../ApiClient");
var _ParameterView = require("./ParameterView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The DataModelModelMath View  module.
 * @module model/DataModelModelMath
 * @version 1.0.0
 */
var DataModelModelMathView = exports.DataModelModelMathView = /*#__PURE__*/_createClass(function DataModelModelMathView() {
  _classCallCheck(this, DataModelModelMathView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./ParameterView":130}],78:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataModelView = void 0;
var _ApiClient = require("../ApiClient");
var _DataModelGeneralInformationView = require("./DataModelGeneralInformationView");
var _DataModelModelMathView = require("./DataModelModelMathView");
var _GenericModelDataBackgroundView = require("./GenericModelDataBackgroundView");
var _GenericModelScopeView = require("./GenericModelScopeView");
var _ModelView2 = require("./ModelView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The DataModel View  module.
 * @module model/DataModel
 * @version 1.0.0
 */
var DataModelView = exports.DataModelView = /*#__PURE__*/function (_ModelView) {
  function DataModelView(metadata, img, state, modelScript, visScript, readme) {
    var _this;
    _classCallCheck(this, DataModelView);
    _this = _callSuper(this, DataModelView, [metadata, img, modelScript, visScript, readme]);
    _this._schema = schemas.genericModel;
    if (state) {
      _this.panels = _this._createPanels();
    }
    _this._menu = [{
      "label": "General Information",
      "id": "generalInformation",
      "submenus": [{
        "label": "General Information",
        "id": "generalInformation"
      }, {
        "label": "Reference",
        "id": "reference"
      }, {
        "label": "Author",
        "id": "author"
      }, {
        "label": "Creator",
        "id": "creator"
      }]
    }, {
      "label": "Scope",
      "id": "scope",
      "submenus": [{
        "label": "Scope",
        "id": "scope"
      }, {
        "label": "Hazard",
        "id": "hazard"
      }, {
        "label": "Population Group",
        "id": "populationGroup"
      }, {
        "label": "Product",
        "id": "product"
      }]
    }, {
      "label": "Model Math",
      "id": "modelMath",
      "submenus": [{
        "label": "Parameter",
        "id": "parameter",
        "submenus": [{
          "label": "Parameter",
          "id": "parameter"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }]
    }, {
      "label": "Data Background",
      "id": "dataBackground",
      "submenus": [{
        "label": "Study Sample",
        "id": "studySample"
      }, {
        "label": "Dietary Assessment Method",
        "id": "dietaryAssessmentMethod"
      }, {
        "label": "Assay",
        "id": "assay"
      }, {
        "label": "Laboratory",
        "id": "laboratory"
      }, {
        "label": "Study",
        "id": "study"
      }]
    }];
    _this._panels = _defineProperty({
      study: {
        type: 'simple',
        schema: _this.jsonSchema.dataBackgroundstudy,
        metadata: _this._metadata.study
      },
      laboratory: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundlaboratory,
        metadata: _this._metadata.laboratory
      },
      assay: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundassay,
        metadata: _this._metadata.assay
      },
      dietaryAssessmentMethod: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgrounddietaryAssessmentMethod,
        metadata: _this._metadata.dietaryAssessmentMethod
      },
      studySample: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundstudySample,
        metadata: _this._metadata.studySample
      },
      parameter: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.parameterparameter,
        metadata: _this._metadata.parameter
      },
      reference: {
        type: 'simple',
        schema: _this.jsonSchema.modelMath.parameterreference,
        metadata: _this._metadata.reference
      },
      scope: {
        type: 'simple',
        schema: _this.jsonSchema.scopescope,
        metadata: _this._metadata.scope
      },
      product: {
        type: 'complex',
        schema: _this.jsonSchema.scopeproduct,
        metadata: _this._metadata.product
      },
      populationGroup: {
        type: 'complex',
        schema: _this.jsonSchema.scopepopulationGroup,
        metadata: _this._metadata.populationGroup
      },
      hazard: {
        type: 'complex',
        schema: _this.jsonSchema.scopehazard,
        metadata: _this._metadata.hazard
      },
      generalInformation: {
        type: 'simple',
        schema: _this.jsonSchema.generalInformationgeneralInformation,
        metadata: _this._metadata.generalInformation
      },
      creator: {
        type: 'complex',
        schema: _this.jsonSchema.generalInformationcreator,
        metadata: _this._metadata.creator
      },
      author: {
        type: 'complex',
        schema: _this.jsonSchema.generalInformationauthor,
        metadata: _this._metadata.author
      }
    }, "reference", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationreference,
      metadata: _this._metadata.reference
    });
    return _this;
  }
  _inherits(DataModelView, _ModelView);
  return _createClass(DataModelView, [{
    key: "metaData",
    get: function get() {
      try {
        this._metadata.dataBackground.study = this.panels.study.data;
        this._metadata.dataBackground.laboratory = this.panels.laboratory.data;
        this._metadata.dataBackground.assay = this.panels.assay.data;
        this._metadata.dataBackground.dietaryAssessmentMethod = this.panels.dietaryAssessmentMethod.data;
        this._metadata.dataBackground.studySample = this.panels.studySample.data;
        this._metadata.modelMath.parameter = this.panels.parameter.data;
        this._metadata.modelMath.parameter.reference = this.panels.reference.data;
        this._metadata.scope = this.panels.scope.data;
        this._metadata.scope.product = this.panels.product.data;
        this._metadata.scope.populationGroup = this.panels.populationGroup.data;
        this._metadata.scope.hazard = this.panels.hazard.data;
        this._metadata.generalInformation = this.panels.generalInformation.data;
        this._metadata.generalInformation.creator = this.panels.creator.data;
        this._metadata.generalInformation.author = this.panels.author.data;
        this._metadata.generalInformation.reference = this.panels.reference.data;
        this._metadata.modelType = "DataModel";
        this._metadata = metadataFix(this._metadata);
      } catch (error) {
        console.log(error);
      }
      return this._metadata;
    }
  }, {
    key: "jsonSchema",
    get: function get() {
      return {
        "dataBackground": {
          "study": [{
            "id": "identifier",
            "label": "Study identifier",
            "type": "text",
            "description": "A user defined identifier for the study"
          }, {
            "id": "protocolComponentsName",
            "label": "Components names",
            "type": "text",
            "description": "The names of the components used when carrying out this protocol"
          }, {
            "id": "designType",
            "label": "Design type",
            "type": "text",
            "description": "The type of study design being employed"
          }, {
            "id": "assayMeasurementType",
            "label": "Assay measurement type",
            "type": "text",
            "description": "The measurement being observed in this assay"
          }, {
            "id": "protocolComponentsType",
            "label": "Protocol components type",
            "type": "text",
            "description": "Description"
          }, {
            "id": "description",
            "label": "Study description",
            "type": "long-text",
            "description": "A brief description of the study aims"
          }, {
            "id": "assayTechnologyPlatform",
            "label": "Assay technology platform",
            "type": "text",
            "description": "The technology platform used"
          }, {
            "id": "assayTechnologyType",
            "label": "Assay technology type",
            "type": "text",
            "description": "The technology being employed to observe this measurement"
          }, {
            "id": "protocolType",
            "label": "Protocol type",
            "type": "text",
            "description": "The type of the protocol, preferably coming from an Ontology, e.g. Extraction Protocol"
          }, {
            "id": "title",
            "label": "Study title",
            "type": "long-text",
            "description": "A title for the study"
          }, {
            "id": "protocolDescription",
            "label": "Protocol description",
            "type": "long-text",
            "description": "A description of the protocol"
          }, {
            "id": "protocolParametersName",
            "label": "Parameters names",
            "type": "text",
            "description": "The parameters used when executing this protocol"
          }, {
            "id": "protocolName",
            "label": "Protocol name",
            "type": "text",
            "description": "The name of the protocol, e.g.Extraction Protocol"
          }, {
            "id": "protocolVersion",
            "label": "Protocol version",
            "type": "text",
            "description": "The version of the protocol used, where applicable."
          }, {
            "id": "protocolURI",
            "label": "Protocol URI",
            "type": "text",
            "description": "A URI to link out to a publication, web page, etc. describing the protocol"
          }, {
            "id": "accreditationProcedureForTheAssayTechnology",
            "label": "Accreditation procedure for assay",
            "type": "text",
            "description": "Accreditation procedure for the analytical method used"
          }],
          "laboratory": [{
            "id": "country",
            "label": "Laboratory country",
            "type": "text",
            "description": "Country where the laboratory is placed. (ISO 3166-1-alpha-2)"
          }, {
            "id": "name",
            "label": "Laboratory name",
            "type": "text",
            "description": "Laboratory code (National laboratory code if available) or Laboratory name "
          }, {
            "id": "accreditation",
            "label": "Laboratory accreditation",
            "description": "The laboratory accreditation to ISO/IEC 17025"
          }],
          "assay": [{
            "id": "contaminationRange",
            "label": "Range of contamination",
            "type": "text",
            "description": "Range of result of the analytical measure reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "uncertaintyValue",
            "label": "Uncertainty value",
            "type": "text",
            "description": "Indicate the expanded uncertainty (usually 95% confidence interval) value associated with the measurement expressed in the unit reported in the field Hazard unit"
          }, {
            "id": "fatPercentage",
            "label": "Percentage of fat",
            "type": "text",
            "description": "Percentage of fat in the original sample"
          }, {
            "id": "name",
            "label": "Assay name",
            "type": "text",
            "description": "A name given to the assay"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the assay. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "moisturePercentage",
            "label": "Percentage of moisture",
            "type": "text",
            "description": "Percentage of moisture in the original sample"
          }, {
            "id": "leftCensoredData",
            "label": "Left-censored data",
            "type": "text",
            "description": "Percentage of measures equal to LOQ and/or LOD"
          }, {
            "id": "detectionLimit",
            "label": "Limit of detection",
            "type": "text",
            "description": "Limit of detection reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "quantificationLimit",
            "label": "Limit of quantification",
            "type": "text",
            "description": "Limit of quantification reported in the unit specified by the variable Hazard unit"
          }],
          "dietaryAssessmentMethod": [{
            "id": "recordTypes",
            "label": "Type of records",
            "description": "Consumption occasion, mean of consumption, quantified and described as eaten, recipes for self-made"
          }, {
            "id": "numberOfFoodItems",
            "label": "Number of food items",
            "description": "Number of food items"
          }, {
            "id": "numberOfNonConsecutiveOneDay",
            "label": "Number of non-consecutive one-day",
            "type": "text",
            "description": "Number of non-consecutive one-day recorded"
          }, {
            "id": "softwareTool",
            "label": "Dietary software tool",
            "type": "text",
            "description": "Name of the software used to collect the data"
          }, {
            "id": "foodDescriptors",
            "label": "Food descriptors",
            "description": "Description using FoodEx2 facet"
          }, {
            "id": "collectionTool",
            "label": "Methodological tool to collect data",
            "type": "text",
            "description": "Food diaries, interview, 24-hour recall interview, food propensy questionnaire, portion size measurement aids, eating outside questionnaire"
          }],
          "studySample": [{
            "id": "sampleName",
            "label": "Name",
            "type": "text",
            "description": "An unambiguous ID given to the samples used in the assay"
          }, {
            "id": "samplingWeight",
            "label": "Sampling weight",
            "type": "text",
            "description": "Description of the method employed to compute sampling weight (nonresponse-adjusted weight)"
          }, {
            "id": "protocolOfSampleCollection",
            "label": "Protocol of sample collection",
            "type": "text",
            "description": "Additional protocol for sample and sample collection. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "samplingStrategy",
            "label": "Sampling strategy",
            "type": "text",
            "description": "Sampling strategy (ref. EUROSTAT - Typology of sampling strategy, version of July 2009)"
          }, {
            "id": "samplingSize",
            "label": "Sampling size",
            "type": "text",
            "description": "Number of units, full participants, partial participants, eligibles, not eligible, unresolved (eligibility status not resolved)"
          }, {
            "id": "lotSizeUnit",
            "label": "Lot size unit",
            "type": "text",
            "description": "Unit in which the lot size is expressed"
          }, {
            "id": "samplingPoint",
            "label": "Sampling point",
            "type": "text",
            "description": "Point in the food chain where the sample was taken. (Doc. ESTAT/F5/ES/155 Data dictionary of activities of the establishments)"
          }, {
            "id": "samplingMethod",
            "label": "Sampling method",
            "type": "text",
            "description": "Sampling method used to take the sample"
          }, {
            "id": "typeOfSamplingProgram",
            "label": "Type of sampling program",
            "type": "text",
            "description": "Indicate the type of programm for which the samples have been collected"
          }, {
            "id": "samplingPlan",
            "label": "Sampling plan",
            "type": "text",
            "description": "Description of data collection technique: stratified or complex sampling (several stages)"
          }]
        },
        "modelMath": {
          "parameter": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "parameter": [{
              "id": "subject",
              "label": "Parameter subject",
              "type": "text",
              "description": "Scope of the parameter, e.g. if it refers to an animal, a batch of animals, a batch of products, a carcass, a carcass skin etc"
            }, {
              "id": "maxValue",
              "label": "Value max",
              "type": "text",
              "description": "Numerical value of the maximum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "dataType",
              "label": "Data type",
              "type": "text",
              "description": "Information on the data format of the parameter, e.g. if it is a categorical variable: int, double, array of size x,y,z "
            }, {
              "id": "description",
              "label": "Description",
              "type": "text",
              "description": "General description of the parameter"
            }, {
              "id": "source",
              "label": "Parameter source",
              "type": "text",
              "description": "Information on the type of knowledge used to define the parameter value"
            }, {
              "id": "classification",
              "label": "Parameter classification",
              "type": "text",
              "description": "General classification of the parameter (e.g. Input, Constant, Output etc)"
            }, {
              "id": "distribution",
              "label": "Parameter distribution",
              "type": "text",
              "description": "Distribution describing the parameter variabilty. If no distribution selected this means the value provided in 'Parameter value' is a point estimate. In case a distribution is selected the value provided in 'Parameter value' is a string that the model code can parse in order to sample from the named distribution"
            }, {
              "id": "error",
              "label": "Error",
              "type": "text",
              "description": "Error of the parameter value"
            }, {
              "id": "variabilitySubject",
              "label": "Parameter variability subject",
              "type": "text",
              "description": "Information on which the variability is described. It can be variability between broiler in a flock, variability between all meat packages sold in Denmark, variability between days, etc."
            }, {
              "id": "unit",
              "label": "Unit",
              "type": "text",
              "description": "Unit of the parameter"
            }, {
              "id": "minValue",
              "label": "Value min",
              "type": "text",
              "description": "Numerical value of the minimum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "unitCategory",
              "label": "Unit category",
              "type": "text",
              "description": "General classification of the parameter unit"
            }, {
              "id": "name",
              "label": "Parameter name",
              "type": "text",
              "description": "A name given to the parameter"
            }, {
              "id": "id",
              "label": "Parameter ID",
              "type": "text",
              "description": "An unambiguous ID given to each of the parameters - preferably autogenerated by a software tool and compatible with SBML ID requirements, only letters from A to Z, numbers and '_'"
            }, {
              "id": "value",
              "label": "Value",
              "type": "text",
              "description": "A default value for the parameter. This is mandatory (needs to be provided) for all parameters of type 'Input'"
            }]
          }
        },
        "scope": {
          "product": [{
            "id": "expiryDate",
            "label": "Expiration date",
            "type": "date",
            "description": "Expiry date of food/product"
          }, {
            "id": "treatment",
            "label": "Treatment",
            "description": "Used to characterise a product/matrix based on the treatment or processes applied to the product or any indexed ingredient"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the product, matrix or environment for which the model or data applies"
          }, {
            "id": "productionDate",
            "label": "Production date",
            "type": "date",
            "description": "Date of production of food/product"
          }, {
            "id": "method",
            "label": "Method of production",
            "description": "Type of production for the product/ matrix"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "The product, matrix or environment (e.g food product, lab media, soil etc.) for which the model or data applies"
          }, {
            "id": "originCountry",
            "label": "Country of origin",
            "type": "text",
            "description": "Country of origin of the food/product (ISO 3166-1-alpha-2 country code)"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Detailed description of the product, matrix or environment for which the model or data applies"
          }, {
            "id": "packaging",
            "label": "Packaging",
            "description": "Describe container or wrapper that holds the product/matrix. Common type of packaging (paper or plastic bags, boxes, tinplate or aluminium cans, plastic trays, plastic bottles, glass bottles or jars)"
          }, {
            "id": "fisheriesArea",
            "label": "Fisheries area",
            "type": "text",
            "description": "Fisheries or aquaculture area specifying the origin of the sample (FAO Fisheries areas)."
          }, {
            "id": "originArea",
            "label": "Area of origin",
            "type": "text",
            "description": "Area of origin of the food/product (Nomenclature of territorial units for statistics  NUTS  coding system valid only for EEA and Switzerland)."
          }],
          "populationGroup": [{
            "id": "populationRiskFactor",
            "label": "Risk and population factors",
            "description": "Population risk factor that may influence the outcomes of the study, confounder should be included"
          }, {
            "id": "country",
            "label": "Country",
            "description": "Country on which the population group of the model or data applies"
          }, {
            "id": "populationSpan",
            "label": "Population span (years)",
            "description": "Temporal information on the exposure duration"
          }, {
            "id": "populationGender",
            "label": "Population gender",
            "type": "text",
            "description": "Description of the percentage of gender"
          }, {
            "id": "populationDescription",
            "label": "Description",
            "description": "Description of the population for which the model applies (demographic and socio-economic characteristics for example). Background information that are needed in the data analysis phase, size of household, education level, employment status, professional category, ethnicity, etc."
          }, {
            "id": "populationAge",
            "label": "Population age",
            "description": "Description of the range of age or group of age"
          }, {
            "id": "patternConsumption",
            "label": "Consumption pattern",
            "description": "Description of the consumption of different food items, frequency, portion size"
          }, {
            "id": "name",
            "label": "Population name",
            "type": "text",
            "description": "Name of the population for which the model or data applies"
          }, {
            "id": "season",
            "label": "Season",
            "description": "Distribution of surveyed people according to the season (influence consumption pattern)"
          }, {
            "id": "region",
            "label": "Region",
            "description": "Spatial information (area) on which the population group of the model or data applies"
          }, {
            "id": "targetPopulation",
            "label": "Target population",
            "type": "text",
            "description": "Population of individual that we are interested in describing and making statistical inferences about"
          }, {
            "id": "bmi",
            "label": "BMI",
            "description": "Description of the range of BMI or class of BMI or BMI mean"
          }, {
            "id": "specialDietGroups",
            "label": "Special diet groups",
            "description": "Description of sub-population with special diets (vegetarians, diabetics, group following special ethnic diets)"
          }],
          "hazard": [{
            "id": "maximumResidueLimit",
            "label": "Maximum Residue Limit (MRL)",
            "type": "text",
            "description": "International regulations and permissible maximum residue levels in food and drinking water"
          }, {
            "id": "sourceOfContamination",
            "label": "Source of contamination",
            "type": "text",
            "description": "rigin of the contamination, source"
          }, {
            "id": "indSum",
            "label": "Individual or Summed Hazard",
            "type": "text",
            "description": "Define if the parameter reported is an individual residue/analyte, a summed residue definition or part of a sum a summed residue definition"
          }, {
            "id": "acceptableOperatorsExposureLevel",
            "label": "Acceptable Operator Exposure Level (AOEL)",
            "type": "text",
            "description": "Maximum amount of active substance to which the operator may be exposed without any adverse health effects. The AOEL is expressed as milligrams of the chemical per kilogram body weight of the operator"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Description of the hazard for which the model or data applies"
          }, {
            "id": "type",
            "label": "Hazard type",
            "type": "text",
            "description": "General classification of the hazard for which the model or data applies"
          }, {
            "id": "adverseEffect",
            "label": "Adverse effect",
            "type": "text",
            "description": "Adverse effect induced by hazard about morbidity, mortality, and etcetera"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the hazard for which the model or data applies"
          }, {
            "id": "noObservedAdverseAffectLevel",
            "label": "No Observed Adverse Affect Level (NOAEL)",
            "type": "text",
            "description": "Level of exposure of an organism, found by experiment or observation, at which there is no biologically or statistically significant increase in the frequency or severity of any adverse effects in the exposed population when compared to its appropriate control"
          }, {
            "id": "acuteReferenceDose",
            "label": "Acute Reference Dose (ARfD)",
            "type": "text",
            "description": "An estimate (with uncertainty spanning perhaps an order of magnitude) of a daily oral exposure for an acute duration (24 hours or less) to the human population (including sensitive subgroups) that is likely to be without an appreciable risk of deleterious effects during a lifetime"
          }, {
            "id": "name",
            "label": "Hazard name",
            "type": "text",
            "description": "Name of the hazard (agent, contaminant, chemical) for which the data or model applies"
          }, {
            "id": "lowestObservedAdverseAffectLevel",
            "label": "Lowest Observed Adverse Effect Level (LOAEL)",
            "type": "text",
            "description": "Lowest concentration or amount of a substance found by experiment or observation that causes an adverse alteration of morphology, function, capacity, growth, development, or lifespan of a target organism distinguished from normal organisms of the same species under defined conditions of exposure"
          }, {
            "id": "benchmarkDose",
            "label": "Benchmark Dose (BMD)",
            "type": "text",
            "description": "A dose or concentration that produces a predetermined change in response rate of an adverse effect (called the benchmark response or BMR) compared to background"
          }, {
            "id": "acceptableDailyIntake",
            "label": "Acceptable Daily Intake (ADI)",
            "type": "text",
            "description": "Measure of amount of a specific substance in food or in drinking water tahta can be ingested (orally) on a daily basis over a lifetime without an appreciable health risk"
          }],
          "scope": [{
            "id": "spatialInformation",
            "label": "Spatial information",
            "description": "Spatial information (area) on which the model or data applies"
          }, {
            "id": "generalComment",
            "label": "General comment",
            "type": "long-text",
            "description": "General comments on the scope of the study, data or model"
          }, {
            "id": "temporalInformation",
            "label": "Temporal information",
            "type": "long-text",
            "description": "Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)"
          }]
        },
        "generalInformation": {
          "creator": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "author": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "reference": [{
            "id": "date",
            "label": "Date",
            "type": "year_date",
            "description": "Temporal information on the publication date"
          }, {
            "id": "website",
            "label": "Website",
            "type": "text",
            "description": "A link to the publication website (different from DOI)"
          }, {
            "id": "issue",
            "label": "Issue",
            "type": "text",
            "description": "Data on the details of the issue in which the model or date has been described"
          }, {
            "id": "publicationType",
            "label": "Publication type",
            "type": "text",
            "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
          }, {
            "id": "abstract",
            "label": "Abstract",
            "type": "text",
            "description": "Abstract of the publication in which the model or the data has been described "
          }, {
            "id": "isReferenceDescription",
            "label": "Is_reference_description?",
            "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
          }, {
            "id": "title",
            "label": "Title",
            "type": "long-text",
            "description": "Title of publication in which the model or date has been described"
          }, {
            "id": "pmid",
            "label": "PubMed ID",
            "type": "text",
            "description": "The PubMed ID related to this publication"
          }, {
            "id": "volume",
            "label": "Volume",
            "type": "text",
            "description": "Data on the details of the volume in which the model or date has been described"
          }, {
            "id": "journal",
            "label": "Journal",
            "type": "long-text",
            "description": "Data on the details of the journal in which the model or date has been described"
          }, {
            "id": "authorList",
            "label": "Author list",
            "type": "long-text",
            "description": "Name and surname of the authors who contributed to this publication"
          }, {
            "id": "comment",
            "label": "Comment",
            "type": "long-text",
            "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
          }, {
            "id": "doi",
            "label": "Publication DOI",
            "type": "long-text",
            "description": "The DOI related to this publication"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The status of this publication, e.g. Published, Submitted, etc."
          }],
          "generalInformation": [{
            "id": "identifier",
            "label": "Identifier",
            "type": "text",
            "description": "An unambiguous ID given to the model or data. This can also be created automatically by a software tool"
          }, {
            "id": "format",
            "label": "Format",
            "type": "text",
            "description": "File extension of the model or data file (including version number of format if applicable)"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the study, data or model"
          }, {
            "id": "language",
            "label": "Language",
            "type": "text",
            "description": "A language of the resource (some data or reports can be available in French language for example)"
          }, {
            "id": "source",
            "label": "Source",
            "type": "text",
            "description": "A source from which the resource is derived"
          }, {
            "id": "availability",
            "label": "Availability",
            "type": "text",
            "description": "Availability of data or model, i.e. if the annotated model code / data is included in this FSK file"
          }, {
            "id": "creationDate",
            "label": "Creation date",
            "type": "date",
            "description": "Creation date/time of the FSK file"
          }, {
            "id": "url",
            "label": "URL",
            "type": "text",
            "description": "Web address referencing the resource location (data for example)"
          }, {
            "id": "objective",
            "label": "Objective",
            "type": "long-text",
            "description": "Objective of the model or data"
          }, {
            "id": "modificationDate",
            "label": "Modification date",
            "description": "Date/time of the last version of the FSK file"
          }, {
            "id": "rights",
            "label": "Rights",
            "type": "text",
            "description": "Rights granted for usage, distribution and modification of this FSK file"
          }, {
            "id": "name",
            "label": "Data name",
            "type": "text",
            "description": "A name given to the data"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The status of the resource"
          }]
        }
      };
    }
    // Validate this.panels and return boolean
  }, {
    key: "validate",
    value: function validate() {
      var isValid = true;
      if (!this.panels.generalInformation.validate()) isValid = false;
      if (!this.panels.modelCategory.validate()) isValid = false;
      if (!this.panels.scopeGeneral.validate()) isValid = false;
      if (!this.panels.study.validate()) isValid = false;
      return isValid;
    }
  }, {
    key: "_createPanels",
    value: function _createPanels() {
      var port = window.port || -1;
      var schema = schemas.genericModel;
      return _defineProperty({
        study: new _FormPanel.FormPanel("Study", this.jsonSchema.dataBackground.study, this._metadata.dataBackground ? this._metadata.dataBackground.study : {}, port),
        laboratory: new _TablePanel.TablePanel("Laboratory", this.jsonSchema.dataBackground.laboratory, this._metadata.dataBackground ? this._metadata.dataBackground.laboratory : {}, port),
        assay: new _TablePanel.TablePanel("Assay", this.jsonSchema.dataBackground.assay, this._metadata.dataBackground ? this._metadata.dataBackground.assay : {}, port),
        dietaryAssessmentMethod: new _TablePanel.TablePanel("Dietary Assessment Method", this.jsonSchema.dataBackground.dietaryAssessmentMethod, this._metadata.dataBackground ? this._metadata.dataBackground.dietaryAssessmentMethod : {}, port),
        studySample: new _TablePanel.TablePanel("Study Sample", this.jsonSchema.dataBackground.studySample, this._metadata.dataBackground ? this._metadata.dataBackground.studySample : {}, port),
        parameter: new _TablePanel.TablePanel("Parameter", this.jsonSchema.modelMath.parameter.parameter, this._metadata.modelMath ? this._metadata.modelMath.parameter : {}, port),
        reference: new _FormPanel.FormPanel("Reference", this.jsonSchema.modelMath.parameter.reference, this._metadata.modelMath.parameter ? this._metadata.modelMath.parameter.reference : {}, port),
        scope: new _FormPanel.FormPanel("Scope", this.jsonSchema.scope.scope, this._metadata.scope, port),
        product: new _TablePanel.TablePanel("Product", this.jsonSchema.scope.product, this._metadata.scope ? this._metadata.scope.product : {}, port),
        populationGroup: new _TablePanel.TablePanel("Population Group", this.jsonSchema.scope.populationGroup, this._metadata.scope ? this._metadata.scope.populationGroup : {}, port),
        hazard: new _TablePanel.TablePanel("Hazard", this.jsonSchema.scope.hazard, this._metadata.scope ? this._metadata.scope.hazard : {}, port),
        generalInformation: new _FormPanel.FormPanel("General Information", this.jsonSchema.generalInformation.generalInformation, this._metadata.generalInformation, port),
        creator: new _TablePanel.TablePanel("Creator", this.jsonSchema.generalInformation.creator, this._metadata.generalInformation ? this._metadata.generalInformation.creator : {}, port),
        author: new _TablePanel.TablePanel("Author", this.jsonSchema.generalInformation.author, this._metadata.generalInformation ? this._metadata.generalInformation.author : {}, port)
      }, "reference", new _TablePanel.TablePanel("Reference", this.jsonSchema.generalInformation.reference, this._metadata.generalInformation ? this._metadata.generalInformation.reference : {}, port));
    }
  }]);
}(_ModelView2.ModelView);

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./DataModelGeneralInformationView":75,"./DataModelModelMathView":77,"./GenericModelDataBackgroundView":97,"./GenericModelScopeView":103,"./ModelView":118}],79:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DietaryAssessmentMethod = void 0;
var _ApiClient = require("../ApiClient");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The DietaryAssessmentMethod model module.
 * @module model/DietaryAssessmentMethod
 * @version 1.0.0
 */
var DietaryAssessmentMethod = exports.DietaryAssessmentMethod = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>DietaryAssessmentMethod</code>.
   * @alias module:model/DietaryAssessmentMethod
   * @class
   * @param recordTypes {} Consumption occasion, mean of consumption, quantified and described as eaten, recipes for self-made
   * @param numberOfFoodItems {} Number of food items
   * @param numberOfNonConsecutiveOneDay {} Number of non-consecutive one-day recorded
   * @param foodDescriptors {} Description using FoodEx2 facet
   * @param collectionTool {} Food diaries, interview, 24-hour recall interview, food propensy questionnaire, portion size measurement aids, eating outside questionnaire
   */
  function DietaryAssessmentMethod(recordTypesnumberOfFoodItemsnumberOfNonConsecutiveOneDayfoodDescriptorscollectionTool) {
    _classCallCheck(this, DietaryAssessmentMethod);
    this.recordTypes = recordTypes;
    this.numberOfFoodItems = numberOfFoodItems;
    this.numberOfNonConsecutiveOneDay = numberOfNonConsecutiveOneDay;
    this.foodDescriptors = foodDescriptors;
    this.collectionTool = collectionTool;
  }

  /**
   * Constructs a <code>DietaryAssessmentMethod</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/DietaryAssessmentMethod} obj Optional instance to populate.
   * @return {module:model/DietaryAssessmentMethod} The populated <code>DietaryAssessmentMethod</code> instance.
   */
  return _createClass(DietaryAssessmentMethod, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new DietaryAssessmentMethod();
        if (data.hasOwnProperty('recordTypes')) obj.recordTypes = _ApiClient.ApiClient.convertToType(data['recordTypes'], ['String']);
        if (data.hasOwnProperty('numberOfFoodItems')) obj.numberOfFoodItems = _ApiClient.ApiClient.convertToType(data['numberOfFoodItems'], ['String']);
        if (data.hasOwnProperty('numberOfNonConsecutiveOneDay')) obj.numberOfNonConsecutiveOneDay = _ApiClient.ApiClient.convertToType(data['numberOfNonConsecutiveOneDay'], 'String');
        if (data.hasOwnProperty('softwareTool')) obj.softwareTool = _ApiClient.ApiClient.convertToType(data['softwareTool'], 'String');
        if (data.hasOwnProperty('foodDescriptors')) obj.foodDescriptors = _ApiClient.ApiClient.convertToType(data['foodDescriptors'], ['String']);
        if (data.hasOwnProperty('collectionTool')) obj.collectionTool = _ApiClient.ApiClient.convertToType(data['collectionTool'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * Consumption occasion, mean of consumption, quantified and described as eaten, recipes for self-made
 * @member {Array.<String>} recordTypes
 */
DietaryAssessmentMethod.prototype.recordTypes = undefined;

/**
 * Number of food items
 * @member {Array.<String>} numberOfFoodItems
 */
DietaryAssessmentMethod.prototype.numberOfFoodItems = undefined;

/**
 * Number of non-consecutive one-day recorded
 * @member {String} numberOfNonConsecutiveOneDay
 */
DietaryAssessmentMethod.prototype.numberOfNonConsecutiveOneDay = undefined;

/**
 * Name of the software used to collect the data
 * @member {String} softwareTool
 */
DietaryAssessmentMethod.prototype.softwareTool = undefined;

/**
 * Description using FoodEx2 facet
 * @member {Array.<String>} foodDescriptors
 */
DietaryAssessmentMethod.prototype.foodDescriptors = undefined;

/**
 * Food diaries, interview, 24-hour recall interview, food propensy questionnaire, portion size measurement aids, eating outside questionnaire
 * @member {String} collectionTool
 */
DietaryAssessmentMethod.prototype.collectionTool = undefined;

},{"../ApiClient":44}],80:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DietaryAssessmentMethodView = void 0;
var _ApiClient = require("../ApiClient");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The DietaryAssessmentMethod View  module.
 * @module model/DietaryAssessmentMethod
 * @version 1.0.0
 */
var DietaryAssessmentMethodView = exports.DietaryAssessmentMethodView = /*#__PURE__*/_createClass(function DietaryAssessmentMethodView() {
  _classCallCheck(this, DietaryAssessmentMethodView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63}],81:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DoseResponseModel = void 0;
var _ApiClient = require("../ApiClient");
var _DoseResponseModelGeneralInformation = require("./DoseResponseModelGeneralInformation");
var _DoseResponseModelModelMath = require("./DoseResponseModelModelMath");
var _DoseResponseModelScope = require("./DoseResponseModelScope");
var _Model2 = require("./Model");
var _PredictiveModelDataBackground = require("./PredictiveModelDataBackground");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The DoseResponseModel model module.
 * @module model/DoseResponseModel
 * @version 1.0.0
 */
var DoseResponseModel = exports.DoseResponseModel = /*#__PURE__*/function (_Model) {
  /**
   * Constructs a new <code>DoseResponseModel</code>.
   * @alias module:model/DoseResponseModel
   * @class
   * @extends module:model/Model
   * @param modelType {} 
   */
  function DoseResponseModel(modelType) {
    _classCallCheck(this, DoseResponseModel);
    return _callSuper(this, DoseResponseModel, [modelType]);
  }

  /**
   * Constructs a <code>DoseResponseModel</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/DoseResponseModel} obj Optional instance to populate.
   * @return {module:model/DoseResponseModel} The populated <code>DoseResponseModel</code> instance.
   */
  _inherits(DoseResponseModel, _Model);
  return _createClass(DoseResponseModel, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new DoseResponseModel();
        _Model2.Model.constructFromObject(data, obj);
        if (data.hasOwnProperty('dataBackground')) obj.dataBackground = _PredictiveModelDataBackground.PredictiveModelDataBackground.constructFromObject(data['dataBackground']);
        if (data.hasOwnProperty('modelMath')) obj.modelMath = _DoseResponseModelModelMath.DoseResponseModelModelMath.constructFromObject(data['modelMath']);
        if (data.hasOwnProperty('scope')) obj.scope = _DoseResponseModelScope.DoseResponseModelScope.constructFromObject(data['scope']);
        if (data.hasOwnProperty('generalInformation')) obj.generalInformation = _DoseResponseModelGeneralInformation.DoseResponseModelGeneralInformation.constructFromObject(data['generalInformation']);
      }
      return obj;
    }
  }]);
}(_Model2.Model);
/**
 * @member {module:model/PredictiveModelDataBackground} dataBackground
 */
DoseResponseModel.prototype.dataBackground = undefined;

/**
 * @member {module:model/DoseResponseModelModelMath} modelMath
 */
DoseResponseModel.prototype.modelMath = undefined;

/**
 * @member {module:model/DoseResponseModelScope} scope
 */
DoseResponseModel.prototype.scope = undefined;

/**
 * @member {module:model/DoseResponseModelGeneralInformation} generalInformation
 */
DoseResponseModel.prototype.generalInformation = undefined;

},{"../ApiClient":44,"./DoseResponseModelGeneralInformation":82,"./DoseResponseModelModelMath":84,"./DoseResponseModelScope":86,"./Model":113,"./PredictiveModelDataBackground":134}],82:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DoseResponseModelGeneralInformation = void 0;
var _ApiClient = require("../ApiClient");
var _Contact = require("./Contact");
var _ModelCategory = require("./ModelCategory");
var _Reference = require("./Reference");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The DoseResponseModelGeneralInformation model module.
 * @module model/DoseResponseModelGeneralInformation
 * @version 1.0.0
 */
var DoseResponseModelGeneralInformation = exports.DoseResponseModelGeneralInformation = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>DoseResponseModelGeneralInformation</code>.
   * @alias module:model/DoseResponseModelGeneralInformation
   * @class
   * @param identifier {} An unambiguous ID given to the model or data. This can also be created automatically by a software tool
   * @param creationDate {} Creation date/time of the FSK file
   * @param rights {} Rights granted for usage, distribution and modification of this FSK file
   * @param name {} A name given to the model or data
   */
  function DoseResponseModelGeneralInformation(identifiercreationDaterightsname) {
    _classCallCheck(this, DoseResponseModelGeneralInformation);
    this.identifier = identifier;
    this.creationDate = creationDate;
    this.rights = rights;
    this.name = name;
  }

  /**
   * Constructs a <code>DoseResponseModelGeneralInformation</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/DoseResponseModelGeneralInformation} obj Optional instance to populate.
   * @return {module:model/DoseResponseModelGeneralInformation} The populated <code>DoseResponseModelGeneralInformation</code> instance.
   */
  return _createClass(DoseResponseModelGeneralInformation, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new DoseResponseModelGeneralInformation();
        if (data.hasOwnProperty('identifier')) obj.identifier = _ApiClient.ApiClient.convertToType(data['identifier'], 'String');
        if (data.hasOwnProperty('creator')) obj.creator = _ApiClient.ApiClient.convertToType(data['creator'], [_Contact.Contact]);
        if (data.hasOwnProperty('software')) obj.software = _ApiClient.ApiClient.convertToType(data['software'], 'String');
        if (data.hasOwnProperty('author')) obj.author = _ApiClient.ApiClient.convertToType(data['author'], [_Contact.Contact]);
        if (data.hasOwnProperty('format')) obj.format = _ApiClient.ApiClient.convertToType(data['format'], 'String');
        if (data.hasOwnProperty('description')) obj.description = _ApiClient.ApiClient.convertToType(data['description'], 'String');
        if (data.hasOwnProperty('language')) obj.language = _ApiClient.ApiClient.convertToType(data['language'], 'String');
        if (data.hasOwnProperty('source')) obj.source = _ApiClient.ApiClient.convertToType(data['source'], 'String');
        if (data.hasOwnProperty('availability')) obj.availability = _ApiClient.ApiClient.convertToType(data['availability'], 'String');
        if (data.hasOwnProperty('creationDate')) obj.creationDate = _ApiClient.ApiClient.convertToType(data['creationDate'], 'Date');
        if (data.hasOwnProperty('url')) obj.url = _ApiClient.ApiClient.convertToType(data['url'], 'String');
        if (data.hasOwnProperty('objective')) obj.objective = _ApiClient.ApiClient.convertToType(data['objective'], 'String');
        if (data.hasOwnProperty('reference')) obj.reference = _ApiClient.ApiClient.convertToType(data['reference'], [_Reference.Reference]);
        if (data.hasOwnProperty('modificationDate')) obj.modificationDate = _ApiClient.ApiClient.convertToType(data['modificationDate'], ['Date']);
        if (data.hasOwnProperty('rights')) obj.rights = _ApiClient.ApiClient.convertToType(data['rights'], 'String');
        if (data.hasOwnProperty('name')) obj.name = _ApiClient.ApiClient.convertToType(data['name'], 'String');
        if (data.hasOwnProperty('languageWrittenIn')) obj.languageWrittenIn = _ApiClient.ApiClient.convertToType(data['languageWrittenIn'], 'String');
        if (data.hasOwnProperty('modelCategory')) obj.modelCategory = _ModelCategory.ModelCategory.constructFromObject(data['modelCategory']);
        if (data.hasOwnProperty('status')) obj.status = _ApiClient.ApiClient.convertToType(data['status'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * An unambiguous ID given to the model or data. This can also be created automatically by a software tool
 * @member {String} identifier
 */
DoseResponseModelGeneralInformation.prototype.identifier = undefined;

/**
 * The person(s) that created this FSK file including all metadata
 * @member {Array.<module:model/Contact>} creator
 */
DoseResponseModelGeneralInformation.prototype.creator = undefined;

/**
 * The program or software language in which the model has been implemented
 * @member {String} software
 */
DoseResponseModelGeneralInformation.prototype.software = undefined;

/**
 * Person(s) who generated the model code or generated the data set originally
 * @member {Array.<module:model/Contact>} author
 */
DoseResponseModelGeneralInformation.prototype.author = undefined;

/**
 * File extension of the model or data file (including version number of format if applicable)
 * @member {String} format
 */
DoseResponseModelGeneralInformation.prototype.format = undefined;

/**
 * General description of the study, data or model
 * @member {String} description
 */
DoseResponseModelGeneralInformation.prototype.description = undefined;

/**
 * A language of the resource (some data or reports can be available in French language for example)
 * @member {String} language
 */
DoseResponseModelGeneralInformation.prototype.language = undefined;

/**
 * A source from which the model/data is derived
 * @member {String} source
 */
DoseResponseModelGeneralInformation.prototype.source = undefined;

/**
 * Availability of data or model, i.e. if the annotated model code / data is included in this FSK file
 * @member {String} availability
 */
DoseResponseModelGeneralInformation.prototype.availability = undefined;

/**
 * Creation date/time of the FSK file
 * @member {Date} creationDate
 */
DoseResponseModelGeneralInformation.prototype.creationDate = undefined;

/**
 * Web address referencing the resource location (data for example)
 * @member {String} url
 */
DoseResponseModelGeneralInformation.prototype.url = undefined;

/**
 * Objective of the model or data
 * @member {String} objective
 */
DoseResponseModelGeneralInformation.prototype.objective = undefined;

/**
 * @member {Array.<module:model/Reference>} reference
 */
DoseResponseModelGeneralInformation.prototype.reference = undefined;

/**
 * Date/time of the last version of the FSK file
 * @member {Array.<Date>} modificationDate
 */
DoseResponseModelGeneralInformation.prototype.modificationDate = undefined;

/**
 * Rights granted for usage, distribution and modification of this FSK file
 * @member {String} rights
 */
DoseResponseModelGeneralInformation.prototype.rights = undefined;

/**
 * A name given to the model or data
 * @member {String} name
 */
DoseResponseModelGeneralInformation.prototype.name = undefined;

/**
 * Software language used to write the model, e.g. R or MatLab
 * @member {String} languageWrittenIn
 */
DoseResponseModelGeneralInformation.prototype.languageWrittenIn = undefined;

/**
 * @member {module:model/ModelCategory} modelCategory
 */
DoseResponseModelGeneralInformation.prototype.modelCategory = undefined;

/**
 * The curation status of the model
 * @member {String} status
 */
DoseResponseModelGeneralInformation.prototype.status = undefined;

},{"../ApiClient":44,"./Contact":71,"./ModelCategory":114,"./Reference":155}],83:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DoseResponseModelGeneralInformationView = void 0;
var _ApiClient = require("../ApiClient");
var _ContactView = require("./ContactView");
var _ModelCategoryView = require("./ModelCategoryView");
var _ReferenceView = require("./ReferenceView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The DoseResponseModelGeneralInformation View  module.
 * @module model/DoseResponseModelGeneralInformation
 * @version 1.0.0
 */
var DoseResponseModelGeneralInformationView = exports.DoseResponseModelGeneralInformationView = /*#__PURE__*/_createClass(function DoseResponseModelGeneralInformationView() {
  _classCallCheck(this, DoseResponseModelGeneralInformationView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./ContactView":72,"./ModelCategoryView":115,"./ReferenceView":156}],84:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DoseResponseModelModelMath = void 0;
var _ApiClient = require("../ApiClient");
var _Exposure = require("./Exposure");
var _ModelEquation = require("./ModelEquation");
var _Parameter = require("./Parameter");
var _QualityMeasures = require("./QualityMeasures");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The DoseResponseModelModelMath model module.
 * @module model/DoseResponseModelModelMath
 * @version 1.0.0
 */
var DoseResponseModelModelMath = exports.DoseResponseModelModelMath = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>DoseResponseModelModelMath</code>.
   * @alias module:model/DoseResponseModelModelMath
   * @class
   * @param parameter {} 
   */
  function DoseResponseModelModelMath(parameter) {
    _classCallCheck(this, DoseResponseModelModelMath);
    this.parameter = parameter;
  }

  /**
   * Constructs a <code>DoseResponseModelModelMath</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/DoseResponseModelModelMath} obj Optional instance to populate.
   * @return {module:model/DoseResponseModelModelMath} The populated <code>DoseResponseModelModelMath</code> instance.
   */
  return _createClass(DoseResponseModelModelMath, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new DoseResponseModelModelMath();
        if (data.hasOwnProperty('fittingProcedure')) obj.fittingProcedure = _ApiClient.ApiClient.convertToType(data['fittingProcedure'], 'String');
        if (data.hasOwnProperty('modelEquation')) obj.modelEquation = _ApiClient.ApiClient.convertToType(data['modelEquation'], [_ModelEquation.ModelEquation]);
        if (data.hasOwnProperty('exposure')) obj.exposure = _Exposure.Exposure.constructFromObject(data['exposure']);
        if (data.hasOwnProperty('parameter')) obj.parameter = _ApiClient.ApiClient.convertToType(data['parameter'], [_Parameter.Parameter]);
        if (data.hasOwnProperty('qualityMeasures')) obj.qualityMeasures = _ApiClient.ApiClient.convertToType(data['qualityMeasures'], [_QualityMeasures.QualityMeasures]);
        if (data.hasOwnProperty('event')) obj.event = _ApiClient.ApiClient.convertToType(data['event'], ['String']);
      }
      return obj;
    }
  }]);
}();
/**
 * Procedure used to fit the data to the model equation
 * @member {String} fittingProcedure
 */
DoseResponseModelModelMath.prototype.fittingProcedure = undefined;

/**
 * @member {Array.<module:model/ModelEquation>} modelEquation
 */
DoseResponseModelModelMath.prototype.modelEquation = undefined;

/**
 * @member {module:model/Exposure} exposure
 */
DoseResponseModelModelMath.prototype.exposure = undefined;

/**
 * @member {Array.<module:model/Parameter>} parameter
 */
DoseResponseModelModelMath.prototype.parameter = undefined;

/**
 * @member {Array.<module:model/QualityMeasures>} qualityMeasures
 */
DoseResponseModelModelMath.prototype.qualityMeasures = undefined;

/**
 * Definition of time-dependent parameter changes
 * @member {Array.<String>} event
 */
DoseResponseModelModelMath.prototype.event = undefined;

},{"../ApiClient":44,"./Exposure":89,"./ModelEquation":116,"./Parameter":129,"./QualityMeasures":153}],85:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DoseResponseModelModelMathView = void 0;
var _ApiClient = require("../ApiClient");
var _ExposureView = require("./ExposureView");
var _ModelEquationView = require("./ModelEquationView");
var _ParameterView = require("./ParameterView");
var _QualityMeasuresView = require("./QualityMeasuresView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The DoseResponseModelModelMath View  module.
 * @module model/DoseResponseModelModelMath
 * @version 1.0.0
 */
var DoseResponseModelModelMathView = exports.DoseResponseModelModelMathView = /*#__PURE__*/_createClass(function DoseResponseModelModelMathView() {
  _classCallCheck(this, DoseResponseModelModelMathView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./ExposureView":94,"./ModelEquationView":117,"./ParameterView":130,"./QualityMeasuresView":154}],86:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DoseResponseModelScope = void 0;
var _ApiClient = require("../ApiClient");
var _Hazard = require("./Hazard");
var _PopulationGroup = require("./PopulationGroup");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The DoseResponseModelScope model module.
 * @module model/DoseResponseModelScope
 * @version 1.0.0
 */
var DoseResponseModelScope = exports.DoseResponseModelScope = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>DoseResponseModelScope</code>.
   * @alias module:model/DoseResponseModelScope
   * @class
   */
  function DoseResponseModelScope() {
    _classCallCheck(this, DoseResponseModelScope);
  }

  /**
   * Constructs a <code>DoseResponseModelScope</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/DoseResponseModelScope} obj Optional instance to populate.
   * @return {module:model/DoseResponseModelScope} The populated <code>DoseResponseModelScope</code> instance.
   */
  return _createClass(DoseResponseModelScope, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new DoseResponseModelScope();
        if (data.hasOwnProperty('spatialInformation')) obj.spatialInformation = _ApiClient.ApiClient.convertToType(data['spatialInformation'], ['String']);
        if (data.hasOwnProperty('populationGroup')) obj.populationGroup = _ApiClient.ApiClient.convertToType(data['populationGroup'], [_PopulationGroup.PopulationGroup]);
        if (data.hasOwnProperty('hazard')) obj.hazard = _ApiClient.ApiClient.convertToType(data['hazard'], [_Hazard.Hazard]);
        if (data.hasOwnProperty('generalComment')) obj.generalComment = _ApiClient.ApiClient.convertToType(data['generalComment'], 'String');
        if (data.hasOwnProperty('temporalInformation')) obj.temporalInformation = _ApiClient.ApiClient.convertToType(data['temporalInformation'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * Spatial information (area) on which the model or data applies
 * @member {Array.<String>} spatialInformation
 */
DoseResponseModelScope.prototype.spatialInformation = undefined;

/**
 * @member {Array.<module:model/PopulationGroup>} populationGroup
 */
DoseResponseModelScope.prototype.populationGroup = undefined;

/**
 * @member {Array.<module:model/Hazard>} hazard
 */
DoseResponseModelScope.prototype.hazard = undefined;

/**
 * General comments on the scope of the study, data or model
 * @member {String} generalComment
 */
DoseResponseModelScope.prototype.generalComment = undefined;

/**
 * Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)
 * @member {String} temporalInformation
 */
DoseResponseModelScope.prototype.temporalInformation = undefined;

},{"../ApiClient":44,"./Hazard":105,"./PopulationGroup":131}],87:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DoseResponseModelScopeView = void 0;
var _ApiClient = require("../ApiClient");
var _HazardView = require("./HazardView");
var _PopulationGroupView = require("./PopulationGroupView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The DoseResponseModelScope View  module.
 * @module model/DoseResponseModelScope
 * @version 1.0.0
 */
var DoseResponseModelScopeView = exports.DoseResponseModelScopeView = /*#__PURE__*/_createClass(function DoseResponseModelScopeView() {
  _classCallCheck(this, DoseResponseModelScopeView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./HazardView":106,"./PopulationGroupView":132}],88:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DoseResponseModelView = void 0;
var _ApiClient = require("../ApiClient");
var _DoseResponseModelGeneralInformationView = require("./DoseResponseModelGeneralInformationView");
var _DoseResponseModelModelMathView = require("./DoseResponseModelModelMathView");
var _DoseResponseModelScopeView = require("./DoseResponseModelScopeView");
var _ModelView2 = require("./ModelView");
var _PredictiveModelDataBackgroundView = require("./PredictiveModelDataBackgroundView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The DoseResponseModel View  module.
 * @module model/DoseResponseModel
 * @version 1.0.0
 */
var DoseResponseModelView = exports.DoseResponseModelView = /*#__PURE__*/function (_ModelView) {
  function DoseResponseModelView(metadata, img, state, modelScript, visScript, readme) {
    var _this;
    _classCallCheck(this, DoseResponseModelView);
    _this = _callSuper(this, DoseResponseModelView, [metadata, img, modelScript, visScript, readme]);
    _this._schema = schemas.genericModel;
    if (state) {
      _this.panels = _this._createPanels();
    }
    _this._menu = [{
      "label": "General Information",
      "id": "generalInformation",
      "submenus": [{
        "label": "General Information",
        "id": "generalInformation"
      }, {
        "label": "Model Category",
        "id": "modelCategory"
      }, {
        "label": "Reference",
        "id": "reference"
      }, {
        "label": "Author",
        "id": "author"
      }, {
        "label": "Creator",
        "id": "creator"
      }]
    }, {
      "label": "Scope",
      "id": "scope",
      "submenus": [{
        "label": "Scope",
        "id": "scope"
      }, {
        "label": "Hazard",
        "id": "hazard"
      }, {
        "label": "Population Group",
        "id": "populationGroup"
      }]
    }, {
      "label": "Model Math",
      "id": "modelMath",
      "submenus": [{
        "label": "Model Math",
        "id": "modelMath"
      }, {
        "label": "Quality Measures",
        "id": "qualityMeasures"
      }, {
        "label": "Parameter",
        "id": "parameter",
        "submenus": [{
          "label": "Parameter",
          "id": "parameter"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }, {
        "label": "Exposure",
        "id": "exposure"
      }, {
        "label": "Model Equation",
        "id": "modelEquation",
        "submenus": [{
          "label": "Model Equation",
          "id": "modelEquation"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }]
    }, {
      "label": "Data Background",
      "id": "dataBackground",
      "submenus": [{
        "label": "Study Sample",
        "id": "studySample"
      }, {
        "label": "Assay",
        "id": "assay"
      }, {
        "label": "Laboratory",
        "id": "laboratory"
      }, {
        "label": "Study",
        "id": "study"
      }]
    }];
    _this._panels = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
      study: {
        type: 'simple',
        schema: _this.jsonSchema.dataBackgroundstudy,
        metadata: _this._metadata.study
      },
      laboratory: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundlaboratory,
        metadata: _this._metadata.laboratory
      },
      assay: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundassay,
        metadata: _this._metadata.assay
      },
      studySample: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundstudySample,
        metadata: _this._metadata.studySample
      },
      modelMath: {
        type: 'simple',
        schema: _this.jsonSchema.modelMathmodelMath,
        metadata: _this._metadata.modelMath
      },
      modelEquation: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationmodelEquation,
        metadata: _this._metadata.modelEquation
      },
      reference: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationreference,
        metadata: _this._metadata.reference
      },
      exposure: {
        type: 'simple',
        schema: _this.jsonSchema.modelMathexposure,
        metadata: _this._metadata.exposure
      },
      parameter: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.parameterparameter,
        metadata: _this._metadata.parameter
      }
    }, "reference", {
      type: 'simple',
      schema: _this.jsonSchema.modelMath.parameterreference,
      metadata: _this._metadata.reference
    }), "qualityMeasures", {
      type: 'complex',
      schema: _this.jsonSchema.modelMathqualityMeasures,
      metadata: _this._metadata.qualityMeasures
    }), "scope", {
      type: 'simple',
      schema: _this.jsonSchema.scopescope,
      metadata: _this._metadata.scope
    }), "populationGroup", {
      type: 'complex',
      schema: _this.jsonSchema.scopepopulationGroup,
      metadata: _this._metadata.populationGroup
    }), "hazard", {
      type: 'complex',
      schema: _this.jsonSchema.scopehazard,
      metadata: _this._metadata.hazard
    }), "generalInformation", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationgeneralInformation,
      metadata: _this._metadata.generalInformation
    }), "creator", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationcreator,
      metadata: _this._metadata.creator
    }), "author", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationauthor,
      metadata: _this._metadata.author
    }), "reference", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationreference,
      metadata: _this._metadata.reference
    }), "modelCategory", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationmodelCategory,
      metadata: _this._metadata.modelCategory
    });
    return _this;
  }
  _inherits(DoseResponseModelView, _ModelView);
  return _createClass(DoseResponseModelView, [{
    key: "metaData",
    get: function get() {
      try {
        this._metadata.dataBackground.study = this.panels.study.data;
        this._metadata.dataBackground.laboratory = this.panels.laboratory.data;
        this._metadata.dataBackground.assay = this.panels.assay.data;
        this._metadata.dataBackground.studySample = this.panels.studySample.data;
        this._metadata.modelMath = this.panels.modelMath.data;
        this._metadata.modelMath.modelEquation = this.panels.modelEquation.data;
        this._metadata.modelMath.modelEquation.reference = this.panels.reference.data;
        this._metadata.modelMath.exposure = this.panels.exposure.data;
        this._metadata.modelMath.parameter = this.panels.parameter.data;
        this._metadata.modelMath.parameter.reference = this.panels.reference.data;
        this._metadata.modelMath.qualityMeasures = this.panels.qualityMeasures.data;
        this._metadata.scope = this.panels.scope.data;
        this._metadata.scope.populationGroup = this.panels.populationGroup.data;
        this._metadata.scope.hazard = this.panels.hazard.data;
        this._metadata.generalInformation = this.panels.generalInformation.data;
        this._metadata.generalInformation.creator = this.panels.creator.data;
        this._metadata.generalInformation.author = this.panels.author.data;
        this._metadata.generalInformation.reference = this.panels.reference.data;
        this._metadata.generalInformation.modelCategory = this.panels.modelCategory.data;
        this._metadata.modelType = "DoseResponseModel";
        this._metadata = metadataFix(this._metadata);
      } catch (error) {
        console.log(error);
      }
      return this._metadata;
    }
  }, {
    key: "jsonSchema",
    get: function get() {
      return {
        "dataBackground": {
          "study": [{
            "id": "identifier",
            "label": "Study identifier",
            "type": "text",
            "description": "A user defined identifier for the study"
          }, {
            "id": "protocolComponentsName",
            "label": "Components names",
            "type": "text",
            "description": "The names of the components used when carrying out this protocol"
          }, {
            "id": "designType",
            "label": "Design type",
            "type": "text",
            "description": "The type of study design being employed"
          }, {
            "id": "assayMeasurementType",
            "label": "Assay measurement type",
            "type": "text",
            "description": "The measurement being observed in this assay"
          }, {
            "id": "protocolComponentsType",
            "label": "Protocol components type",
            "type": "text",
            "description": "Description"
          }, {
            "id": "description",
            "label": "Study description",
            "type": "long-text",
            "description": "A brief description of the study aims"
          }, {
            "id": "assayTechnologyPlatform",
            "label": "Assay technology platform",
            "type": "text",
            "description": "The technology platform used"
          }, {
            "id": "assayTechnologyType",
            "label": "Assay technology type",
            "type": "text",
            "description": "The technology being employed to observe this measurement"
          }, {
            "id": "protocolType",
            "label": "Protocol type",
            "type": "text",
            "description": "The type of the protocol, preferably coming from an Ontology, e.g. Extraction Protocol"
          }, {
            "id": "title",
            "label": "Study title",
            "type": "long-text",
            "description": "A title for the study"
          }, {
            "id": "protocolDescription",
            "label": "Protocol description",
            "type": "long-text",
            "description": "A description of the protocol"
          }, {
            "id": "protocolParametersName",
            "label": "Parameters names",
            "type": "text",
            "description": "The parameters used when executing this protocol"
          }, {
            "id": "protocolName",
            "label": "Protocol name",
            "type": "text",
            "description": "The name of the protocol, e.g.Extraction Protocol"
          }, {
            "id": "protocolVersion",
            "label": "Protocol version",
            "type": "text",
            "description": "The version of the protocol used, where applicable."
          }, {
            "id": "protocolURI",
            "label": "Protocol URI",
            "type": "text",
            "description": "A URI to link out to a publication, web page, etc. describing the protocol"
          }, {
            "id": "accreditationProcedureForTheAssayTechnology",
            "label": "Accreditation procedure for assay",
            "type": "text",
            "description": "Accreditation procedure for the analytical method used"
          }],
          "laboratory": [{
            "id": "country",
            "label": "Laboratory country",
            "type": "text",
            "description": "Country where the laboratory is placed. (ISO 3166-1-alpha-2)"
          }, {
            "id": "name",
            "label": "Laboratory name",
            "type": "text",
            "description": "Laboratory code (National laboratory code if available) or Laboratory name "
          }, {
            "id": "accreditation",
            "label": "Laboratory accreditation",
            "description": "The laboratory accreditation to ISO/IEC 17025"
          }],
          "assay": [{
            "id": "contaminationRange",
            "label": "Range of contamination",
            "type": "text",
            "description": "Range of result of the analytical measure reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "uncertaintyValue",
            "label": "Uncertainty value",
            "type": "text",
            "description": "Indicate the expanded uncertainty (usually 95% confidence interval) value associated with the measurement expressed in the unit reported in the field Hazard unit"
          }, {
            "id": "fatPercentage",
            "label": "Percentage of fat",
            "type": "text",
            "description": "Percentage of fat in the original sample"
          }, {
            "id": "name",
            "label": "Assay name",
            "type": "text",
            "description": "A name given to the assay"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the assay. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "moisturePercentage",
            "label": "Percentage of moisture",
            "type": "text",
            "description": "Percentage of moisture in the original sample"
          }, {
            "id": "leftCensoredData",
            "label": "Left-censored data",
            "type": "text",
            "description": "Percentage of measures equal to LOQ and/or LOD"
          }, {
            "id": "detectionLimit",
            "label": "Limit of detection",
            "type": "text",
            "description": "Limit of detection reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "quantificationLimit",
            "label": "Limit of quantification",
            "type": "text",
            "description": "Limit of quantification reported in the unit specified by the variable Hazard unit"
          }],
          "studySample": [{
            "id": "sampleName",
            "label": "Name",
            "type": "text",
            "description": "An unambiguous ID given to the samples used in the assay"
          }, {
            "id": "samplingWeight",
            "label": "Sampling weight",
            "type": "text",
            "description": "Description of the method employed to compute sampling weight (nonresponse-adjusted weight)"
          }, {
            "id": "protocolOfSampleCollection",
            "label": "Protocol of sample collection",
            "type": "text",
            "description": "Additional protocol for sample and sample collection. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "samplingStrategy",
            "label": "Sampling strategy",
            "type": "text",
            "description": "Sampling strategy (ref. EUROSTAT - Typology of sampling strategy, version of July 2009)"
          }, {
            "id": "samplingSize",
            "label": "Sampling size",
            "type": "text",
            "description": "Number of units, full participants, partial participants, eligibles, not eligible, unresolved (eligibility status not resolved)"
          }, {
            "id": "lotSizeUnit",
            "label": "Lot size unit",
            "type": "text",
            "description": "Unit in which the lot size is expressed"
          }, {
            "id": "samplingPoint",
            "label": "Sampling point",
            "type": "text",
            "description": "Point in the food chain where the sample was taken. (Doc. ESTAT/F5/ES/155 Data dictionary of activities of the establishments)"
          }, {
            "id": "samplingMethod",
            "label": "Sampling method",
            "type": "text",
            "description": "Sampling method used to take the sample"
          }, {
            "id": "typeOfSamplingProgram",
            "label": "Type of sampling program",
            "type": "text",
            "description": "Indicate the type of programm for which the samples have been collected"
          }, {
            "id": "samplingPlan",
            "label": "Sampling plan",
            "type": "text",
            "description": "Description of data collection technique: stratified or complex sampling (several stages)"
          }]
        },
        "modelMath": {
          "modelEquation": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "modelEquation": [{
              "id": "modelEquation",
              "label": "Equation",
              "type": "text",
              "description": "The pointer to the file that holds the software code (e.g. R-script)"
            }, {
              "id": "name",
              "label": "Model equation name",
              "type": "text",
              "description": "A name given to the model equation"
            }, {
              "id": "modelHypothesis",
              "label": "Hypothesis of the model",
              "description": "Description of the hypothesis of the model"
            }, {
              "id": "modelEquationClass",
              "label": "Model equation class",
              "type": "text",
              "description": "Information on that helps to categorize model equations"
            }]
          },
          "exposure": [{
            "id": "treatment",
            "label": "Left-censored data treatment",
            "description": "Description of the mathematical method to replace left-censored data (recommandation of WHO (2013), distribution or others)"
          }, {
            "id": "scenario",
            "label": "Scenario",
            "description": "Description of the different scenarios of exposure assessment"
          }, {
            "id": "uncertaintyEstimation",
            "label": "Uncertainty estimation",
            "type": "text",
            "description": "Analysis to estimate uncertainty"
          }, {
            "id": "type",
            "label": "Type of exposure",
            "type": "text",
            "description": "Description of the type of exposure"
          }, {
            "id": "contamination",
            "label": "Contam level post data treatment",
            "description": "Description of the range of of the level of contamination after left censored data treatment"
          }],
          "parameter": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "parameter": [{
              "id": "subject",
              "label": "Parameter subject",
              "type": "text",
              "description": "Scope of the parameter, e.g. if it refers to an animal, a batch of animals, a batch of products, a carcass, a carcass skin etc"
            }, {
              "id": "maxValue",
              "label": "Value max",
              "type": "text",
              "description": "Numerical value of the maximum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "dataType",
              "label": "Data type",
              "type": "text",
              "description": "Information on the data format of the parameter, e.g. if it is a categorical variable: int, double, array of size x,y,z "
            }, {
              "id": "description",
              "label": "Description",
              "type": "text",
              "description": "General description of the parameter"
            }, {
              "id": "source",
              "label": "Parameter source",
              "type": "text",
              "description": "Information on the type of knowledge used to define the parameter value"
            }, {
              "id": "classification",
              "label": "Parameter classification",
              "type": "text",
              "description": "General classification of the parameter (e.g. Input, Constant, Output etc)"
            }, {
              "id": "distribution",
              "label": "Parameter distribution",
              "type": "text",
              "description": "Distribution describing the parameter variabilty. If no distribution selected this means the value provided in 'Parameter value' is a point estimate. In case a distribution is selected the value provided in 'Parameter value' is a string that the model code can parse in order to sample from the named distribution"
            }, {
              "id": "error",
              "label": "Error",
              "type": "text",
              "description": "Error of the parameter value"
            }, {
              "id": "variabilitySubject",
              "label": "Parameter variability subject",
              "type": "text",
              "description": "Information on which the variability is described. It can be variability between broiler in a flock, variability between all meat packages sold in Denmark, variability between days, etc."
            }, {
              "id": "unit",
              "label": "Unit",
              "type": "text",
              "description": "Unit of the parameter"
            }, {
              "id": "minValue",
              "label": "Value min",
              "type": "text",
              "description": "Numerical value of the minimum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "unitCategory",
              "label": "Unit category",
              "type": "text",
              "description": "General classification of the parameter unit"
            }, {
              "id": "name",
              "label": "Parameter name",
              "type": "text",
              "description": "A name given to the parameter"
            }, {
              "id": "id",
              "label": "Parameter ID",
              "type": "text",
              "description": "An unambiguous ID given to each of the parameters - preferably autogenerated by a software tool and compatible with SBML ID requirements, only letters from A to Z, numbers and '_'"
            }, {
              "id": "value",
              "label": "Value",
              "type": "text",
              "description": "A default value for the parameter. This is mandatory (needs to be provided) for all parameters of type 'Input'"
            }]
          },
          "qualityMeasures": [{
            "id": "rsquared",
            "label": "R squared",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sse",
            "label": "SSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "rmse",
            "label": "RMSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "aic",
            "label": "AIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sensitivityAnalysis",
            "label": "Sensitivity analysis",
            "type": "long-text",
            "description": "Description of the results of an sensitivity analysis, i.e. how independence assumptions are met or how variables will affect the output of model"
          }, {
            "id": "bic",
            "label": "BIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "mse",
            "label": "MSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }],
          "modelMath": [{
            "id": "fittingProcedure",
            "label": "Fitting procedure",
            "type": "text",
            "description": "Procedure used to fit the data to the model equation"
          }, {
            "id": "event",
            "label": "Event",
            "description": "Definition of time-dependent parameter changes"
          }]
        },
        "scope": {
          "populationGroup": [{
            "id": "populationRiskFactor",
            "label": "Risk and population factors",
            "description": "Population risk factor that may influence the outcomes of the study, confounder should be included"
          }, {
            "id": "country",
            "label": "Country",
            "description": "Country on which the population group of the model or data applies"
          }, {
            "id": "populationSpan",
            "label": "Population span (years)",
            "description": "Temporal information on the exposure duration"
          }, {
            "id": "populationGender",
            "label": "Population gender",
            "type": "text",
            "description": "Description of the percentage of gender"
          }, {
            "id": "populationDescription",
            "label": "Description",
            "description": "Description of the population for which the model applies (demographic and socio-economic characteristics for example). Background information that are needed in the data analysis phase, size of household, education level, employment status, professional category, ethnicity, etc."
          }, {
            "id": "populationAge",
            "label": "Population age",
            "description": "Description of the range of age or group of age"
          }, {
            "id": "patternConsumption",
            "label": "Consumption pattern",
            "description": "Description of the consumption of different food items, frequency, portion size"
          }, {
            "id": "name",
            "label": "Population name",
            "type": "text",
            "description": "Name of the population for which the model or data applies"
          }, {
            "id": "season",
            "label": "Season",
            "description": "Distribution of surveyed people according to the season (influence consumption pattern)"
          }, {
            "id": "region",
            "label": "Region",
            "description": "Spatial information (area) on which the population group of the model or data applies"
          }, {
            "id": "targetPopulation",
            "label": "Target population",
            "type": "text",
            "description": "Population of individual that we are interested in describing and making statistical inferences about"
          }, {
            "id": "bmi",
            "label": "BMI",
            "description": "Description of the range of BMI or class of BMI or BMI mean"
          }, {
            "id": "specialDietGroups",
            "label": "Special diet groups",
            "description": "Description of sub-population with special diets (vegetarians, diabetics, group following special ethnic diets)"
          }],
          "hazard": [{
            "id": "maximumResidueLimit",
            "label": "Maximum Residue Limit (MRL)",
            "type": "text",
            "description": "International regulations and permissible maximum residue levels in food and drinking water"
          }, {
            "id": "sourceOfContamination",
            "label": "Source of contamination",
            "type": "text",
            "description": "rigin of the contamination, source"
          }, {
            "id": "indSum",
            "label": "Individual or Summed Hazard",
            "type": "text",
            "description": "Define if the parameter reported is an individual residue/analyte, a summed residue definition or part of a sum a summed residue definition"
          }, {
            "id": "acceptableOperatorsExposureLevel",
            "label": "Acceptable Operator Exposure Level (AOEL)",
            "type": "text",
            "description": "Maximum amount of active substance to which the operator may be exposed without any adverse health effects. The AOEL is expressed as milligrams of the chemical per kilogram body weight of the operator"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Description of the hazard for which the model or data applies"
          }, {
            "id": "type",
            "label": "Hazard type",
            "type": "text",
            "description": "General classification of the hazard for which the model or data applies"
          }, {
            "id": "adverseEffect",
            "label": "Adverse effect",
            "type": "text",
            "description": "Adverse effect induced by hazard about morbidity, mortality, and etcetera"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the hazard for which the model or data applies"
          }, {
            "id": "noObservedAdverseAffectLevel",
            "label": "No Observed Adverse Affect Level (NOAEL)",
            "type": "text",
            "description": "Level of exposure of an organism, found by experiment or observation, at which there is no biologically or statistically significant increase in the frequency or severity of any adverse effects in the exposed population when compared to its appropriate control"
          }, {
            "id": "acuteReferenceDose",
            "label": "Acute Reference Dose (ARfD)",
            "type": "text",
            "description": "An estimate (with uncertainty spanning perhaps an order of magnitude) of a daily oral exposure for an acute duration (24 hours or less) to the human population (including sensitive subgroups) that is likely to be without an appreciable risk of deleterious effects during a lifetime"
          }, {
            "id": "name",
            "label": "Hazard name",
            "type": "text",
            "description": "Name of the hazard (agent, contaminant, chemical) for which the data or model applies"
          }, {
            "id": "lowestObservedAdverseAffectLevel",
            "label": "Lowest Observed Adverse Effect Level (LOAEL)",
            "type": "text",
            "description": "Lowest concentration or amount of a substance found by experiment or observation that causes an adverse alteration of morphology, function, capacity, growth, development, or lifespan of a target organism distinguished from normal organisms of the same species under defined conditions of exposure"
          }, {
            "id": "benchmarkDose",
            "label": "Benchmark Dose (BMD)",
            "type": "text",
            "description": "A dose or concentration that produces a predetermined change in response rate of an adverse effect (called the benchmark response or BMR) compared to background"
          }, {
            "id": "acceptableDailyIntake",
            "label": "Acceptable Daily Intake (ADI)",
            "type": "text",
            "description": "Measure of amount of a specific substance in food or in drinking water tahta can be ingested (orally) on a daily basis over a lifetime without an appreciable health risk"
          }],
          "scope": [{
            "id": "spatialInformation",
            "label": "Spatial information",
            "description": "Spatial information (area) on which the model or data applies"
          }, {
            "id": "generalComment",
            "label": "General comment",
            "type": "long-text",
            "description": "General comments on the scope of the study, data or model"
          }, {
            "id": "temporalInformation",
            "label": "Temporal information",
            "type": "long-text",
            "description": "Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)"
          }]
        },
        "generalInformation": {
          "creator": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "author": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "reference": [{
            "id": "date",
            "label": "Date",
            "type": "year_date",
            "description": "Temporal information on the publication date"
          }, {
            "id": "website",
            "label": "Website",
            "type": "text",
            "description": "A link to the publication website (different from DOI)"
          }, {
            "id": "issue",
            "label": "Issue",
            "type": "text",
            "description": "Data on the details of the issue in which the model or date has been described"
          }, {
            "id": "publicationType",
            "label": "Publication type",
            "type": "text",
            "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
          }, {
            "id": "abstract",
            "label": "Abstract",
            "type": "text",
            "description": "Abstract of the publication in which the model or the data has been described "
          }, {
            "id": "isReferenceDescription",
            "label": "Is_reference_description?",
            "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
          }, {
            "id": "title",
            "label": "Title",
            "type": "long-text",
            "description": "Title of publication in which the model or date has been described"
          }, {
            "id": "pmid",
            "label": "PubMed ID",
            "type": "text",
            "description": "The PubMed ID related to this publication"
          }, {
            "id": "volume",
            "label": "Volume",
            "type": "text",
            "description": "Data on the details of the volume in which the model or date has been described"
          }, {
            "id": "journal",
            "label": "Journal",
            "type": "long-text",
            "description": "Data on the details of the journal in which the model or date has been described"
          }, {
            "id": "authorList",
            "label": "Author list",
            "type": "long-text",
            "description": "Name and surname of the authors who contributed to this publication"
          }, {
            "id": "comment",
            "label": "Comment",
            "type": "long-text",
            "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
          }, {
            "id": "doi",
            "label": "Publication DOI",
            "type": "long-text",
            "description": "The DOI related to this publication"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The status of this publication, e.g. Published, Submitted, etc."
          }],
          "modelCategory": [{
            "id": "modelClassComment",
            "label": "Comment",
            "type": "long-text",
            "description": "Comment with further details on the model class"
          }, {
            "id": "basicProcess",
            "label": "Basic process",
            "description": "Defines the impact of the process on the hazard (so far only valid for process models and predictive models)"
          }, {
            "id": "modelClass",
            "label": "Model class",
            "type": "text",
            "description": "Type of model according to RAKIP classification"
          }, {
            "id": "modelSubClass",
            "label": "Subclass",
            "description": "Sub-classification of the model given the Model Class"
          }],
          "generalInformation": [{
            "id": "identifier",
            "label": "Identifier",
            "type": "text",
            "description": "An unambiguous ID given to the model or data. This can also be created automatically by a software tool"
          }, {
            "id": "software",
            "label": "Software",
            "type": "text",
            "description": "The program or software language in which the model has been implemented"
          }, {
            "id": "format",
            "label": "Format",
            "type": "text",
            "description": "File extension of the model or data file (including version number of format if applicable)"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the study, data or model"
          }, {
            "id": "language",
            "label": "Language",
            "type": "text",
            "description": "A language of the resource (some data or reports can be available in French language for example)"
          }, {
            "id": "source",
            "label": "Source",
            "type": "text",
            "description": "A source from which the model/data is derived"
          }, {
            "id": "availability",
            "label": "Availability",
            "type": "text",
            "description": "Availability of data or model, i.e. if the annotated model code / data is included in this FSK file"
          }, {
            "id": "creationDate",
            "label": "Creation date",
            "type": "date",
            "description": "Creation date/time of the FSK file"
          }, {
            "id": "url",
            "label": "URL",
            "type": "text",
            "description": "Web address referencing the resource location (data for example)"
          }, {
            "id": "objective",
            "label": "Objective",
            "type": "long-text",
            "description": "Objective of the model or data"
          }, {
            "id": "modificationDate",
            "label": "Modification date",
            "description": "Date/time of the last version of the FSK file"
          }, {
            "id": "rights",
            "label": "Rights",
            "type": "text",
            "description": "Rights granted for usage, distribution and modification of this FSK file"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "A name given to the model or data"
          }, {
            "id": "languageWrittenIn",
            "label": "Language written in",
            "type": "text",
            "description": "Software language used to write the model, e.g. R or MatLab"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The curation status of the model"
          }]
        }
      };
    }
    // Validate this.panels and return boolean
  }, {
    key: "validate",
    value: function validate() {
      var isValid = true;
      if (!this.panels.generalInformation.validate()) isValid = false;
      if (!this.panels.modelCategory.validate()) isValid = false;
      if (!this.panels.scopeGeneral.validate()) isValid = false;
      if (!this.panels.study.validate()) isValid = false;
      return isValid;
    }
  }, {
    key: "_createPanels",
    value: function _createPanels() {
      var port = window.port || -1;
      var schema = schemas.genericModel;
      return _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
        study: new _FormPanel.FormPanel("Study", this.jsonSchema.dataBackground.study, this._metadata.dataBackground ? this._metadata.dataBackground.study : {}, port),
        laboratory: new _TablePanel.TablePanel("Laboratory", this.jsonSchema.dataBackground.laboratory, this._metadata.dataBackground ? this._metadata.dataBackground.laboratory : {}, port),
        assay: new _TablePanel.TablePanel("Assay", this.jsonSchema.dataBackground.assay, this._metadata.dataBackground ? this._metadata.dataBackground.assay : {}, port),
        studySample: new _TablePanel.TablePanel("Study Sample", this.jsonSchema.dataBackground.studySample, this._metadata.dataBackground ? this._metadata.dataBackground.studySample : {}, port),
        modelMath: new _FormPanel.FormPanel("Model Math", this.jsonSchema.modelMath.modelMath, this._metadata.modelMath, port),
        modelEquation: new _TablePanel.TablePanel("Model Equation", this.jsonSchema.modelMath.modelEquation.modelEquation, this._metadata.modelMath ? this._metadata.modelMath.modelEquation : {}, port),
        reference: new _TablePanel.TablePanel("Reference", this.jsonSchema.modelMath.modelEquation.reference, this._metadata.modelMath.modelEquation ? this._metadata.modelMath.modelEquation.reference : {}, port),
        exposure: new _FormPanel.FormPanel("Exposure", this.jsonSchema.modelMath.exposure, this._metadata.modelMath ? this._metadata.modelMath.exposure : {}, port),
        parameter: new _TablePanel.TablePanel("Parameter", this.jsonSchema.modelMath.parameter.parameter, this._metadata.modelMath ? this._metadata.modelMath.parameter : {}, port)
      }, "reference", new _FormPanel.FormPanel("Reference", this.jsonSchema.modelMath.parameter.reference, this._metadata.modelMath.parameter ? this._metadata.modelMath.parameter.reference : {}, port)), "qualityMeasures", new _TablePanel.TablePanel("Quality Measures", this.jsonSchema.modelMath.qualityMeasures, this._metadata.modelMath ? this._metadata.modelMath.qualityMeasures : {}, port)), "scope", new _FormPanel.FormPanel("Scope", this.jsonSchema.scope.scope, this._metadata.scope, port)), "populationGroup", new _TablePanel.TablePanel("Population Group", this.jsonSchema.scope.populationGroup, this._metadata.scope ? this._metadata.scope.populationGroup : {}, port)), "hazard", new _TablePanel.TablePanel("Hazard", this.jsonSchema.scope.hazard, this._metadata.scope ? this._metadata.scope.hazard : {}, port)), "generalInformation", new _FormPanel.FormPanel("General Information", this.jsonSchema.generalInformation.generalInformation, this._metadata.generalInformation, port)), "creator", new _TablePanel.TablePanel("Creator", this.jsonSchema.generalInformation.creator, this._metadata.generalInformation ? this._metadata.generalInformation.creator : {}, port)), "author", new _TablePanel.TablePanel("Author", this.jsonSchema.generalInformation.author, this._metadata.generalInformation ? this._metadata.generalInformation.author : {}, port)), "reference", new _TablePanel.TablePanel("Reference", this.jsonSchema.generalInformation.reference, this._metadata.generalInformation ? this._metadata.generalInformation.reference : {}, port)), "modelCategory", new _FormPanel.FormPanel("Model Category", this.jsonSchema.generalInformation.modelCategory, this._metadata.generalInformation ? this._metadata.generalInformation.modelCategory : {}, port));
    }
  }]);
}(_ModelView2.ModelView);

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./DoseResponseModelGeneralInformationView":83,"./DoseResponseModelModelMathView":85,"./DoseResponseModelScopeView":87,"./ModelView":118,"./PredictiveModelDataBackgroundView":135}],89:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Exposure = void 0;
var _ApiClient = require("../ApiClient");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Exposure model module.
 * @module model/Exposure
 * @version 1.0.0
 */
var Exposure = exports.Exposure = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>Exposure</code>.
   * @alias module:model/Exposure
   * @class
   * @param type {} Description of the type of exposure
   */
  function Exposure(type) {
    _classCallCheck(this, Exposure);
    this.type = type;
  }

  /**
   * Constructs a <code>Exposure</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/Exposure} obj Optional instance to populate.
   * @return {module:model/Exposure} The populated <code>Exposure</code> instance.
   */
  return _createClass(Exposure, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new Exposure();
        if (data.hasOwnProperty('treatment')) obj.treatment = _ApiClient.ApiClient.convertToType(data['treatment'], ['String']);
        if (data.hasOwnProperty('scenario')) obj.scenario = _ApiClient.ApiClient.convertToType(data['scenario'], ['String']);
        if (data.hasOwnProperty('uncertaintyEstimation')) obj.uncertaintyEstimation = _ApiClient.ApiClient.convertToType(data['uncertaintyEstimation'], 'String');
        if (data.hasOwnProperty('type')) obj.type = _ApiClient.ApiClient.convertToType(data['type'], 'String');
        if (data.hasOwnProperty('contamination')) obj.contamination = _ApiClient.ApiClient.convertToType(data['contamination'], ['String']);
      }
      return obj;
    }
  }]);
}();
/**
 * Description of the mathematical method to replace left-censored data (recommandation of WHO (2013), distribution or others)
 * @member {Array.<String>} treatment
 */
Exposure.prototype.treatment = undefined;

/**
 * Description of the different scenarios of exposure assessment
 * @member {Array.<String>} scenario
 */
Exposure.prototype.scenario = undefined;

/**
 * Analysis to estimate uncertainty
 * @member {String} uncertaintyEstimation
 */
Exposure.prototype.uncertaintyEstimation = undefined;

/**
 * Description of the type of exposure
 * @member {String} type
 */
Exposure.prototype.type = undefined;

/**
 * Description of the range of of the level of contamination after left censored data treatment
 * @member {Array.<String>} contamination
 */
Exposure.prototype.contamination = undefined;

},{"../ApiClient":44}],90:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExposureModel = void 0;
var _ApiClient = require("../ApiClient");
var _ExposureModelScope = require("./ExposureModelScope");
var _GenericModelDataBackground = require("./GenericModelDataBackground");
var _GenericModelModelMath = require("./GenericModelModelMath");
var _Model2 = require("./Model");
var _PredictiveModelGeneralInformation = require("./PredictiveModelGeneralInformation");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ExposureModel model module.
 * @module model/ExposureModel
 * @version 1.0.0
 */
var ExposureModel = exports.ExposureModel = /*#__PURE__*/function (_Model) {
  /**
   * Constructs a new <code>ExposureModel</code>.
   * @alias module:model/ExposureModel
   * @class
   * @extends module:model/Model
   * @param modelType {} 
   */
  function ExposureModel(modelType) {
    _classCallCheck(this, ExposureModel);
    return _callSuper(this, ExposureModel, [modelType]);
  }

  /**
   * Constructs a <code>ExposureModel</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/ExposureModel} obj Optional instance to populate.
   * @return {module:model/ExposureModel} The populated <code>ExposureModel</code> instance.
   */
  _inherits(ExposureModel, _Model);
  return _createClass(ExposureModel, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new ExposureModel();
        _Model2.Model.constructFromObject(data, obj);
        if (data.hasOwnProperty('dataBackground')) obj.dataBackground = _GenericModelDataBackground.GenericModelDataBackground.constructFromObject(data['dataBackground']);
        if (data.hasOwnProperty('modelMath')) obj.modelMath = _GenericModelModelMath.GenericModelModelMath.constructFromObject(data['modelMath']);
        if (data.hasOwnProperty('scope')) obj.scope = _ExposureModelScope.ExposureModelScope.constructFromObject(data['scope']);
        if (data.hasOwnProperty('generalInformation')) obj.generalInformation = _PredictiveModelGeneralInformation.PredictiveModelGeneralInformation.constructFromObject(data['generalInformation']);
      }
      return obj;
    }
  }]);
}(_Model2.Model);
/**
 * @member {module:model/GenericModelDataBackground} dataBackground
 */
ExposureModel.prototype.dataBackground = undefined;

/**
 * @member {module:model/GenericModelModelMath} modelMath
 */
ExposureModel.prototype.modelMath = undefined;

/**
 * @member {module:model/ExposureModelScope} scope
 */
ExposureModel.prototype.scope = undefined;

/**
 * @member {module:model/PredictiveModelGeneralInformation} generalInformation
 */
ExposureModel.prototype.generalInformation = undefined;

},{"../ApiClient":44,"./ExposureModelScope":91,"./GenericModelDataBackground":96,"./GenericModelModelMath":100,"./Model":113,"./PredictiveModelGeneralInformation":136}],91:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExposureModelScope = void 0;
var _ApiClient = require("../ApiClient");
var _Hazard = require("./Hazard");
var _PopulationGroup = require("./PopulationGroup");
var _Product = require("./Product");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ExposureModelScope model module.
 * @module model/ExposureModelScope
 * @version 1.0.0
 */
var ExposureModelScope = exports.ExposureModelScope = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>ExposureModelScope</code>.
   * @alias module:model/ExposureModelScope
   * @class
   * @param product {} 
   * @param populationGroup {} 
   * @param hazard {} 
   */
  function ExposureModelScope(productpopulationGrouphazard) {
    _classCallCheck(this, ExposureModelScope);
    this.product = product;
    this.populationGroup = populationGroup;
    this.hazard = hazard;
  }

  /**
   * Constructs a <code>ExposureModelScope</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/ExposureModelScope} obj Optional instance to populate.
   * @return {module:model/ExposureModelScope} The populated <code>ExposureModelScope</code> instance.
   */
  return _createClass(ExposureModelScope, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new ExposureModelScope();
        if (data.hasOwnProperty('spatialInformation')) obj.spatialInformation = _ApiClient.ApiClient.convertToType(data['spatialInformation'], ['String']);
        if (data.hasOwnProperty('product')) obj.product = _ApiClient.ApiClient.convertToType(data['product'], [_Product.Product]);
        if (data.hasOwnProperty('populationGroup')) obj.populationGroup = _ApiClient.ApiClient.convertToType(data['populationGroup'], [_PopulationGroup.PopulationGroup]);
        if (data.hasOwnProperty('hazard')) obj.hazard = _ApiClient.ApiClient.convertToType(data['hazard'], [_Hazard.Hazard]);
        if (data.hasOwnProperty('generalComment')) obj.generalComment = _ApiClient.ApiClient.convertToType(data['generalComment'], 'String');
        if (data.hasOwnProperty('temporalInformation')) obj.temporalInformation = _ApiClient.ApiClient.convertToType(data['temporalInformation'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * Spatial information (area) on which the model or data applies
 * @member {Array.<String>} spatialInformation
 */
ExposureModelScope.prototype.spatialInformation = undefined;

/**
 * @member {Array.<module:model/Product>} product
 */
ExposureModelScope.prototype.product = undefined;

/**
 * @member {Array.<module:model/PopulationGroup>} populationGroup
 */
ExposureModelScope.prototype.populationGroup = undefined;

/**
 * @member {Array.<module:model/Hazard>} hazard
 */
ExposureModelScope.prototype.hazard = undefined;

/**
 * General comments on the scope of the study, data or model
 * @member {String} generalComment
 */
ExposureModelScope.prototype.generalComment = undefined;

/**
 * Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)
 * @member {String} temporalInformation
 */
ExposureModelScope.prototype.temporalInformation = undefined;

},{"../ApiClient":44,"./Hazard":105,"./PopulationGroup":131,"./Product":149}],92:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExposureModelScopeView = void 0;
var _ApiClient = require("../ApiClient");
var _HazardView = require("./HazardView");
var _PopulationGroupView = require("./PopulationGroupView");
var _ProductView = require("./ProductView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ExposureModelScope View  module.
 * @module model/ExposureModelScope
 * @version 1.0.0
 */
var ExposureModelScopeView = exports.ExposureModelScopeView = /*#__PURE__*/_createClass(function ExposureModelScopeView() {
  _classCallCheck(this, ExposureModelScopeView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./HazardView":106,"./PopulationGroupView":132,"./ProductView":150}],93:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExposureModelView = void 0;
var _ApiClient = require("../ApiClient");
var _ExposureModelScopeView = require("./ExposureModelScopeView");
var _GenericModelDataBackgroundView = require("./GenericModelDataBackgroundView");
var _GenericModelModelMathView = require("./GenericModelModelMathView");
var _ModelView2 = require("./ModelView");
var _PredictiveModelGeneralInformationView = require("./PredictiveModelGeneralInformationView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ExposureModel View  module.
 * @module model/ExposureModel
 * @version 1.0.0
 */
var ExposureModelView = exports.ExposureModelView = /*#__PURE__*/function (_ModelView) {
  function ExposureModelView(metadata, img, state, modelScript, visScript, readme) {
    var _this$_panels;
    var _this;
    _classCallCheck(this, ExposureModelView);
    _this = _callSuper(this, ExposureModelView, [metadata, img, modelScript, visScript, readme]);
    _this._schema = schemas.genericModel;
    if (state) {
      _this.panels = _this._createPanels();
    }
    _this._menu = [{
      "label": "General Information",
      "id": "generalInformation",
      "submenus": [{
        "label": "General Information",
        "id": "generalInformation"
      }, {
        "label": "Model Category",
        "id": "modelCategory"
      }, {
        "label": "Reference",
        "id": "reference"
      }, {
        "label": "Author",
        "id": "author"
      }, {
        "label": "Creator",
        "id": "creator"
      }]
    }, {
      "label": "Scope",
      "id": "scope",
      "submenus": [{
        "label": "Scope",
        "id": "scope"
      }, {
        "label": "Hazard",
        "id": "hazard"
      }, {
        "label": "Population Group",
        "id": "populationGroup"
      }, {
        "label": "Product",
        "id": "product"
      }]
    }, {
      "label": "Model Math",
      "id": "modelMath",
      "submenus": [{
        "label": "Model Math",
        "id": "modelMath"
      }, {
        "label": "Quality Measures",
        "id": "qualityMeasures"
      }, {
        "label": "Parameter",
        "id": "parameter",
        "submenus": [{
          "label": "Parameter",
          "id": "parameter"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }, {
        "label": "Exposure",
        "id": "exposure"
      }, {
        "label": "Model Equation",
        "id": "modelEquation",
        "submenus": [{
          "label": "Model Equation",
          "id": "modelEquation"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }]
    }, {
      "label": "Data Background",
      "id": "dataBackground",
      "submenus": [{
        "label": "Study Sample",
        "id": "studySample"
      }, {
        "label": "Dietary Assessment Method",
        "id": "dietaryAssessmentMethod"
      }, {
        "label": "Assay",
        "id": "assay"
      }, {
        "label": "Laboratory",
        "id": "laboratory"
      }, {
        "label": "Study",
        "id": "study"
      }]
    }];
    _this._panels = (_this$_panels = {
      study: {
        type: 'simple',
        schema: _this.jsonSchema.dataBackgroundstudy,
        metadata: _this._metadata.study
      },
      laboratory: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundlaboratory,
        metadata: _this._metadata.laboratory
      },
      assay: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundassay,
        metadata: _this._metadata.assay
      },
      dietaryAssessmentMethod: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgrounddietaryAssessmentMethod,
        metadata: _this._metadata.dietaryAssessmentMethod
      },
      studySample: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundstudySample,
        metadata: _this._metadata.studySample
      },
      modelMath: {
        type: 'simple',
        schema: _this.jsonSchema.modelMathmodelMath,
        metadata: _this._metadata.modelMath
      },
      modelEquation: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationmodelEquation,
        metadata: _this._metadata.modelEquation
      },
      reference: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationreference,
        metadata: _this._metadata.reference
      },
      exposure: {
        type: 'complex',
        schema: _this.jsonSchema.modelMathexposure,
        metadata: _this._metadata.exposure
      },
      parameter: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.parameterparameter,
        metadata: _this._metadata.parameter
      }
    }, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_this$_panels, "reference", {
      type: 'simple',
      schema: _this.jsonSchema.modelMath.parameterreference,
      metadata: _this._metadata.reference
    }), "qualityMeasures", {
      type: 'complex',
      schema: _this.jsonSchema.modelMathqualityMeasures,
      metadata: _this._metadata.qualityMeasures
    }), "scope", {
      type: 'simple',
      schema: _this.jsonSchema.scopescope,
      metadata: _this._metadata.scope
    }), "product", {
      type: 'complex',
      schema: _this.jsonSchema.scopeproduct,
      metadata: _this._metadata.product
    }), "populationGroup", {
      type: 'complex',
      schema: _this.jsonSchema.scopepopulationGroup,
      metadata: _this._metadata.populationGroup
    }), "hazard", {
      type: 'complex',
      schema: _this.jsonSchema.scopehazard,
      metadata: _this._metadata.hazard
    }), "generalInformation", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationgeneralInformation,
      metadata: _this._metadata.generalInformation
    }), "creator", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationcreator,
      metadata: _this._metadata.creator
    }), "author", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationauthor,
      metadata: _this._metadata.author
    }), "reference", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationreference,
      metadata: _this._metadata.reference
    }), _defineProperty(_this$_panels, "modelCategory", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationmodelCategory,
      metadata: _this._metadata.modelCategory
    }));
    return _this;
  }
  _inherits(ExposureModelView, _ModelView);
  return _createClass(ExposureModelView, [{
    key: "metaData",
    get: function get() {
      try {
        this._metadata.dataBackground.study = this.panels.study.data;
        this._metadata.dataBackground.laboratory = this.panels.laboratory.data;
        this._metadata.dataBackground.assay = this.panels.assay.data;
        this._metadata.dataBackground.dietaryAssessmentMethod = this.panels.dietaryAssessmentMethod.data;
        this._metadata.dataBackground.studySample = this.panels.studySample.data;
        this._metadata.modelMath = this.panels.modelMath.data;
        this._metadata.modelMath.modelEquation = this.panels.modelEquation.data;
        this._metadata.modelMath.modelEquation.reference = this.panels.reference.data;
        this._metadata.modelMath.exposure = this.panels.exposure.data;
        this._metadata.modelMath.parameter = this.panels.parameter.data;
        this._metadata.modelMath.parameter.reference = this.panels.reference.data;
        this._metadata.modelMath.qualityMeasures = this.panels.qualityMeasures.data;
        this._metadata.scope = this.panels.scope.data;
        this._metadata.scope.product = this.panels.product.data;
        this._metadata.scope.populationGroup = this.panels.populationGroup.data;
        this._metadata.scope.hazard = this.panels.hazard.data;
        this._metadata.generalInformation = this.panels.generalInformation.data;
        this._metadata.generalInformation.creator = this.panels.creator.data;
        this._metadata.generalInformation.author = this.panels.author.data;
        this._metadata.generalInformation.reference = this.panels.reference.data;
        this._metadata.generalInformation.modelCategory = this.panels.modelCategory.data;
        this._metadata.modelType = "ExposureModel";
        this._metadata = metadataFix(this._metadata);
      } catch (error) {
        console.log(error);
      }
      return this._metadata;
    }
  }, {
    key: "jsonSchema",
    get: function get() {
      return {
        "dataBackground": {
          "study": [{
            "id": "identifier",
            "label": "Study identifier",
            "type": "text",
            "description": "A user defined identifier for the study"
          }, {
            "id": "protocolComponentsName",
            "label": "Components names",
            "type": "text",
            "description": "The names of the components used when carrying out this protocol"
          }, {
            "id": "designType",
            "label": "Design type",
            "type": "text",
            "description": "The type of study design being employed"
          }, {
            "id": "assayMeasurementType",
            "label": "Assay measurement type",
            "type": "text",
            "description": "The measurement being observed in this assay"
          }, {
            "id": "protocolComponentsType",
            "label": "Protocol components type",
            "type": "text",
            "description": "Description"
          }, {
            "id": "description",
            "label": "Study description",
            "type": "long-text",
            "description": "A brief description of the study aims"
          }, {
            "id": "assayTechnologyPlatform",
            "label": "Assay technology platform",
            "type": "text",
            "description": "The technology platform used"
          }, {
            "id": "assayTechnologyType",
            "label": "Assay technology type",
            "type": "text",
            "description": "The technology being employed to observe this measurement"
          }, {
            "id": "protocolType",
            "label": "Protocol type",
            "type": "text",
            "description": "The type of the protocol, preferably coming from an Ontology, e.g. Extraction Protocol"
          }, {
            "id": "title",
            "label": "Study title",
            "type": "long-text",
            "description": "A title for the study"
          }, {
            "id": "protocolDescription",
            "label": "Protocol description",
            "type": "long-text",
            "description": "A description of the protocol"
          }, {
            "id": "protocolParametersName",
            "label": "Parameters names",
            "type": "text",
            "description": "The parameters used when executing this protocol"
          }, {
            "id": "protocolName",
            "label": "Protocol name",
            "type": "text",
            "description": "The name of the protocol, e.g.Extraction Protocol"
          }, {
            "id": "protocolVersion",
            "label": "Protocol version",
            "type": "text",
            "description": "The version of the protocol used, where applicable."
          }, {
            "id": "protocolURI",
            "label": "Protocol URI",
            "type": "text",
            "description": "A URI to link out to a publication, web page, etc. describing the protocol"
          }, {
            "id": "accreditationProcedureForTheAssayTechnology",
            "label": "Accreditation procedure for assay",
            "type": "text",
            "description": "Accreditation procedure for the analytical method used"
          }],
          "laboratory": [{
            "id": "country",
            "label": "Laboratory country",
            "type": "text",
            "description": "Country where the laboratory is placed. (ISO 3166-1-alpha-2)"
          }, {
            "id": "name",
            "label": "Laboratory name",
            "type": "text",
            "description": "Laboratory code (National laboratory code if available) or Laboratory name "
          }, {
            "id": "accreditation",
            "label": "Laboratory accreditation",
            "description": "The laboratory accreditation to ISO/IEC 17025"
          }],
          "assay": [{
            "id": "contaminationRange",
            "label": "Range of contamination",
            "type": "text",
            "description": "Range of result of the analytical measure reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "uncertaintyValue",
            "label": "Uncertainty value",
            "type": "text",
            "description": "Indicate the expanded uncertainty (usually 95% confidence interval) value associated with the measurement expressed in the unit reported in the field Hazard unit"
          }, {
            "id": "fatPercentage",
            "label": "Percentage of fat",
            "type": "text",
            "description": "Percentage of fat in the original sample"
          }, {
            "id": "name",
            "label": "Assay name",
            "type": "text",
            "description": "A name given to the assay"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the assay. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "moisturePercentage",
            "label": "Percentage of moisture",
            "type": "text",
            "description": "Percentage of moisture in the original sample"
          }, {
            "id": "leftCensoredData",
            "label": "Left-censored data",
            "type": "text",
            "description": "Percentage of measures equal to LOQ and/or LOD"
          }, {
            "id": "detectionLimit",
            "label": "Limit of detection",
            "type": "text",
            "description": "Limit of detection reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "quantificationLimit",
            "label": "Limit of quantification",
            "type": "text",
            "description": "Limit of quantification reported in the unit specified by the variable Hazard unit"
          }],
          "dietaryAssessmentMethod": [{
            "id": "recordTypes",
            "label": "Type of records",
            "description": "Consumption occasion, mean of consumption, quantified and described as eaten, recipes for self-made"
          }, {
            "id": "numberOfFoodItems",
            "label": "Number of food items",
            "description": "Number of food items"
          }, {
            "id": "numberOfNonConsecutiveOneDay",
            "label": "Number of non-consecutive one-day",
            "type": "text",
            "description": "Number of non-consecutive one-day recorded"
          }, {
            "id": "softwareTool",
            "label": "Dietary software tool",
            "type": "text",
            "description": "Name of the software used to collect the data"
          }, {
            "id": "foodDescriptors",
            "label": "Food descriptors",
            "description": "Description using FoodEx2 facet"
          }, {
            "id": "collectionTool",
            "label": "Methodological tool to collect data",
            "type": "text",
            "description": "Food diaries, interview, 24-hour recall interview, food propensy questionnaire, portion size measurement aids, eating outside questionnaire"
          }],
          "studySample": [{
            "id": "sampleName",
            "label": "Name",
            "type": "text",
            "description": "An unambiguous ID given to the samples used in the assay"
          }, {
            "id": "samplingWeight",
            "label": "Sampling weight",
            "type": "text",
            "description": "Description of the method employed to compute sampling weight (nonresponse-adjusted weight)"
          }, {
            "id": "protocolOfSampleCollection",
            "label": "Protocol of sample collection",
            "type": "text",
            "description": "Additional protocol for sample and sample collection. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "samplingStrategy",
            "label": "Sampling strategy",
            "type": "text",
            "description": "Sampling strategy (ref. EUROSTAT - Typology of sampling strategy, version of July 2009)"
          }, {
            "id": "samplingSize",
            "label": "Sampling size",
            "type": "text",
            "description": "Number of units, full participants, partial participants, eligibles, not eligible, unresolved (eligibility status not resolved)"
          }, {
            "id": "lotSizeUnit",
            "label": "Lot size unit",
            "type": "text",
            "description": "Unit in which the lot size is expressed"
          }, {
            "id": "samplingPoint",
            "label": "Sampling point",
            "type": "text",
            "description": "Point in the food chain where the sample was taken. (Doc. ESTAT/F5/ES/155 Data dictionary of activities of the establishments)"
          }, {
            "id": "samplingMethod",
            "label": "Sampling method",
            "type": "text",
            "description": "Sampling method used to take the sample"
          }, {
            "id": "typeOfSamplingProgram",
            "label": "Type of sampling program",
            "type": "text",
            "description": "Indicate the type of programm for which the samples have been collected"
          }, {
            "id": "samplingPlan",
            "label": "Sampling plan",
            "type": "text",
            "description": "Description of data collection technique: stratified or complex sampling (several stages)"
          }]
        },
        "modelMath": {
          "modelEquation": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "modelEquation": [{
              "id": "modelEquation",
              "label": "Equation",
              "type": "text",
              "description": "The pointer to the file that holds the software code (e.g. R-script)"
            }, {
              "id": "name",
              "label": "Model equation name",
              "type": "text",
              "description": "A name given to the model equation"
            }, {
              "id": "modelHypothesis",
              "label": "Hypothesis of the model",
              "description": "Description of the hypothesis of the model"
            }, {
              "id": "modelEquationClass",
              "label": "Model equation class",
              "type": "text",
              "description": "Information on that helps to categorize model equations"
            }]
          },
          "exposure": [{
            "id": "treatment",
            "label": "Left-censored data treatment",
            "description": "Description of the mathematical method to replace left-censored data (recommandation of WHO (2013), distribution or others)"
          }, {
            "id": "scenario",
            "label": "Scenario",
            "description": "Description of the different scenarios of exposure assessment"
          }, {
            "id": "uncertaintyEstimation",
            "label": "Uncertainty estimation",
            "type": "text",
            "description": "Analysis to estimate uncertainty"
          }, {
            "id": "type",
            "label": "Type of exposure",
            "type": "text",
            "description": "Description of the type of exposure"
          }, {
            "id": "contamination",
            "label": "Contam level post data treatment",
            "description": "Description of the range of of the level of contamination after left censored data treatment"
          }],
          "parameter": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "parameter": [{
              "id": "subject",
              "label": "Parameter subject",
              "type": "text",
              "description": "Scope of the parameter, e.g. if it refers to an animal, a batch of animals, a batch of products, a carcass, a carcass skin etc"
            }, {
              "id": "maxValue",
              "label": "Value max",
              "type": "text",
              "description": "Numerical value of the maximum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "dataType",
              "label": "Data type",
              "type": "text",
              "description": "Information on the data format of the parameter, e.g. if it is a categorical variable: int, double, array of size x,y,z "
            }, {
              "id": "description",
              "label": "Description",
              "type": "text",
              "description": "General description of the parameter"
            }, {
              "id": "source",
              "label": "Parameter source",
              "type": "text",
              "description": "Information on the type of knowledge used to define the parameter value"
            }, {
              "id": "classification",
              "label": "Parameter classification",
              "type": "text",
              "description": "General classification of the parameter (e.g. Input, Constant, Output etc)"
            }, {
              "id": "distribution",
              "label": "Parameter distribution",
              "type": "text",
              "description": "Distribution describing the parameter variabilty. If no distribution selected this means the value provided in 'Parameter value' is a point estimate. In case a distribution is selected the value provided in 'Parameter value' is a string that the model code can parse in order to sample from the named distribution"
            }, {
              "id": "error",
              "label": "Error",
              "type": "text",
              "description": "Error of the parameter value"
            }, {
              "id": "variabilitySubject",
              "label": "Parameter variability subject",
              "type": "text",
              "description": "Information on which the variability is described. It can be variability between broiler in a flock, variability between all meat packages sold in Denmark, variability between days, etc."
            }, {
              "id": "unit",
              "label": "Unit",
              "type": "text",
              "description": "Unit of the parameter"
            }, {
              "id": "minValue",
              "label": "Value min",
              "type": "text",
              "description": "Numerical value of the minimum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "unitCategory",
              "label": "Unit category",
              "type": "text",
              "description": "General classification of the parameter unit"
            }, {
              "id": "name",
              "label": "Parameter name",
              "type": "text",
              "description": "A name given to the parameter"
            }, {
              "id": "id",
              "label": "Parameter ID",
              "type": "text",
              "description": "An unambiguous ID given to each of the parameters - preferably autogenerated by a software tool and compatible with SBML ID requirements, only letters from A to Z, numbers and '_'"
            }, {
              "id": "value",
              "label": "Value",
              "type": "text",
              "description": "A default value for the parameter. This is mandatory (needs to be provided) for all parameters of type 'Input'"
            }]
          },
          "qualityMeasures": [{
            "id": "rsquared",
            "label": "R squared",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sse",
            "label": "SSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "rmse",
            "label": "RMSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "aic",
            "label": "AIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sensitivityAnalysis",
            "label": "Sensitivity analysis",
            "type": "long-text",
            "description": "Description of the results of an sensitivity analysis, i.e. how independence assumptions are met or how variables will affect the output of model"
          }, {
            "id": "bic",
            "label": "BIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "mse",
            "label": "MSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }],
          "modelMath": [{
            "id": "fittingProcedure",
            "label": "Fitting procedure",
            "type": "text",
            "description": "Procedure used to fit the data to the model equation"
          }, {
            "id": "event",
            "label": "Event",
            "description": "Definition of time-dependent parameter changes"
          }]
        },
        "scope": {
          "product": [{
            "id": "expiryDate",
            "label": "Expiration date",
            "type": "date",
            "description": "Expiry date of food/product"
          }, {
            "id": "treatment",
            "label": "Treatment",
            "description": "Used to characterise a product/matrix based on the treatment or processes applied to the product or any indexed ingredient"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the product, matrix or environment for which the model or data applies"
          }, {
            "id": "productionDate",
            "label": "Production date",
            "type": "date",
            "description": "Date of production of food/product"
          }, {
            "id": "method",
            "label": "Method of production",
            "description": "Type of production for the product/ matrix"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "The product, matrix or environment (e.g food product, lab media, soil etc.) for which the model or data applies"
          }, {
            "id": "originCountry",
            "label": "Country of origin",
            "type": "text",
            "description": "Country of origin of the food/product (ISO 3166-1-alpha-2 country code)"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Detailed description of the product, matrix or environment for which the model or data applies"
          }, {
            "id": "packaging",
            "label": "Packaging",
            "description": "Describe container or wrapper that holds the product/matrix. Common type of packaging (paper or plastic bags, boxes, tinplate or aluminium cans, plastic trays, plastic bottles, glass bottles or jars)"
          }, {
            "id": "fisheriesArea",
            "label": "Fisheries area",
            "type": "text",
            "description": "Fisheries or aquaculture area specifying the origin of the sample (FAO Fisheries areas)."
          }, {
            "id": "originArea",
            "label": "Area of origin",
            "type": "text",
            "description": "Area of origin of the food/product (Nomenclature of territorial units for statistics  NUTS  coding system valid only for EEA and Switzerland)."
          }],
          "populationGroup": [{
            "id": "populationRiskFactor",
            "label": "Risk and population factors",
            "description": "Population risk factor that may influence the outcomes of the study, confounder should be included"
          }, {
            "id": "country",
            "label": "Country",
            "description": "Country on which the population group of the model or data applies"
          }, {
            "id": "populationSpan",
            "label": "Population span (years)",
            "description": "Temporal information on the exposure duration"
          }, {
            "id": "populationGender",
            "label": "Population gender",
            "type": "text",
            "description": "Description of the percentage of gender"
          }, {
            "id": "populationDescription",
            "label": "Description",
            "description": "Description of the population for which the model applies (demographic and socio-economic characteristics for example). Background information that are needed in the data analysis phase, size of household, education level, employment status, professional category, ethnicity, etc."
          }, {
            "id": "populationAge",
            "label": "Population age",
            "description": "Description of the range of age or group of age"
          }, {
            "id": "patternConsumption",
            "label": "Consumption pattern",
            "description": "Description of the consumption of different food items, frequency, portion size"
          }, {
            "id": "name",
            "label": "Population name",
            "type": "text",
            "description": "Name of the population for which the model or data applies"
          }, {
            "id": "season",
            "label": "Season",
            "description": "Distribution of surveyed people according to the season (influence consumption pattern)"
          }, {
            "id": "region",
            "label": "Region",
            "description": "Spatial information (area) on which the population group of the model or data applies"
          }, {
            "id": "targetPopulation",
            "label": "Target population",
            "type": "text",
            "description": "Population of individual that we are interested in describing and making statistical inferences about"
          }, {
            "id": "bmi",
            "label": "BMI",
            "description": "Description of the range of BMI or class of BMI or BMI mean"
          }, {
            "id": "specialDietGroups",
            "label": "Special diet groups",
            "description": "Description of sub-population with special diets (vegetarians, diabetics, group following special ethnic diets)"
          }],
          "hazard": [{
            "id": "maximumResidueLimit",
            "label": "Maximum Residue Limit (MRL)",
            "type": "text",
            "description": "International regulations and permissible maximum residue levels in food and drinking water"
          }, {
            "id": "sourceOfContamination",
            "label": "Source of contamination",
            "type": "text",
            "description": "rigin of the contamination, source"
          }, {
            "id": "indSum",
            "label": "Individual or Summed Hazard",
            "type": "text",
            "description": "Define if the parameter reported is an individual residue/analyte, a summed residue definition or part of a sum a summed residue definition"
          }, {
            "id": "acceptableOperatorsExposureLevel",
            "label": "Acceptable Operator Exposure Level (AOEL)",
            "type": "text",
            "description": "Maximum amount of active substance to which the operator may be exposed without any adverse health effects. The AOEL is expressed as milligrams of the chemical per kilogram body weight of the operator"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Description of the hazard for which the model or data applies"
          }, {
            "id": "type",
            "label": "Hazard type",
            "type": "text",
            "description": "General classification of the hazard for which the model or data applies"
          }, {
            "id": "adverseEffect",
            "label": "Adverse effect",
            "type": "text",
            "description": "Adverse effect induced by hazard about morbidity, mortality, and etcetera"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the hazard for which the model or data applies"
          }, {
            "id": "noObservedAdverseAffectLevel",
            "label": "No Observed Adverse Affect Level (NOAEL)",
            "type": "text",
            "description": "Level of exposure of an organism, found by experiment or observation, at which there is no biologically or statistically significant increase in the frequency or severity of any adverse effects in the exposed population when compared to its appropriate control"
          }, {
            "id": "acuteReferenceDose",
            "label": "Acute Reference Dose (ARfD)",
            "type": "text",
            "description": "An estimate (with uncertainty spanning perhaps an order of magnitude) of a daily oral exposure for an acute duration (24 hours or less) to the human population (including sensitive subgroups) that is likely to be without an appreciable risk of deleterious effects during a lifetime"
          }, {
            "id": "name",
            "label": "Hazard name",
            "type": "text",
            "description": "Name of the hazard (agent, contaminant, chemical) for which the data or model applies"
          }, {
            "id": "lowestObservedAdverseAffectLevel",
            "label": "Lowest Observed Adverse Effect Level (LOAEL)",
            "type": "text",
            "description": "Lowest concentration or amount of a substance found by experiment or observation that causes an adverse alteration of morphology, function, capacity, growth, development, or lifespan of a target organism distinguished from normal organisms of the same species under defined conditions of exposure"
          }, {
            "id": "benchmarkDose",
            "label": "Benchmark Dose (BMD)",
            "type": "text",
            "description": "A dose or concentration that produces a predetermined change in response rate of an adverse effect (called the benchmark response or BMR) compared to background"
          }, {
            "id": "acceptableDailyIntake",
            "label": "Acceptable Daily Intake (ADI)",
            "type": "text",
            "description": "Measure of amount of a specific substance in food or in drinking water tahta can be ingested (orally) on a daily basis over a lifetime without an appreciable health risk"
          }],
          "scope": [{
            "id": "spatialInformation",
            "label": "Spatial information",
            "description": "Spatial information (area) on which the model or data applies"
          }, {
            "id": "generalComment",
            "label": "General comment",
            "type": "long-text",
            "description": "General comments on the scope of the study, data or model"
          }, {
            "id": "temporalInformation",
            "label": "Temporal information",
            "type": "long-text",
            "description": "Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)"
          }]
        },
        "generalInformation": {
          "creator": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "author": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "reference": [{
            "id": "date",
            "label": "Date",
            "type": "year_date",
            "description": "Temporal information on the publication date"
          }, {
            "id": "website",
            "label": "Website",
            "type": "text",
            "description": "A link to the publication website (different from DOI)"
          }, {
            "id": "issue",
            "label": "Issue",
            "type": "text",
            "description": "Data on the details of the issue in which the model or date has been described"
          }, {
            "id": "publicationType",
            "label": "Publication type",
            "type": "text",
            "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
          }, {
            "id": "abstract",
            "label": "Abstract",
            "type": "text",
            "description": "Abstract of the publication in which the model or the data has been described "
          }, {
            "id": "isReferenceDescription",
            "label": "Is_reference_description?",
            "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
          }, {
            "id": "title",
            "label": "Title",
            "type": "long-text",
            "description": "Title of publication in which the model or date has been described"
          }, {
            "id": "pmid",
            "label": "PubMed ID",
            "type": "text",
            "description": "The PubMed ID related to this publication"
          }, {
            "id": "volume",
            "label": "Volume",
            "type": "text",
            "description": "Data on the details of the volume in which the model or date has been described"
          }, {
            "id": "journal",
            "label": "Journal",
            "type": "long-text",
            "description": "Data on the details of the journal in which the model or date has been described"
          }, {
            "id": "authorList",
            "label": "Author list",
            "type": "long-text",
            "description": "Name and surname of the authors who contributed to this publication"
          }, {
            "id": "comment",
            "label": "Comment",
            "type": "long-text",
            "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
          }, {
            "id": "doi",
            "label": "Publication DOI",
            "type": "long-text",
            "description": "The DOI related to this publication"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The status of this publication, e.g. Published, Submitted, etc."
          }],
          "modelCategory": [{
            "id": "modelClassComment",
            "label": "Comment",
            "type": "long-text",
            "description": "Comment with further details on the model class"
          }, {
            "id": "basicProcess",
            "label": "Basic process",
            "description": "Defines the impact of the process on the hazard (so far only valid for process models and predictive models)"
          }, {
            "id": "modelClass",
            "label": "Model class",
            "type": "text",
            "description": "Type of model according to RAKIP classification"
          }, {
            "id": "modelSubClass",
            "label": "Subclass",
            "description": "Sub-classification of the model given the Model Class"
          }],
          "generalInformation": [{
            "id": "identifier",
            "label": "Identifier",
            "type": "text",
            "description": "An unambiguous ID given to the model or data. This can also be created automatically by a software tool"
          }, {
            "id": "software",
            "label": "Software",
            "type": "text",
            "description": "The program or software language in which the model has been implemented"
          }, {
            "id": "format",
            "label": "Format",
            "type": "text",
            "description": "File extension of the model or data file (including version number of format if applicable)"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the study, data or model"
          }, {
            "id": "language",
            "label": "Language",
            "type": "text",
            "description": "A language of the resource (some data or reports can be available in French language for example)"
          }, {
            "id": "source",
            "label": "Source",
            "type": "text",
            "description": "A source from which the model/data is derived"
          }, {
            "id": "availability",
            "label": "Availability",
            "type": "text",
            "description": "Availability of data or model, i.e. if the annotated model code / data is included in this FSK file"
          }, {
            "id": "creationDate",
            "label": "Creation date",
            "type": "date",
            "description": "Creation date/time of the FSK file"
          }, {
            "id": "url",
            "label": "URL",
            "type": "text",
            "description": "Web address referencing the resource location (data for example)"
          }, {
            "id": "objective",
            "label": "Objective",
            "type": "long-text",
            "description": "Objective of the model or data"
          }, {
            "id": "modificationDate",
            "label": "Modification date",
            "description": "Date/time of the last version of the FSK file"
          }, {
            "id": "rights",
            "label": "Rights",
            "type": "text",
            "description": "Rights granted for usage, distribution and modification of this FSK file"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "A name given to the model or data"
          }, {
            "id": "languageWrittenIn",
            "label": "Language written in",
            "type": "text",
            "description": "Software language used to write the model, e.g. R or MatLab"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The curation status of the model"
          }]
        }
      };
    }
    // Validate this.panels and return boolean
  }, {
    key: "validate",
    value: function validate() {
      var isValid = true;
      if (!this.panels.generalInformation.validate()) isValid = false;
      if (!this.panels.modelCategory.validate()) isValid = false;
      if (!this.panels.scopeGeneral.validate()) isValid = false;
      if (!this.panels.study.validate()) isValid = false;
      return isValid;
    }
  }, {
    key: "_createPanels",
    value: function _createPanels() {
      var _ref;
      var port = window.port || -1;
      var schema = schemas.genericModel;
      return _ref = {
        study: new _FormPanel.FormPanel("Study", this.jsonSchema.dataBackground.study, this._metadata.dataBackground ? this._metadata.dataBackground.study : {}, port),
        laboratory: new _TablePanel.TablePanel("Laboratory", this.jsonSchema.dataBackground.laboratory, this._metadata.dataBackground ? this._metadata.dataBackground.laboratory : {}, port),
        assay: new _TablePanel.TablePanel("Assay", this.jsonSchema.dataBackground.assay, this._metadata.dataBackground ? this._metadata.dataBackground.assay : {}, port),
        dietaryAssessmentMethod: new _TablePanel.TablePanel("Dietary Assessment Method", this.jsonSchema.dataBackground.dietaryAssessmentMethod, this._metadata.dataBackground ? this._metadata.dataBackground.dietaryAssessmentMethod : {}, port),
        studySample: new _TablePanel.TablePanel("Study Sample", this.jsonSchema.dataBackground.studySample, this._metadata.dataBackground ? this._metadata.dataBackground.studySample : {}, port),
        modelMath: new _FormPanel.FormPanel("Model Math", this.jsonSchema.modelMath.modelMath, this._metadata.modelMath, port),
        modelEquation: new _TablePanel.TablePanel("Model Equation", this.jsonSchema.modelMath.modelEquation.modelEquation, this._metadata.modelMath ? this._metadata.modelMath.modelEquation : {}, port),
        reference: new _TablePanel.TablePanel("Reference", this.jsonSchema.modelMath.modelEquation.reference, this._metadata.modelMath.modelEquation ? this._metadata.modelMath.modelEquation.reference : {}, port),
        exposure: new _TablePanel.TablePanel("Exposure", this.jsonSchema.modelMath.exposure, this._metadata.modelMath ? this._metadata.modelMath.exposure : {}, port),
        parameter: new _TablePanel.TablePanel("Parameter", this.jsonSchema.modelMath.parameter.parameter, this._metadata.modelMath ? this._metadata.modelMath.parameter : {}, port)
      }, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref, "reference", new _FormPanel.FormPanel("Reference", this.jsonSchema.modelMath.parameter.reference, this._metadata.modelMath.parameter ? this._metadata.modelMath.parameter.reference : {}, port)), "qualityMeasures", new _TablePanel.TablePanel("Quality Measures", this.jsonSchema.modelMath.qualityMeasures, this._metadata.modelMath ? this._metadata.modelMath.qualityMeasures : {}, port)), "scope", new _FormPanel.FormPanel("Scope", this.jsonSchema.scope.scope, this._metadata.scope, port)), "product", new _TablePanel.TablePanel("Product", this.jsonSchema.scope.product, this._metadata.scope ? this._metadata.scope.product : {}, port)), "populationGroup", new _TablePanel.TablePanel("Population Group", this.jsonSchema.scope.populationGroup, this._metadata.scope ? this._metadata.scope.populationGroup : {}, port)), "hazard", new _TablePanel.TablePanel("Hazard", this.jsonSchema.scope.hazard, this._metadata.scope ? this._metadata.scope.hazard : {}, port)), "generalInformation", new _FormPanel.FormPanel("General Information", this.jsonSchema.generalInformation.generalInformation, this._metadata.generalInformation, port)), "creator", new _TablePanel.TablePanel("Creator", this.jsonSchema.generalInformation.creator, this._metadata.generalInformation ? this._metadata.generalInformation.creator : {}, port)), "author", new _TablePanel.TablePanel("Author", this.jsonSchema.generalInformation.author, this._metadata.generalInformation ? this._metadata.generalInformation.author : {}, port)), "reference", new _TablePanel.TablePanel("Reference", this.jsonSchema.generalInformation.reference, this._metadata.generalInformation ? this._metadata.generalInformation.reference : {}, port)), _defineProperty(_ref, "modelCategory", new _FormPanel.FormPanel("Model Category", this.jsonSchema.generalInformation.modelCategory, this._metadata.generalInformation ? this._metadata.generalInformation.modelCategory : {}, port));
    }
  }]);
}(_ModelView2.ModelView);

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./ExposureModelScopeView":92,"./GenericModelDataBackgroundView":97,"./GenericModelModelMathView":101,"./ModelView":118,"./PredictiveModelGeneralInformationView":137}],94:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExposureView = void 0;
var _ApiClient = require("../ApiClient");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Exposure View  module.
 * @module model/Exposure
 * @version 1.0.0
 */
var ExposureView = exports.ExposureView = /*#__PURE__*/_createClass(function ExposureView() {
  _classCallCheck(this, ExposureView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63}],95:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenericModel = void 0;
var _ApiClient = require("../ApiClient");
var _GenericModelDataBackground = require("./GenericModelDataBackground");
var _GenericModelGeneralInformation = require("./GenericModelGeneralInformation");
var _GenericModelModelMath = require("./GenericModelModelMath");
var _GenericModelScope = require("./GenericModelScope");
var _Model2 = require("./Model");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The GenericModel model module.
 * @module model/GenericModel
 * @version 1.0.0
 */
var GenericModel = exports.GenericModel = /*#__PURE__*/function (_Model) {
  /**
   * Constructs a new <code>GenericModel</code>.
   * @alias module:model/GenericModel
   * @class
   * @extends module:model/Model
   * @param modelType {} 
   */
  function GenericModel(modelType) {
    _classCallCheck(this, GenericModel);
    return _callSuper(this, GenericModel, [modelType]);
  }

  /**
   * Constructs a <code>GenericModel</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/GenericModel} obj Optional instance to populate.
   * @return {module:model/GenericModel} The populated <code>GenericModel</code> instance.
   */
  _inherits(GenericModel, _Model);
  return _createClass(GenericModel, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new GenericModel();
        _Model2.Model.constructFromObject(data, obj);
        if (data.hasOwnProperty('dataBackground')) obj.dataBackground = _GenericModelDataBackground.GenericModelDataBackground.constructFromObject(data['dataBackground']);
        if (data.hasOwnProperty('modelMath')) obj.modelMath = _GenericModelModelMath.GenericModelModelMath.constructFromObject(data['modelMath']);
        if (data.hasOwnProperty('scope')) obj.scope = _GenericModelScope.GenericModelScope.constructFromObject(data['scope']);
        if (data.hasOwnProperty('generalInformation')) obj.generalInformation = _GenericModelGeneralInformation.GenericModelGeneralInformation.constructFromObject(data['generalInformation']);
      }
      return obj;
    }
  }]);
}(_Model2.Model);
/**
 * @member {module:model/GenericModelDataBackground} dataBackground
 */
GenericModel.prototype.dataBackground = undefined;

/**
 * @member {module:model/GenericModelModelMath} modelMath
 */
GenericModel.prototype.modelMath = undefined;

/**
 * @member {module:model/GenericModelScope} scope
 */
GenericModel.prototype.scope = undefined;

/**
 * @member {module:model/GenericModelGeneralInformation} generalInformation
 */
GenericModel.prototype.generalInformation = undefined;

},{"../ApiClient":44,"./GenericModelDataBackground":96,"./GenericModelGeneralInformation":98,"./GenericModelModelMath":100,"./GenericModelScope":102,"./Model":113}],96:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenericModelDataBackground = void 0;
var _ApiClient = require("../ApiClient");
var _Assay = require("./Assay");
var _DietaryAssessmentMethod = require("./DietaryAssessmentMethod");
var _Laboratory = require("./Laboratory");
var _Study = require("./Study");
var _StudySample = require("./StudySample");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The GenericModelDataBackground model module.
 * @module model/GenericModelDataBackground
 * @version 1.0.0
 */
var GenericModelDataBackground = exports.GenericModelDataBackground = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>GenericModelDataBackground</code>.
   * @alias module:model/GenericModelDataBackground
   * @class
   * @param study {} 
   */
  function GenericModelDataBackground(study) {
    _classCallCheck(this, GenericModelDataBackground);
    this.study = study;
  }

  /**
   * Constructs a <code>GenericModelDataBackground</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/GenericModelDataBackground} obj Optional instance to populate.
   * @return {module:model/GenericModelDataBackground} The populated <code>GenericModelDataBackground</code> instance.
   */
  return _createClass(GenericModelDataBackground, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new GenericModelDataBackground();
        if (data.hasOwnProperty('study')) obj.study = _Study.Study.constructFromObject(data['study']);
        if (data.hasOwnProperty('laboratory')) obj.laboratory = _ApiClient.ApiClient.convertToType(data['laboratory'], [_Laboratory.Laboratory]);
        if (data.hasOwnProperty('assay')) obj.assay = _ApiClient.ApiClient.convertToType(data['assay'], [_Assay.Assay]);
        if (data.hasOwnProperty('dietaryAssessmentMethod')) obj.dietaryAssessmentMethod = _ApiClient.ApiClient.convertToType(data['dietaryAssessmentMethod'], [_DietaryAssessmentMethod.DietaryAssessmentMethod]);
        if (data.hasOwnProperty('studySample')) obj.studySample = _ApiClient.ApiClient.convertToType(data['studySample'], [_StudySample.StudySample]);
      }
      return obj;
    }
  }]);
}();
/**
 * @member {module:model/Study} study
 */
GenericModelDataBackground.prototype.study = undefined;

/**
 * @member {Array.<module:model/Laboratory>} laboratory
 */
GenericModelDataBackground.prototype.laboratory = undefined;

/**
 * @member {Array.<module:model/Assay>} assay
 */
GenericModelDataBackground.prototype.assay = undefined;

/**
 * @member {Array.<module:model/DietaryAssessmentMethod>} dietaryAssessmentMethod
 */
GenericModelDataBackground.prototype.dietaryAssessmentMethod = undefined;

/**
 * @member {Array.<module:model/StudySample>} studySample
 */
GenericModelDataBackground.prototype.studySample = undefined;

},{"../ApiClient":44,"./Assay":65,"./DietaryAssessmentMethod":79,"./Laboratory":111,"./Study":159,"./StudySample":160}],97:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenericModelDataBackgroundView = void 0;
var _ApiClient = require("../ApiClient");
var _AssayView = require("./AssayView");
var _DietaryAssessmentMethodView = require("./DietaryAssessmentMethodView");
var _LaboratoryView = require("./LaboratoryView");
var _StudyView = require("./StudyView");
var _StudySampleView = require("./StudySampleView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The GenericModelDataBackground View  module.
 * @module model/GenericModelDataBackground
 * @version 1.0.0
 */
var GenericModelDataBackgroundView = exports.GenericModelDataBackgroundView = /*#__PURE__*/_createClass(function GenericModelDataBackgroundView() {
  _classCallCheck(this, GenericModelDataBackgroundView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./AssayView":66,"./DietaryAssessmentMethodView":80,"./LaboratoryView":112,"./StudySampleView":161,"./StudyView":162}],98:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenericModelGeneralInformation = void 0;
var _ApiClient = require("../ApiClient");
var _Contact = require("./Contact");
var _ModelCategory = require("./ModelCategory");
var _Reference = require("./Reference");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The GenericModelGeneralInformation model module.
 * @module model/GenericModelGeneralInformation
 * @version 1.0.0
 */
var GenericModelGeneralInformation = exports.GenericModelGeneralInformation = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>GenericModelGeneralInformation</code>.
   * @alias module:model/GenericModelGeneralInformation
   * @class
   * @param identifier {} An unambiguous ID given to the model or data. This can also be created automatically by a software tool
   * @param creationDate {} Creation date/time of the FSK file
   * @param reference {} 
   * @param rights {} Rights granted for usage, distribution and modification of this FSK file
   * @param name {} A name given to the model or data
   */
  function GenericModelGeneralInformation(identifiercreationDatereferencerightsname) {
    _classCallCheck(this, GenericModelGeneralInformation);
    this.identifier = identifier;
    this.creationDate = creationDate;
    this.reference = reference;
    this.rights = rights;
    this.name = name;
  }

  /**
   * Constructs a <code>GenericModelGeneralInformation</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/GenericModelGeneralInformation} obj Optional instance to populate.
   * @return {module:model/GenericModelGeneralInformation} The populated <code>GenericModelGeneralInformation</code> instance.
   */
  return _createClass(GenericModelGeneralInformation, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new GenericModelGeneralInformation();
        if (data.hasOwnProperty('identifier')) obj.identifier = _ApiClient.ApiClient.convertToType(data['identifier'], 'String');
        if (data.hasOwnProperty('creator')) obj.creator = _ApiClient.ApiClient.convertToType(data['creator'], [_Contact.Contact]);
        if (data.hasOwnProperty('software')) obj.software = _ApiClient.ApiClient.convertToType(data['software'], 'String');
        if (data.hasOwnProperty('author')) obj.author = _ApiClient.ApiClient.convertToType(data['author'], [_Contact.Contact]);
        if (data.hasOwnProperty('format')) obj.format = _ApiClient.ApiClient.convertToType(data['format'], 'String');
        if (data.hasOwnProperty('description')) obj.description = _ApiClient.ApiClient.convertToType(data['description'], 'String');
        if (data.hasOwnProperty('language')) obj.language = _ApiClient.ApiClient.convertToType(data['language'], 'String');
        if (data.hasOwnProperty('source')) obj.source = _ApiClient.ApiClient.convertToType(data['source'], 'String');
        if (data.hasOwnProperty('availability')) obj.availability = _ApiClient.ApiClient.convertToType(data['availability'], 'String');
        if (data.hasOwnProperty('creationDate')) obj.creationDate = _ApiClient.ApiClient.convertToType(data['creationDate'], 'Date');
        if (data.hasOwnProperty('url')) obj.url = _ApiClient.ApiClient.convertToType(data['url'], 'String');
        if (data.hasOwnProperty('objective')) obj.objective = _ApiClient.ApiClient.convertToType(data['objective'], 'String');
        if (data.hasOwnProperty('reference')) obj.reference = _ApiClient.ApiClient.convertToType(data['reference'], [_Reference.Reference]);
        if (data.hasOwnProperty('modificationDate')) obj.modificationDate = _ApiClient.ApiClient.convertToType(data['modificationDate'], ['Date']);
        if (data.hasOwnProperty('rights')) obj.rights = _ApiClient.ApiClient.convertToType(data['rights'], 'String');
        if (data.hasOwnProperty('name')) obj.name = _ApiClient.ApiClient.convertToType(data['name'], 'String');
        if (data.hasOwnProperty('languageWrittenIn')) obj.languageWrittenIn = _ApiClient.ApiClient.convertToType(data['languageWrittenIn'], 'String');
        if (data.hasOwnProperty('modelCategory')) obj.modelCategory = _ModelCategory.ModelCategory.constructFromObject(data['modelCategory']);
        if (data.hasOwnProperty('status')) obj.status = _ApiClient.ApiClient.convertToType(data['status'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * An unambiguous ID given to the model or data. This can also be created automatically by a software tool
 * @member {String} identifier
 */
GenericModelGeneralInformation.prototype.identifier = undefined;

/**
 * The person(s) that created this FSK file including all metadata
 * @member {Array.<module:model/Contact>} creator
 */
GenericModelGeneralInformation.prototype.creator = undefined;

/**
 * The program or software language in which the model has been implemented
 * @member {String} software
 */
GenericModelGeneralInformation.prototype.software = undefined;

/**
 * Person(s) who generated the model code or generated the data set originally
 * @member {Array.<module:model/Contact>} author
 */
GenericModelGeneralInformation.prototype.author = undefined;

/**
 * File extension of the model or data file (including version number of format if applicable)
 * @member {String} format
 */
GenericModelGeneralInformation.prototype.format = undefined;

/**
 * General description of the study, data or model
 * @member {String} description
 */
GenericModelGeneralInformation.prototype.description = undefined;

/**
 * A language of the resource (some data or reports can be available in French language for example)
 * @member {String} language
 */
GenericModelGeneralInformation.prototype.language = undefined;

/**
 * A source from which the model/data is derived
 * @member {String} source
 */
GenericModelGeneralInformation.prototype.source = undefined;

/**
 * Availability of data or model, i.e. if the annotated model code / data is included in this FSK file
 * @member {String} availability
 */
GenericModelGeneralInformation.prototype.availability = undefined;

/**
 * Creation date/time of the FSK file
 * @member {Date} creationDate
 */
GenericModelGeneralInformation.prototype.creationDate = undefined;

/**
 * Web address referencing the resource location (data for example)
 * @member {String} url
 */
GenericModelGeneralInformation.prototype.url = undefined;

/**
 * Objective of the model or data
 * @member {String} objective
 */
GenericModelGeneralInformation.prototype.objective = undefined;

/**
 * @member {Array.<module:model/Reference>} reference
 */
GenericModelGeneralInformation.prototype.reference = undefined;

/**
 * Date/time of the last version of the FSK file
 * @member {Array.<Date>} modificationDate
 */
GenericModelGeneralInformation.prototype.modificationDate = undefined;

/**
 * Rights granted for usage, distribution and modification of this FSK file
 * @member {String} rights
 */
GenericModelGeneralInformation.prototype.rights = undefined;

/**
 * A name given to the model or data
 * @member {String} name
 */
GenericModelGeneralInformation.prototype.name = undefined;

/**
 * Software language used to write the model, e.g. R or MatLab
 * @member {String} languageWrittenIn
 */
GenericModelGeneralInformation.prototype.languageWrittenIn = undefined;

/**
 * @member {module:model/ModelCategory} modelCategory
 */
GenericModelGeneralInformation.prototype.modelCategory = undefined;

/**
 * The curation status of the model
 * @member {String} status
 */
GenericModelGeneralInformation.prototype.status = undefined;

},{"../ApiClient":44,"./Contact":71,"./ModelCategory":114,"./Reference":155}],99:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenericModelGeneralInformationView = void 0;
var _ApiClient = require("../ApiClient");
var _ContactView = require("./ContactView");
var _ModelCategoryView = require("./ModelCategoryView");
var _ReferenceView = require("./ReferenceView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The GenericModelGeneralInformation View  module.
 * @module model/GenericModelGeneralInformation
 * @version 1.0.0
 */
var GenericModelGeneralInformationView = exports.GenericModelGeneralInformationView = /*#__PURE__*/_createClass(function GenericModelGeneralInformationView() {
  _classCallCheck(this, GenericModelGeneralInformationView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./ContactView":72,"./ModelCategoryView":115,"./ReferenceView":156}],100:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenericModelModelMath = void 0;
var _ApiClient = require("../ApiClient");
var _Exposure = require("./Exposure");
var _ModelEquation = require("./ModelEquation");
var _Parameter = require("./Parameter");
var _QualityMeasures = require("./QualityMeasures");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The GenericModelModelMath model module.
 * @module model/GenericModelModelMath
 * @version 1.0.0
 */
var GenericModelModelMath = exports.GenericModelModelMath = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>GenericModelModelMath</code>.
   * @alias module:model/GenericModelModelMath
   * @class
   * @param parameter {} 
   */
  function GenericModelModelMath(parameter) {
    _classCallCheck(this, GenericModelModelMath);
    this.parameter = parameter;
  }

  /**
   * Constructs a <code>GenericModelModelMath</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/GenericModelModelMath} obj Optional instance to populate.
   * @return {module:model/GenericModelModelMath} The populated <code>GenericModelModelMath</code> instance.
   */
  return _createClass(GenericModelModelMath, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new GenericModelModelMath();
        if (data.hasOwnProperty('fittingProcedure')) obj.fittingProcedure = _ApiClient.ApiClient.convertToType(data['fittingProcedure'], 'String');
        if (data.hasOwnProperty('modelEquation')) obj.modelEquation = _ApiClient.ApiClient.convertToType(data['modelEquation'], [_ModelEquation.ModelEquation]);
        if (data.hasOwnProperty('exposure')) obj.exposure = _ApiClient.ApiClient.convertToType(data['exposure'], [_Exposure.Exposure]);
        if (data.hasOwnProperty('parameter')) obj.parameter = _ApiClient.ApiClient.convertToType(data['parameter'], [_Parameter.Parameter]);
        if (data.hasOwnProperty('qualityMeasures')) obj.qualityMeasures = _ApiClient.ApiClient.convertToType(data['qualityMeasures'], [_QualityMeasures.QualityMeasures]);
        if (data.hasOwnProperty('event')) obj.event = _ApiClient.ApiClient.convertToType(data['event'], ['String']);
      }
      return obj;
    }
  }]);
}();
/**
 * Procedure used to fit the data to the model equation
 * @member {String} fittingProcedure
 */
GenericModelModelMath.prototype.fittingProcedure = undefined;

/**
 * @member {Array.<module:model/ModelEquation>} modelEquation
 */
GenericModelModelMath.prototype.modelEquation = undefined;

/**
 * @member {Array.<module:model/Exposure>} exposure
 */
GenericModelModelMath.prototype.exposure = undefined;

/**
 * @member {Array.<module:model/Parameter>} parameter
 */
GenericModelModelMath.prototype.parameter = undefined;

/**
 * @member {Array.<module:model/QualityMeasures>} qualityMeasures
 */
GenericModelModelMath.prototype.qualityMeasures = undefined;

/**
 * Definition of time-dependent parameter changes
 * @member {Array.<String>} event
 */
GenericModelModelMath.prototype.event = undefined;

},{"../ApiClient":44,"./Exposure":89,"./ModelEquation":116,"./Parameter":129,"./QualityMeasures":153}],101:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenericModelModelMathView = void 0;
var _ApiClient = require("../ApiClient");
var _ExposureView = require("./ExposureView");
var _ModelEquationView = require("./ModelEquationView");
var _ParameterView = require("./ParameterView");
var _QualityMeasuresView = require("./QualityMeasuresView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The GenericModelModelMath View  module.
 * @module model/GenericModelModelMath
 * @version 1.0.0
 */
var GenericModelModelMathView = exports.GenericModelModelMathView = /*#__PURE__*/_createClass(function GenericModelModelMathView() {
  _classCallCheck(this, GenericModelModelMathView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./ExposureView":94,"./ModelEquationView":117,"./ParameterView":130,"./QualityMeasuresView":154}],102:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenericModelScope = void 0;
var _ApiClient = require("../ApiClient");
var _Hazard = require("./Hazard");
var _PopulationGroup = require("./PopulationGroup");
var _Product = require("./Product");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The GenericModelScope model module.
 * @module model/GenericModelScope
 * @version 1.0.0
 */
var GenericModelScope = exports.GenericModelScope = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>GenericModelScope</code>.
   * @alias module:model/GenericModelScope
   * @class
   */
  function GenericModelScope() {
    _classCallCheck(this, GenericModelScope);
  }

  /**
   * Constructs a <code>GenericModelScope</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/GenericModelScope} obj Optional instance to populate.
   * @return {module:model/GenericModelScope} The populated <code>GenericModelScope</code> instance.
   */
  return _createClass(GenericModelScope, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new GenericModelScope();
        if (data.hasOwnProperty('spatialInformation')) obj.spatialInformation = _ApiClient.ApiClient.convertToType(data['spatialInformation'], ['String']);
        if (data.hasOwnProperty('product')) obj.product = _ApiClient.ApiClient.convertToType(data['product'], [_Product.Product]);
        if (data.hasOwnProperty('populationGroup')) obj.populationGroup = _ApiClient.ApiClient.convertToType(data['populationGroup'], [_PopulationGroup.PopulationGroup]);
        if (data.hasOwnProperty('hazard')) obj.hazard = _ApiClient.ApiClient.convertToType(data['hazard'], [_Hazard.Hazard]);
        if (data.hasOwnProperty('generalComment')) obj.generalComment = _ApiClient.ApiClient.convertToType(data['generalComment'], 'String');
        if (data.hasOwnProperty('temporalInformation')) obj.temporalInformation = _ApiClient.ApiClient.convertToType(data['temporalInformation'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * Spatial information (area) on which the model or data applies
 * @member {Array.<String>} spatialInformation
 */
GenericModelScope.prototype.spatialInformation = undefined;

/**
 * @member {Array.<module:model/Product>} product
 */
GenericModelScope.prototype.product = undefined;

/**
 * @member {Array.<module:model/PopulationGroup>} populationGroup
 */
GenericModelScope.prototype.populationGroup = undefined;

/**
 * @member {Array.<module:model/Hazard>} hazard
 */
GenericModelScope.prototype.hazard = undefined;

/**
 * General comments on the scope of the study, data or model
 * @member {String} generalComment
 */
GenericModelScope.prototype.generalComment = undefined;

/**
 * Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)
 * @member {String} temporalInformation
 */
GenericModelScope.prototype.temporalInformation = undefined;

},{"../ApiClient":44,"./Hazard":105,"./PopulationGroup":131,"./Product":149}],103:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenericModelScopeView = void 0;
var _ApiClient = require("../ApiClient");
var _HazardView = require("./HazardView");
var _PopulationGroupView = require("./PopulationGroupView");
var _ProductView = require("./ProductView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The GenericModelScope View  module.
 * @module model/GenericModelScope
 * @version 1.0.0
 */
var GenericModelScopeView = exports.GenericModelScopeView = /*#__PURE__*/_createClass(function GenericModelScopeView() {
  _classCallCheck(this, GenericModelScopeView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./HazardView":106,"./PopulationGroupView":132,"./ProductView":150}],104:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenericModelView = void 0;
var _ApiClient = require("../ApiClient");
var _GenericModelDataBackgroundView = require("./GenericModelDataBackgroundView");
var _GenericModelGeneralInformationView = require("./GenericModelGeneralInformationView");
var _GenericModelModelMathView = require("./GenericModelModelMathView");
var _GenericModelScopeView = require("./GenericModelScopeView");
var _ModelView2 = require("./ModelView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The GenericModel View  module.
 * @module model/GenericModel
 * @version 1.0.0
 */
var GenericModelView = exports.GenericModelView = /*#__PURE__*/function (_ModelView) {
  function GenericModelView(metadata, img, state, modelScript, visScript, readme) {
    var _this$_panels;
    var _this;
    _classCallCheck(this, GenericModelView);
    _this = _callSuper(this, GenericModelView, [metadata, img, modelScript, visScript, readme]);
    _this._schema = schemas.genericModel;
    if (state) {
      _this.panels = _this._createPanels();
    }
    _this._menu = [{
      "label": "General Information",
      "id": "generalInformation",
      "submenus": [{
        "label": "General Information",
        "id": "generalInformation"
      }, {
        "label": "Model Category",
        "id": "modelCategory"
      }, {
        "label": "Reference",
        "id": "reference"
      }, {
        "label": "Author",
        "id": "author"
      }, {
        "label": "Creator",
        "id": "creator"
      }]
    }, {
      "label": "Scope",
      "id": "scope",
      "submenus": [{
        "label": "Scope",
        "id": "scope"
      }, {
        "label": "Hazard",
        "id": "hazard"
      }, {
        "label": "Population Group",
        "id": "populationGroup"
      }, {
        "label": "Product",
        "id": "product"
      }]
    }, {
      "label": "Model Math",
      "id": "modelMath",
      "submenus": [{
        "label": "Model Math",
        "id": "modelMath"
      }, {
        "label": "Quality Measures",
        "id": "qualityMeasures"
      }, {
        "label": "Parameter",
        "id": "parameter",
        "submenus": [{
          "label": "Parameter",
          "id": "parameter"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }, {
        "label": "Exposure",
        "id": "exposure"
      }, {
        "label": "Model Equation",
        "id": "modelEquation",
        "submenus": [{
          "label": "Model Equation",
          "id": "modelEquation"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }]
    }, {
      "label": "Data Background",
      "id": "dataBackground",
      "submenus": [{
        "label": "Study Sample",
        "id": "studySample"
      }, {
        "label": "Dietary Assessment Method",
        "id": "dietaryAssessmentMethod"
      }, {
        "label": "Assay",
        "id": "assay"
      }, {
        "label": "Laboratory",
        "id": "laboratory"
      }, {
        "label": "Study",
        "id": "study"
      }]
    }];
    _this._panels = (_this$_panels = {
      study: {
        type: 'simple',
        schema: _this.jsonSchema.dataBackgroundstudy,
        metadata: _this._metadata.study
      },
      laboratory: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundlaboratory,
        metadata: _this._metadata.laboratory
      },
      assay: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundassay,
        metadata: _this._metadata.assay
      },
      dietaryAssessmentMethod: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgrounddietaryAssessmentMethod,
        metadata: _this._metadata.dietaryAssessmentMethod
      },
      studySample: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundstudySample,
        metadata: _this._metadata.studySample
      },
      modelMath: {
        type: 'simple',
        schema: _this.jsonSchema.modelMathmodelMath,
        metadata: _this._metadata.modelMath
      },
      modelEquation: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationmodelEquation,
        metadata: _this._metadata.modelEquation
      },
      reference: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationreference,
        metadata: _this._metadata.reference
      },
      exposure: {
        type: 'complex',
        schema: _this.jsonSchema.modelMathexposure,
        metadata: _this._metadata.exposure
      },
      parameter: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.parameterparameter,
        metadata: _this._metadata.parameter
      }
    }, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_this$_panels, "reference", {
      type: 'simple',
      schema: _this.jsonSchema.modelMath.parameterreference,
      metadata: _this._metadata.reference
    }), "qualityMeasures", {
      type: 'complex',
      schema: _this.jsonSchema.modelMathqualityMeasures,
      metadata: _this._metadata.qualityMeasures
    }), "scope", {
      type: 'simple',
      schema: _this.jsonSchema.scopescope,
      metadata: _this._metadata.scope
    }), "product", {
      type: 'complex',
      schema: _this.jsonSchema.scopeproduct,
      metadata: _this._metadata.product
    }), "populationGroup", {
      type: 'complex',
      schema: _this.jsonSchema.scopepopulationGroup,
      metadata: _this._metadata.populationGroup
    }), "hazard", {
      type: 'complex',
      schema: _this.jsonSchema.scopehazard,
      metadata: _this._metadata.hazard
    }), "generalInformation", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationgeneralInformation,
      metadata: _this._metadata.generalInformation
    }), "creator", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationcreator,
      metadata: _this._metadata.creator
    }), "author", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationauthor,
      metadata: _this._metadata.author
    }), "reference", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationreference,
      metadata: _this._metadata.reference
    }), _defineProperty(_this$_panels, "modelCategory", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationmodelCategory,
      metadata: _this._metadata.modelCategory
    }));
    return _this;
  }
  _inherits(GenericModelView, _ModelView);
  return _createClass(GenericModelView, [{
    key: "metaData",
    get: function get() {
      try {
        this._metadata.dataBackground.study = this.panels.study.data;
        this._metadata.dataBackground.laboratory = this.panels.laboratory.data;
        this._metadata.dataBackground.assay = this.panels.assay.data;
        this._metadata.dataBackground.dietaryAssessmentMethod = this.panels.dietaryAssessmentMethod.data;
        this._metadata.dataBackground.studySample = this.panels.studySample.data;
        this._metadata.modelMath = this.panels.modelMath.data;
        this._metadata.modelMath.modelEquation = this.panels.modelEquation.data;
        this._metadata.modelMath.modelEquation.reference = this.panels.reference.data;
        this._metadata.modelMath.exposure = this.panels.exposure.data;
        this._metadata.modelMath.parameter = this.panels.parameter.data;
        this._metadata.modelMath.parameter.reference = this.panels.reference.data;
        this._metadata.modelMath.qualityMeasures = this.panels.qualityMeasures.data;
        this._metadata.scope = this.panels.scope.data;
        this._metadata.scope.product = this.panels.product.data;
        this._metadata.scope.populationGroup = this.panels.populationGroup.data;
        this._metadata.scope.hazard = this.panels.hazard.data;
        this._metadata.generalInformation = this.panels.generalInformation.data;
        this._metadata.generalInformation.creator = this.panels.creator.data;
        this._metadata.generalInformation.author = this.panels.author.data;
        this._metadata.generalInformation.reference = this.panels.reference.data;
        this._metadata.generalInformation.modelCategory = this.panels.modelCategory.data;
        this._metadata.modelType = "GenericModel";
        this._metadata = metadataFix(this._metadata);
      } catch (error) {
        console.log(error);
      }
      return this._metadata;
    }
  }, {
    key: "jsonSchema",
    get: function get() {
      return {
        "dataBackground": {
          "study": [{
            "id": "identifier",
            "label": "Study identifier",
            "type": "text",
            "description": "A user defined identifier for the study"
          }, {
            "id": "protocolComponentsName",
            "label": "Components names",
            "type": "text",
            "description": "The names of the components used when carrying out this protocol"
          }, {
            "id": "designType",
            "label": "Design type",
            "type": "text",
            "description": "The type of study design being employed"
          }, {
            "id": "assayMeasurementType",
            "label": "Assay measurement type",
            "type": "text",
            "description": "The measurement being observed in this assay"
          }, {
            "id": "protocolComponentsType",
            "label": "Protocol components type",
            "type": "text",
            "description": "Description"
          }, {
            "id": "description",
            "label": "Study description",
            "type": "long-text",
            "description": "A brief description of the study aims"
          }, {
            "id": "assayTechnologyPlatform",
            "label": "Assay technology platform",
            "type": "text",
            "description": "The technology platform used"
          }, {
            "id": "assayTechnologyType",
            "label": "Assay technology type",
            "type": "text",
            "description": "The technology being employed to observe this measurement"
          }, {
            "id": "protocolType",
            "label": "Protocol type",
            "type": "text",
            "description": "The type of the protocol, preferably coming from an Ontology, e.g. Extraction Protocol"
          }, {
            "id": "title",
            "label": "Study title",
            "type": "long-text",
            "description": "A title for the study"
          }, {
            "id": "protocolDescription",
            "label": "Protocol description",
            "type": "long-text",
            "description": "A description of the protocol"
          }, {
            "id": "protocolParametersName",
            "label": "Parameters names",
            "type": "text",
            "description": "The parameters used when executing this protocol"
          }, {
            "id": "protocolName",
            "label": "Protocol name",
            "type": "text",
            "description": "The name of the protocol, e.g.Extraction Protocol"
          }, {
            "id": "protocolVersion",
            "label": "Protocol version",
            "type": "text",
            "description": "The version of the protocol used, where applicable."
          }, {
            "id": "protocolURI",
            "label": "Protocol URI",
            "type": "text",
            "description": "A URI to link out to a publication, web page, etc. describing the protocol"
          }, {
            "id": "accreditationProcedureForTheAssayTechnology",
            "label": "Accreditation procedure for assay",
            "type": "text",
            "description": "Accreditation procedure for the analytical method used"
          }],
          "laboratory": [{
            "id": "country",
            "label": "Laboratory country",
            "type": "text",
            "description": "Country where the laboratory is placed. (ISO 3166-1-alpha-2)"
          }, {
            "id": "name",
            "label": "Laboratory name",
            "type": "text",
            "description": "Laboratory code (National laboratory code if available) or Laboratory name "
          }, {
            "id": "accreditation",
            "label": "Laboratory accreditation",
            "description": "The laboratory accreditation to ISO/IEC 17025"
          }],
          "assay": [{
            "id": "contaminationRange",
            "label": "Range of contamination",
            "type": "text",
            "description": "Range of result of the analytical measure reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "uncertaintyValue",
            "label": "Uncertainty value",
            "type": "text",
            "description": "Indicate the expanded uncertainty (usually 95% confidence interval) value associated with the measurement expressed in the unit reported in the field Hazard unit"
          }, {
            "id": "fatPercentage",
            "label": "Percentage of fat",
            "type": "text",
            "description": "Percentage of fat in the original sample"
          }, {
            "id": "name",
            "label": "Assay name",
            "type": "text",
            "description": "A name given to the assay"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the assay. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "moisturePercentage",
            "label": "Percentage of moisture",
            "type": "text",
            "description": "Percentage of moisture in the original sample"
          }, {
            "id": "leftCensoredData",
            "label": "Left-censored data",
            "type": "text",
            "description": "Percentage of measures equal to LOQ and/or LOD"
          }, {
            "id": "detectionLimit",
            "label": "Limit of detection",
            "type": "text",
            "description": "Limit of detection reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "quantificationLimit",
            "label": "Limit of quantification",
            "type": "text",
            "description": "Limit of quantification reported in the unit specified by the variable Hazard unit"
          }],
          "dietaryAssessmentMethod": [{
            "id": "recordTypes",
            "label": "Type of records",
            "description": "Consumption occasion, mean of consumption, quantified and described as eaten, recipes for self-made"
          }, {
            "id": "numberOfFoodItems",
            "label": "Number of food items",
            "description": "Number of food items"
          }, {
            "id": "numberOfNonConsecutiveOneDay",
            "label": "Number of non-consecutive one-day",
            "type": "text",
            "description": "Number of non-consecutive one-day recorded"
          }, {
            "id": "softwareTool",
            "label": "Dietary software tool",
            "type": "text",
            "description": "Name of the software used to collect the data"
          }, {
            "id": "foodDescriptors",
            "label": "Food descriptors",
            "description": "Description using FoodEx2 facet"
          }, {
            "id": "collectionTool",
            "label": "Methodological tool to collect data",
            "type": "text",
            "description": "Food diaries, interview, 24-hour recall interview, food propensy questionnaire, portion size measurement aids, eating outside questionnaire"
          }],
          "studySample": [{
            "id": "sampleName",
            "label": "Name",
            "type": "text",
            "description": "An unambiguous ID given to the samples used in the assay"
          }, {
            "id": "samplingWeight",
            "label": "Sampling weight",
            "type": "text",
            "description": "Description of the method employed to compute sampling weight (nonresponse-adjusted weight)"
          }, {
            "id": "protocolOfSampleCollection",
            "label": "Protocol of sample collection",
            "type": "text",
            "description": "Additional protocol for sample and sample collection. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "samplingStrategy",
            "label": "Sampling strategy",
            "type": "text",
            "description": "Sampling strategy (ref. EUROSTAT - Typology of sampling strategy, version of July 2009)"
          }, {
            "id": "samplingSize",
            "label": "Sampling size",
            "type": "text",
            "description": "Number of units, full participants, partial participants, eligibles, not eligible, unresolved (eligibility status not resolved)"
          }, {
            "id": "lotSizeUnit",
            "label": "Lot size unit",
            "type": "text",
            "description": "Unit in which the lot size is expressed"
          }, {
            "id": "samplingPoint",
            "label": "Sampling point",
            "type": "text",
            "description": "Point in the food chain where the sample was taken. (Doc. ESTAT/F5/ES/155 Data dictionary of activities of the establishments)"
          }, {
            "id": "samplingMethod",
            "label": "Sampling method",
            "type": "text",
            "description": "Sampling method used to take the sample"
          }, {
            "id": "typeOfSamplingProgram",
            "label": "Type of sampling program",
            "type": "text",
            "description": "Indicate the type of programm for which the samples have been collected"
          }, {
            "id": "samplingPlan",
            "label": "Sampling plan",
            "type": "text",
            "description": "Description of data collection technique: stratified or complex sampling (several stages)"
          }]
        },
        "modelMath": {
          "modelEquation": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "modelEquation": [{
              "id": "modelEquation",
              "label": "Equation",
              "type": "text",
              "description": "The pointer to the file that holds the software code (e.g. R-script)"
            }, {
              "id": "name",
              "label": "Model equation name",
              "type": "text",
              "description": "A name given to the model equation"
            }, {
              "id": "modelHypothesis",
              "label": "Hypothesis of the model",
              "description": "Description of the hypothesis of the model"
            }, {
              "id": "modelEquationClass",
              "label": "Model equation class",
              "type": "text",
              "description": "Information on that helps to categorize model equations"
            }]
          },
          "exposure": [{
            "id": "treatment",
            "label": "Left-censored data treatment",
            "description": "Description of the mathematical method to replace left-censored data (recommandation of WHO (2013), distribution or others)"
          }, {
            "id": "scenario",
            "label": "Scenario",
            "description": "Description of the different scenarios of exposure assessment"
          }, {
            "id": "uncertaintyEstimation",
            "label": "Uncertainty estimation",
            "type": "text",
            "description": "Analysis to estimate uncertainty"
          }, {
            "id": "type",
            "label": "Type of exposure",
            "type": "text",
            "description": "Description of the type of exposure"
          }, {
            "id": "contamination",
            "label": "Contam level post data treatment",
            "description": "Description of the range of of the level of contamination after left censored data treatment"
          }],
          "parameter": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "parameter": [{
              "id": "subject",
              "label": "Parameter subject",
              "type": "text",
              "description": "Scope of the parameter, e.g. if it refers to an animal, a batch of animals, a batch of products, a carcass, a carcass skin etc"
            }, {
              "id": "maxValue",
              "label": "Value max",
              "type": "text",
              "description": "Numerical value of the maximum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "dataType",
              "label": "Data type",
              "type": "text",
              "description": "Information on the data format of the parameter, e.g. if it is a categorical variable: int, double, array of size x,y,z "
            }, {
              "id": "description",
              "label": "Description",
              "type": "text",
              "description": "General description of the parameter"
            }, {
              "id": "source",
              "label": "Parameter source",
              "type": "text",
              "description": "Information on the type of knowledge used to define the parameter value"
            }, {
              "id": "classification",
              "label": "Parameter classification",
              "type": "text",
              "description": "General classification of the parameter (e.g. Input, Constant, Output etc)"
            }, {
              "id": "distribution",
              "label": "Parameter distribution",
              "type": "text",
              "description": "Distribution describing the parameter variabilty. If no distribution selected this means the value provided in 'Parameter value' is a point estimate. In case a distribution is selected the value provided in 'Parameter value' is a string that the model code can parse in order to sample from the named distribution"
            }, {
              "id": "error",
              "label": "Error",
              "type": "text",
              "description": "Error of the parameter value"
            }, {
              "id": "variabilitySubject",
              "label": "Parameter variability subject",
              "type": "text",
              "description": "Information on which the variability is described. It can be variability between broiler in a flock, variability between all meat packages sold in Denmark, variability between days, etc."
            }, {
              "id": "unit",
              "label": "Unit",
              "type": "text",
              "description": "Unit of the parameter"
            }, {
              "id": "minValue",
              "label": "Value min",
              "type": "text",
              "description": "Numerical value of the minimum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "unitCategory",
              "label": "Unit category",
              "type": "text",
              "description": "General classification of the parameter unit"
            }, {
              "id": "name",
              "label": "Parameter name",
              "type": "text",
              "description": "A name given to the parameter"
            }, {
              "id": "id",
              "label": "Parameter ID",
              "type": "text",
              "description": "An unambiguous ID given to each of the parameters - preferably autogenerated by a software tool and compatible with SBML ID requirements, only letters from A to Z, numbers and '_'"
            }, {
              "id": "value",
              "label": "Value",
              "type": "text",
              "description": "A default value for the parameter. This is mandatory (needs to be provided) for all parameters of type 'Input'"
            }]
          },
          "qualityMeasures": [{
            "id": "rsquared",
            "label": "R squared",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sse",
            "label": "SSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "rmse",
            "label": "RMSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "aic",
            "label": "AIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sensitivityAnalysis",
            "label": "Sensitivity analysis",
            "type": "long-text",
            "description": "Description of the results of an sensitivity analysis, i.e. how independence assumptions are met or how variables will affect the output of model"
          }, {
            "id": "bic",
            "label": "BIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "mse",
            "label": "MSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }],
          "modelMath": [{
            "id": "fittingProcedure",
            "label": "Fitting procedure",
            "type": "text",
            "description": "Procedure used to fit the data to the model equation"
          }, {
            "id": "event",
            "label": "Event",
            "description": "Definition of time-dependent parameter changes"
          }]
        },
        "scope": {
          "product": [{
            "id": "expiryDate",
            "label": "Expiration date",
            "type": "date",
            "description": "Expiry date of food/product"
          }, {
            "id": "treatment",
            "label": "Treatment",
            "description": "Used to characterise a product/matrix based on the treatment or processes applied to the product or any indexed ingredient"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the product, matrix or environment for which the model or data applies"
          }, {
            "id": "productionDate",
            "label": "Production date",
            "type": "date",
            "description": "Date of production of food/product"
          }, {
            "id": "method",
            "label": "Method of production",
            "description": "Type of production for the product/ matrix"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "The product, matrix or environment (e.g food product, lab media, soil etc.) for which the model or data applies"
          }, {
            "id": "originCountry",
            "label": "Country of origin",
            "type": "text",
            "description": "Country of origin of the food/product (ISO 3166-1-alpha-2 country code)"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Detailed description of the product, matrix or environment for which the model or data applies"
          }, {
            "id": "packaging",
            "label": "Packaging",
            "description": "Describe container or wrapper that holds the product/matrix. Common type of packaging (paper or plastic bags, boxes, tinplate or aluminium cans, plastic trays, plastic bottles, glass bottles or jars)"
          }, {
            "id": "fisheriesArea",
            "label": "Fisheries area",
            "type": "text",
            "description": "Fisheries or aquaculture area specifying the origin of the sample (FAO Fisheries areas)."
          }, {
            "id": "originArea",
            "label": "Area of origin",
            "type": "text",
            "description": "Area of origin of the food/product (Nomenclature of territorial units for statistics  NUTS  coding system valid only for EEA and Switzerland)."
          }],
          "populationGroup": [{
            "id": "populationRiskFactor",
            "label": "Risk and population factors",
            "description": "Population risk factor that may influence the outcomes of the study, confounder should be included"
          }, {
            "id": "country",
            "label": "Country",
            "description": "Country on which the population group of the model or data applies"
          }, {
            "id": "populationSpan",
            "label": "Population span (years)",
            "description": "Temporal information on the exposure duration"
          }, {
            "id": "populationGender",
            "label": "Population gender",
            "type": "text",
            "description": "Description of the percentage of gender"
          }, {
            "id": "populationDescription",
            "label": "Description",
            "description": "Description of the population for which the model applies (demographic and socio-economic characteristics for example). Background information that are needed in the data analysis phase, size of household, education level, employment status, professional category, ethnicity, etc."
          }, {
            "id": "populationAge",
            "label": "Population age",
            "description": "Description of the range of age or group of age"
          }, {
            "id": "patternConsumption",
            "label": "Consumption pattern",
            "description": "Description of the consumption of different food items, frequency, portion size"
          }, {
            "id": "name",
            "label": "Population name",
            "type": "text",
            "description": "Name of the population for which the model or data applies"
          }, {
            "id": "season",
            "label": "Season",
            "description": "Distribution of surveyed people according to the season (influence consumption pattern)"
          }, {
            "id": "region",
            "label": "Region",
            "description": "Spatial information (area) on which the population group of the model or data applies"
          }, {
            "id": "targetPopulation",
            "label": "Target population",
            "type": "text",
            "description": "Population of individual that we are interested in describing and making statistical inferences about"
          }, {
            "id": "bmi",
            "label": "BMI",
            "description": "Description of the range of BMI or class of BMI or BMI mean"
          }, {
            "id": "specialDietGroups",
            "label": "Special diet groups",
            "description": "Description of sub-population with special diets (vegetarians, diabetics, group following special ethnic diets)"
          }],
          "hazard": [{
            "id": "maximumResidueLimit",
            "label": "Maximum Residue Limit (MRL)",
            "type": "text",
            "description": "International regulations and permissible maximum residue levels in food and drinking water"
          }, {
            "id": "sourceOfContamination",
            "label": "Source of contamination",
            "type": "text",
            "description": "rigin of the contamination, source"
          }, {
            "id": "indSum",
            "label": "Individual or Summed Hazard",
            "type": "text",
            "description": "Define if the parameter reported is an individual residue/analyte, a summed residue definition or part of a sum a summed residue definition"
          }, {
            "id": "acceptableOperatorsExposureLevel",
            "label": "Acceptable Operator Exposure Level (AOEL)",
            "type": "text",
            "description": "Maximum amount of active substance to which the operator may be exposed without any adverse health effects. The AOEL is expressed as milligrams of the chemical per kilogram body weight of the operator"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Description of the hazard for which the model or data applies"
          }, {
            "id": "type",
            "label": "Hazard type",
            "type": "text",
            "description": "General classification of the hazard for which the model or data applies"
          }, {
            "id": "adverseEffect",
            "label": "Adverse effect",
            "type": "text",
            "description": "Adverse effect induced by hazard about morbidity, mortality, and etcetera"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the hazard for which the model or data applies"
          }, {
            "id": "noObservedAdverseAffectLevel",
            "label": "No Observed Adverse Affect Level (NOAEL)",
            "type": "text",
            "description": "Level of exposure of an organism, found by experiment or observation, at which there is no biologically or statistically significant increase in the frequency or severity of any adverse effects in the exposed population when compared to its appropriate control"
          }, {
            "id": "acuteReferenceDose",
            "label": "Acute Reference Dose (ARfD)",
            "type": "text",
            "description": "An estimate (with uncertainty spanning perhaps an order of magnitude) of a daily oral exposure for an acute duration (24 hours or less) to the human population (including sensitive subgroups) that is likely to be without an appreciable risk of deleterious effects during a lifetime"
          }, {
            "id": "name",
            "label": "Hazard name",
            "type": "text",
            "description": "Name of the hazard (agent, contaminant, chemical) for which the data or model applies"
          }, {
            "id": "lowestObservedAdverseAffectLevel",
            "label": "Lowest Observed Adverse Effect Level (LOAEL)",
            "type": "text",
            "description": "Lowest concentration or amount of a substance found by experiment or observation that causes an adverse alteration of morphology, function, capacity, growth, development, or lifespan of a target organism distinguished from normal organisms of the same species under defined conditions of exposure"
          }, {
            "id": "benchmarkDose",
            "label": "Benchmark Dose (BMD)",
            "type": "text",
            "description": "A dose or concentration that produces a predetermined change in response rate of an adverse effect (called the benchmark response or BMR) compared to background"
          }, {
            "id": "acceptableDailyIntake",
            "label": "Acceptable Daily Intake (ADI)",
            "type": "text",
            "description": "Measure of amount of a specific substance in food or in drinking water tahta can be ingested (orally) on a daily basis over a lifetime without an appreciable health risk"
          }],
          "scope": [{
            "id": "spatialInformation",
            "label": "Spatial information",
            "description": "Spatial information (area) on which the model or data applies"
          }, {
            "id": "generalComment",
            "label": "General comment",
            "type": "long-text",
            "description": "General comments on the scope of the study, data or model"
          }, {
            "id": "temporalInformation",
            "label": "Temporal information",
            "type": "long-text",
            "description": "Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)"
          }]
        },
        "generalInformation": {
          "creator": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "author": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "reference": [{
            "id": "date",
            "label": "Date",
            "type": "year_date",
            "description": "Temporal information on the publication date"
          }, {
            "id": "website",
            "label": "Website",
            "type": "text",
            "description": "A link to the publication website (different from DOI)"
          }, {
            "id": "issue",
            "label": "Issue",
            "type": "text",
            "description": "Data on the details of the issue in which the model or date has been described"
          }, {
            "id": "publicationType",
            "label": "Publication type",
            "type": "text",
            "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
          }, {
            "id": "abstract",
            "label": "Abstract",
            "type": "text",
            "description": "Abstract of the publication in which the model or the data has been described "
          }, {
            "id": "isReferenceDescription",
            "label": "Is_reference_description?",
            "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
          }, {
            "id": "title",
            "label": "Title",
            "type": "long-text",
            "description": "Title of publication in which the model or date has been described"
          }, {
            "id": "pmid",
            "label": "PubMed ID",
            "type": "text",
            "description": "The PubMed ID related to this publication"
          }, {
            "id": "volume",
            "label": "Volume",
            "type": "text",
            "description": "Data on the details of the volume in which the model or date has been described"
          }, {
            "id": "journal",
            "label": "Journal",
            "type": "long-text",
            "description": "Data on the details of the journal in which the model or date has been described"
          }, {
            "id": "authorList",
            "label": "Author list",
            "type": "long-text",
            "description": "Name and surname of the authors who contributed to this publication"
          }, {
            "id": "comment",
            "label": "Comment",
            "type": "long-text",
            "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
          }, {
            "id": "doi",
            "label": "Publication DOI",
            "type": "long-text",
            "description": "The DOI related to this publication"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The status of this publication, e.g. Published, Submitted, etc."
          }],
          "modelCategory": [{
            "id": "modelClassComment",
            "label": "Comment",
            "type": "long-text",
            "description": "Comment with further details on the model class"
          }, {
            "id": "basicProcess",
            "label": "Basic process",
            "description": "Defines the impact of the process on the hazard (so far only valid for process models and predictive models)"
          }, {
            "id": "modelClass",
            "label": "Model class",
            "type": "text",
            "description": "Type of model according to RAKIP classification"
          }, {
            "id": "modelSubClass",
            "label": "Subclass",
            "description": "Sub-classification of the model given the Model Class"
          }],
          "generalInformation": [{
            "id": "identifier",
            "label": "Identifier",
            "type": "text",
            "description": "An unambiguous ID given to the model or data. This can also be created automatically by a software tool"
          }, {
            "id": "software",
            "label": "Software",
            "type": "text",
            "description": "The program or software language in which the model has been implemented"
          }, {
            "id": "format",
            "label": "Format",
            "type": "text",
            "description": "File extension of the model or data file (including version number of format if applicable)"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the study, data or model"
          }, {
            "id": "language",
            "label": "Language",
            "type": "text",
            "description": "A language of the resource (some data or reports can be available in French language for example)"
          }, {
            "id": "source",
            "label": "Source",
            "type": "text",
            "description": "A source from which the model/data is derived"
          }, {
            "id": "availability",
            "label": "Availability",
            "type": "text",
            "description": "Availability of data or model, i.e. if the annotated model code / data is included in this FSK file"
          }, {
            "id": "creationDate",
            "label": "Creation date",
            "type": "date",
            "description": "Creation date/time of the FSK file"
          }, {
            "id": "url",
            "label": "URL",
            "type": "text",
            "description": "Web address referencing the resource location (data for example)"
          }, {
            "id": "objective",
            "label": "Objective",
            "type": "long-text",
            "description": "Objective of the model or data"
          }, {
            "id": "modificationDate",
            "label": "Modification date",
            "description": "Date/time of the last version of the FSK file"
          }, {
            "id": "rights",
            "label": "Rights",
            "type": "text",
            "description": "Rights granted for usage, distribution and modification of this FSK file"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "A name given to the model or data"
          }, {
            "id": "languageWrittenIn",
            "label": "Language written in",
            "type": "text",
            "description": "Software language used to write the model, e.g. R or MatLab"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The curation status of the model"
          }]
        }
      };
    }
    // Validate this.panels and return boolean
  }, {
    key: "validate",
    value: function validate() {
      var isValid = true;
      if (!this.panels.generalInformation.validate()) isValid = false;
      if (!this.panels.modelCategory.validate()) isValid = false;
      if (!this.panels.scopeGeneral.validate()) isValid = false;
      if (!this.panels.study.validate()) isValid = false;
      return isValid;
    }
  }, {
    key: "_createPanels",
    value: function _createPanels() {
      var _ref;
      var port = window.port || -1;
      var schema = schemas.genericModel;
      return _ref = {
        study: new _FormPanel.FormPanel("Study", this.jsonSchema.dataBackground.study, this._metadata.dataBackground ? this._metadata.dataBackground.study : {}, port),
        laboratory: new _TablePanel.TablePanel("Laboratory", this.jsonSchema.dataBackground.laboratory, this._metadata.dataBackground ? this._metadata.dataBackground.laboratory : {}, port),
        assay: new _TablePanel.TablePanel("Assay", this.jsonSchema.dataBackground.assay, this._metadata.dataBackground ? this._metadata.dataBackground.assay : {}, port),
        dietaryAssessmentMethod: new _TablePanel.TablePanel("Dietary Assessment Method", this.jsonSchema.dataBackground.dietaryAssessmentMethod, this._metadata.dataBackground ? this._metadata.dataBackground.dietaryAssessmentMethod : {}, port),
        studySample: new _TablePanel.TablePanel("Study Sample", this.jsonSchema.dataBackground.studySample, this._metadata.dataBackground ? this._metadata.dataBackground.studySample : {}, port),
        modelMath: new _FormPanel.FormPanel("Model Math", this.jsonSchema.modelMath.modelMath, this._metadata.modelMath, port),
        modelEquation: new _TablePanel.TablePanel("Model Equation", this.jsonSchema.modelMath.modelEquation.modelEquation, this._metadata.modelMath ? this._metadata.modelMath.modelEquation : {}, port),
        reference: new _TablePanel.TablePanel("Reference", this.jsonSchema.modelMath.modelEquation.reference, this._metadata.modelMath.modelEquation ? this._metadata.modelMath.modelEquation.reference : {}, port),
        exposure: new _TablePanel.TablePanel("Exposure", this.jsonSchema.modelMath.exposure, this._metadata.modelMath ? this._metadata.modelMath.exposure : {}, port),
        parameter: new _TablePanel.TablePanel("Parameter", this.jsonSchema.modelMath.parameter.parameter, this._metadata.modelMath ? this._metadata.modelMath.parameter : {}, port)
      }, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref, "reference", new _FormPanel.FormPanel("Reference", this.jsonSchema.modelMath.parameter.reference, this._metadata.modelMath.parameter ? this._metadata.modelMath.parameter.reference : {}, port)), "qualityMeasures", new _TablePanel.TablePanel("Quality Measures", this.jsonSchema.modelMath.qualityMeasures, this._metadata.modelMath ? this._metadata.modelMath.qualityMeasures : {}, port)), "scope", new _FormPanel.FormPanel("Scope", this.jsonSchema.scope.scope, this._metadata.scope, port)), "product", new _TablePanel.TablePanel("Product", this.jsonSchema.scope.product, this._metadata.scope ? this._metadata.scope.product : {}, port)), "populationGroup", new _TablePanel.TablePanel("Population Group", this.jsonSchema.scope.populationGroup, this._metadata.scope ? this._metadata.scope.populationGroup : {}, port)), "hazard", new _TablePanel.TablePanel("Hazard", this.jsonSchema.scope.hazard, this._metadata.scope ? this._metadata.scope.hazard : {}, port)), "generalInformation", new _FormPanel.FormPanel("General Information", this.jsonSchema.generalInformation.generalInformation, this._metadata.generalInformation, port)), "creator", new _TablePanel.TablePanel("Creator", this.jsonSchema.generalInformation.creator, this._metadata.generalInformation ? this._metadata.generalInformation.creator : {}, port)), "author", new _TablePanel.TablePanel("Author", this.jsonSchema.generalInformation.author, this._metadata.generalInformation ? this._metadata.generalInformation.author : {}, port)), "reference", new _TablePanel.TablePanel("Reference", this.jsonSchema.generalInformation.reference, this._metadata.generalInformation ? this._metadata.generalInformation.reference : {}, port)), _defineProperty(_ref, "modelCategory", new _FormPanel.FormPanel("Model Category", this.jsonSchema.generalInformation.modelCategory, this._metadata.generalInformation ? this._metadata.generalInformation.modelCategory : {}, port));
    }
  }]);
}(_ModelView2.ModelView);

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./GenericModelDataBackgroundView":97,"./GenericModelGeneralInformationView":99,"./GenericModelModelMathView":101,"./GenericModelScopeView":103,"./ModelView":118}],105:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Hazard = void 0;
var _ApiClient = require("../ApiClient");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Hazard model module.
 * @module model/Hazard
 * @version 1.0.0
 */
var Hazard = exports.Hazard = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>Hazard</code>.
   * @alias module:model/Hazard
   * @class
   * @param name {} Name of the hazard (agent, contaminant, chemical) for which the data or model applies
   */
  function Hazard(name) {
    _classCallCheck(this, Hazard);
    this.name = name;
  }

  /**
   * Constructs a <code>Hazard</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/Hazard} obj Optional instance to populate.
   * @return {module:model/Hazard} The populated <code>Hazard</code> instance.
   */
  return _createClass(Hazard, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new Hazard();
        if (data.hasOwnProperty('maximumResidueLimit')) obj.maximumResidueLimit = _ApiClient.ApiClient.convertToType(data['maximumResidueLimit'], 'String');
        if (data.hasOwnProperty('sourceOfContamination')) obj.sourceOfContamination = _ApiClient.ApiClient.convertToType(data['sourceOfContamination'], 'String');
        if (data.hasOwnProperty('indSum')) obj.indSum = _ApiClient.ApiClient.convertToType(data['indSum'], 'String');
        if (data.hasOwnProperty('acceptableOperatorsExposureLevel')) obj.acceptableOperatorsExposureLevel = _ApiClient.ApiClient.convertToType(data['acceptableOperatorsExposureLevel'], 'String');
        if (data.hasOwnProperty('description')) obj.description = _ApiClient.ApiClient.convertToType(data['description'], 'String');
        if (data.hasOwnProperty('type')) obj.type = _ApiClient.ApiClient.convertToType(data['type'], 'String');
        if (data.hasOwnProperty('adverseEffect')) obj.adverseEffect = _ApiClient.ApiClient.convertToType(data['adverseEffect'], 'String');
        if (data.hasOwnProperty('unit')) obj.unit = _ApiClient.ApiClient.convertToType(data['unit'], 'String');
        if (data.hasOwnProperty('noObservedAdverseAffectLevel')) obj.noObservedAdverseAffectLevel = _ApiClient.ApiClient.convertToType(data['noObservedAdverseAffectLevel'], 'String');
        if (data.hasOwnProperty('acuteReferenceDose')) obj.acuteReferenceDose = _ApiClient.ApiClient.convertToType(data['acuteReferenceDose'], 'String');
        if (data.hasOwnProperty('name')) obj.name = _ApiClient.ApiClient.convertToType(data['name'], 'String');
        if (data.hasOwnProperty('lowestObservedAdverseAffectLevel')) obj.lowestObservedAdverseAffectLevel = _ApiClient.ApiClient.convertToType(data['lowestObservedAdverseAffectLevel'], 'String');
        if (data.hasOwnProperty('benchmarkDose')) obj.benchmarkDose = _ApiClient.ApiClient.convertToType(data['benchmarkDose'], 'String');
        if (data.hasOwnProperty('acceptableDailyIntake')) obj.acceptableDailyIntake = _ApiClient.ApiClient.convertToType(data['acceptableDailyIntake'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * International regulations and permissible maximum residue levels in food and drinking water
 * @member {String} maximumResidueLimit
 */
Hazard.prototype.maximumResidueLimit = undefined;

/**
 * rigin of the contamination, source
 * @member {String} sourceOfContamination
 */
Hazard.prototype.sourceOfContamination = undefined;

/**
 * Define if the parameter reported is an individual residue/analyte, a summed residue definition or part of a sum a summed residue definition
 * @member {String} indSum
 */
Hazard.prototype.indSum = undefined;

/**
 * Maximum amount of active substance to which the operator may be exposed without any adverse health effects. The AOEL is expressed as milligrams of the chemical per kilogram body weight of the operator
 * @member {String} acceptableOperatorsExposureLevel
 */
Hazard.prototype.acceptableOperatorsExposureLevel = undefined;

/**
 * Description of the hazard for which the model or data applies
 * @member {String} description
 */
Hazard.prototype.description = undefined;

/**
 * General classification of the hazard for which the model or data applies
 * @member {String} type
 */
Hazard.prototype.type = undefined;

/**
 * Adverse effect induced by hazard about morbidity, mortality, and etcetera
 * @member {String} adverseEffect
 */
Hazard.prototype.adverseEffect = undefined;

/**
 * Unit of the hazard for which the model or data applies
 * @member {String} unit
 */
Hazard.prototype.unit = undefined;

/**
 * Level of exposure of an organism, found by experiment or observation, at which there is no biologically or statistically significant increase in the frequency or severity of any adverse effects in the exposed population when compared to its appropriate control
 * @member {String} noObservedAdverseAffectLevel
 */
Hazard.prototype.noObservedAdverseAffectLevel = undefined;

/**
 * An estimate (with uncertainty spanning perhaps an order of magnitude) of a daily oral exposure for an acute duration (24 hours or less) to the human population (including sensitive subgroups) that is likely to be without an appreciable risk of deleterious effects during a lifetime
 * @member {String} acuteReferenceDose
 */
Hazard.prototype.acuteReferenceDose = undefined;

/**
 * Name of the hazard (agent, contaminant, chemical) for which the data or model applies
 * @member {String} name
 */
Hazard.prototype.name = undefined;

/**
 * Lowest concentration or amount of a substance found by experiment or observation that causes an adverse alteration of morphology, function, capacity, growth, development, or lifespan of a target organism distinguished from normal organisms of the same species under defined conditions of exposure
 * @member {String} lowestObservedAdverseAffectLevel
 */
Hazard.prototype.lowestObservedAdverseAffectLevel = undefined;

/**
 * A dose or concentration that produces a predetermined change in response rate of an adverse effect (called the benchmark response or BMR) compared to background
 * @member {String} benchmarkDose
 */
Hazard.prototype.benchmarkDose = undefined;

/**
 * Measure of amount of a specific substance in food or in drinking water tahta can be ingested (orally) on a daily basis over a lifetime without an appreciable health risk
 * @member {String} acceptableDailyIntake
 */
Hazard.prototype.acceptableDailyIntake = undefined;

},{"../ApiClient":44}],106:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HazardView = void 0;
var _ApiClient = require("../ApiClient");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Hazard View  module.
 * @module model/Hazard
 * @version 1.0.0
 */
var HazardView = exports.HazardView = /*#__PURE__*/_createClass(function HazardView() {
  _classCallCheck(this, HazardView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63}],107:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HealthModel = void 0;
var _ApiClient = require("../ApiClient");
var _GenericModelModelMath = require("./GenericModelModelMath");
var _HealthModelScope = require("./HealthModelScope");
var _Model2 = require("./Model");
var _PredictiveModelDataBackground = require("./PredictiveModelDataBackground");
var _PredictiveModelGeneralInformation = require("./PredictiveModelGeneralInformation");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The HealthModel model module.
 * @module model/HealthModel
 * @version 1.0.0
 */
var HealthModel = exports.HealthModel = /*#__PURE__*/function (_Model) {
  /**
   * Constructs a new <code>HealthModel</code>.
   * @alias module:model/HealthModel
   * @class
   * @extends module:model/Model
   * @param modelType {} 
   */
  function HealthModel(modelType) {
    _classCallCheck(this, HealthModel);
    return _callSuper(this, HealthModel, [modelType]);
  }

  /**
   * Constructs a <code>HealthModel</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/HealthModel} obj Optional instance to populate.
   * @return {module:model/HealthModel} The populated <code>HealthModel</code> instance.
   */
  _inherits(HealthModel, _Model);
  return _createClass(HealthModel, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new HealthModel();
        _Model2.Model.constructFromObject(data, obj);
        if (data.hasOwnProperty('dataBackground')) obj.dataBackground = _PredictiveModelDataBackground.PredictiveModelDataBackground.constructFromObject(data['dataBackground']);
        if (data.hasOwnProperty('modelMath')) obj.modelMath = _GenericModelModelMath.GenericModelModelMath.constructFromObject(data['modelMath']);
        if (data.hasOwnProperty('scope')) obj.scope = _HealthModelScope.HealthModelScope.constructFromObject(data['scope']);
        if (data.hasOwnProperty('generalInformation')) obj.generalInformation = _PredictiveModelGeneralInformation.PredictiveModelGeneralInformation.constructFromObject(data['generalInformation']);
      }
      return obj;
    }
  }]);
}(_Model2.Model);
/**
 * @member {module:model/PredictiveModelDataBackground} dataBackground
 */
HealthModel.prototype.dataBackground = undefined;

/**
 * @member {module:model/GenericModelModelMath} modelMath
 */
HealthModel.prototype.modelMath = undefined;

/**
 * @member {module:model/HealthModelScope} scope
 */
HealthModel.prototype.scope = undefined;

/**
 * @member {module:model/PredictiveModelGeneralInformation} generalInformation
 */
HealthModel.prototype.generalInformation = undefined;

},{"../ApiClient":44,"./GenericModelModelMath":100,"./HealthModelScope":108,"./Model":113,"./PredictiveModelDataBackground":134,"./PredictiveModelGeneralInformation":136}],108:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HealthModelScope = void 0;
var _ApiClient = require("../ApiClient");
var _Hazard = require("./Hazard");
var _PopulationGroup = require("./PopulationGroup");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The HealthModelScope model module.
 * @module model/HealthModelScope
 * @version 1.0.0
 */
var HealthModelScope = exports.HealthModelScope = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>HealthModelScope</code>.
   * @alias module:model/HealthModelScope
   * @class
   */
  function HealthModelScope() {
    _classCallCheck(this, HealthModelScope);
  }

  /**
   * Constructs a <code>HealthModelScope</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/HealthModelScope} obj Optional instance to populate.
   * @return {module:model/HealthModelScope} The populated <code>HealthModelScope</code> instance.
   */
  return _createClass(HealthModelScope, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new HealthModelScope();
        if (data.hasOwnProperty('spatialInformation')) obj.spatialInformation = _ApiClient.ApiClient.convertToType(data['spatialInformation'], ['String']);
        if (data.hasOwnProperty('populationGroup')) obj.populationGroup = _ApiClient.ApiClient.convertToType(data['populationGroup'], [_PopulationGroup.PopulationGroup]);
        if (data.hasOwnProperty('hazard')) obj.hazard = _ApiClient.ApiClient.convertToType(data['hazard'], [_Hazard.Hazard]);
        if (data.hasOwnProperty('generalComment')) obj.generalComment = _ApiClient.ApiClient.convertToType(data['generalComment'], 'String');
        if (data.hasOwnProperty('temporalInformation')) obj.temporalInformation = _ApiClient.ApiClient.convertToType(data['temporalInformation'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * Spatial information (area) on which the model or data applies
 * @member {Array.<String>} spatialInformation
 */
HealthModelScope.prototype.spatialInformation = undefined;

/**
 * @member {Array.<module:model/PopulationGroup>} populationGroup
 */
HealthModelScope.prototype.populationGroup = undefined;

/**
 * @member {Array.<module:model/Hazard>} hazard
 */
HealthModelScope.prototype.hazard = undefined;

/**
 * General comments on the scope of the study, data or model
 * @member {String} generalComment
 */
HealthModelScope.prototype.generalComment = undefined;

/**
 * Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)
 * @member {String} temporalInformation
 */
HealthModelScope.prototype.temporalInformation = undefined;

},{"../ApiClient":44,"./Hazard":105,"./PopulationGroup":131}],109:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HealthModelScopeView = void 0;
var _ApiClient = require("../ApiClient");
var _HazardView = require("./HazardView");
var _PopulationGroupView = require("./PopulationGroupView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The HealthModelScope View  module.
 * @module model/HealthModelScope
 * @version 1.0.0
 */
var HealthModelScopeView = exports.HealthModelScopeView = /*#__PURE__*/_createClass(function HealthModelScopeView() {
  _classCallCheck(this, HealthModelScopeView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./HazardView":106,"./PopulationGroupView":132}],110:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HealthModelView = void 0;
var _ApiClient = require("../ApiClient");
var _GenericModelModelMathView = require("./GenericModelModelMathView");
var _HealthModelScopeView = require("./HealthModelScopeView");
var _ModelView2 = require("./ModelView");
var _PredictiveModelDataBackgroundView = require("./PredictiveModelDataBackgroundView");
var _PredictiveModelGeneralInformationView = require("./PredictiveModelGeneralInformationView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The HealthModel View  module.
 * @module model/HealthModel
 * @version 1.0.0
 */
var HealthModelView = exports.HealthModelView = /*#__PURE__*/function (_ModelView) {
  function HealthModelView(metadata, img, state, modelScript, visScript, readme) {
    var _this;
    _classCallCheck(this, HealthModelView);
    _this = _callSuper(this, HealthModelView, [metadata, img, modelScript, visScript, readme]);
    _this._schema = schemas.genericModel;
    if (state) {
      _this.panels = _this._createPanels();
    }
    _this._menu = [{
      "label": "General Information",
      "id": "generalInformation",
      "submenus": [{
        "label": "General Information",
        "id": "generalInformation"
      }, {
        "label": "Model Category",
        "id": "modelCategory"
      }, {
        "label": "Reference",
        "id": "reference"
      }, {
        "label": "Author",
        "id": "author"
      }, {
        "label": "Creator",
        "id": "creator"
      }]
    }, {
      "label": "Scope",
      "id": "scope",
      "submenus": [{
        "label": "Scope",
        "id": "scope"
      }, {
        "label": "Hazard",
        "id": "hazard"
      }, {
        "label": "Population Group",
        "id": "populationGroup"
      }]
    }, {
      "label": "Model Math",
      "id": "modelMath",
      "submenus": [{
        "label": "Model Math",
        "id": "modelMath"
      }, {
        "label": "Quality Measures",
        "id": "qualityMeasures"
      }, {
        "label": "Parameter",
        "id": "parameter",
        "submenus": [{
          "label": "Parameter",
          "id": "parameter"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }, {
        "label": "Exposure",
        "id": "exposure"
      }, {
        "label": "Model Equation",
        "id": "modelEquation",
        "submenus": [{
          "label": "Model Equation",
          "id": "modelEquation"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }]
    }, {
      "label": "Data Background",
      "id": "dataBackground",
      "submenus": [{
        "label": "Study Sample",
        "id": "studySample"
      }, {
        "label": "Assay",
        "id": "assay"
      }, {
        "label": "Laboratory",
        "id": "laboratory"
      }, {
        "label": "Study",
        "id": "study"
      }]
    }];
    _this._panels = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
      study: {
        type: 'simple',
        schema: _this.jsonSchema.dataBackgroundstudy,
        metadata: _this._metadata.study
      },
      laboratory: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundlaboratory,
        metadata: _this._metadata.laboratory
      },
      assay: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundassay,
        metadata: _this._metadata.assay
      },
      studySample: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundstudySample,
        metadata: _this._metadata.studySample
      },
      modelMath: {
        type: 'simple',
        schema: _this.jsonSchema.modelMathmodelMath,
        metadata: _this._metadata.modelMath
      },
      modelEquation: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationmodelEquation,
        metadata: _this._metadata.modelEquation
      },
      reference: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationreference,
        metadata: _this._metadata.reference
      },
      exposure: {
        type: 'complex',
        schema: _this.jsonSchema.modelMathexposure,
        metadata: _this._metadata.exposure
      },
      parameter: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.parameterparameter,
        metadata: _this._metadata.parameter
      }
    }, "reference", {
      type: 'simple',
      schema: _this.jsonSchema.modelMath.parameterreference,
      metadata: _this._metadata.reference
    }), "qualityMeasures", {
      type: 'complex',
      schema: _this.jsonSchema.modelMathqualityMeasures,
      metadata: _this._metadata.qualityMeasures
    }), "scope", {
      type: 'simple',
      schema: _this.jsonSchema.scopescope,
      metadata: _this._metadata.scope
    }), "populationGroup", {
      type: 'complex',
      schema: _this.jsonSchema.scopepopulationGroup,
      metadata: _this._metadata.populationGroup
    }), "hazard", {
      type: 'complex',
      schema: _this.jsonSchema.scopehazard,
      metadata: _this._metadata.hazard
    }), "generalInformation", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationgeneralInformation,
      metadata: _this._metadata.generalInformation
    }), "creator", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationcreator,
      metadata: _this._metadata.creator
    }), "author", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationauthor,
      metadata: _this._metadata.author
    }), "reference", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationreference,
      metadata: _this._metadata.reference
    }), "modelCategory", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationmodelCategory,
      metadata: _this._metadata.modelCategory
    });
    return _this;
  }
  _inherits(HealthModelView, _ModelView);
  return _createClass(HealthModelView, [{
    key: "metaData",
    get: function get() {
      try {
        this._metadata.dataBackground.study = this.panels.study.data;
        this._metadata.dataBackground.laboratory = this.panels.laboratory.data;
        this._metadata.dataBackground.assay = this.panels.assay.data;
        this._metadata.dataBackground.studySample = this.panels.studySample.data;
        this._metadata.modelMath = this.panels.modelMath.data;
        this._metadata.modelMath.modelEquation = this.panels.modelEquation.data;
        this._metadata.modelMath.modelEquation.reference = this.panels.reference.data;
        this._metadata.modelMath.exposure = this.panels.exposure.data;
        this._metadata.modelMath.parameter = this.panels.parameter.data;
        this._metadata.modelMath.parameter.reference = this.panels.reference.data;
        this._metadata.modelMath.qualityMeasures = this.panels.qualityMeasures.data;
        this._metadata.scope = this.panels.scope.data;
        this._metadata.scope.populationGroup = this.panels.populationGroup.data;
        this._metadata.scope.hazard = this.panels.hazard.data;
        this._metadata.generalInformation = this.panels.generalInformation.data;
        this._metadata.generalInformation.creator = this.panels.creator.data;
        this._metadata.generalInformation.author = this.panels.author.data;
        this._metadata.generalInformation.reference = this.panels.reference.data;
        this._metadata.generalInformation.modelCategory = this.panels.modelCategory.data;
        this._metadata.modelType = "HealthModel";
        this._metadata = metadataFix(this._metadata);
      } catch (error) {
        console.log(error);
      }
      return this._metadata;
    }
  }, {
    key: "jsonSchema",
    get: function get() {
      return {
        "dataBackground": {
          "study": [{
            "id": "identifier",
            "label": "Study identifier",
            "type": "text",
            "description": "A user defined identifier for the study"
          }, {
            "id": "protocolComponentsName",
            "label": "Components names",
            "type": "text",
            "description": "The names of the components used when carrying out this protocol"
          }, {
            "id": "designType",
            "label": "Design type",
            "type": "text",
            "description": "The type of study design being employed"
          }, {
            "id": "assayMeasurementType",
            "label": "Assay measurement type",
            "type": "text",
            "description": "The measurement being observed in this assay"
          }, {
            "id": "protocolComponentsType",
            "label": "Protocol components type",
            "type": "text",
            "description": "Description"
          }, {
            "id": "description",
            "label": "Study description",
            "type": "long-text",
            "description": "A brief description of the study aims"
          }, {
            "id": "assayTechnologyPlatform",
            "label": "Assay technology platform",
            "type": "text",
            "description": "The technology platform used"
          }, {
            "id": "assayTechnologyType",
            "label": "Assay technology type",
            "type": "text",
            "description": "The technology being employed to observe this measurement"
          }, {
            "id": "protocolType",
            "label": "Protocol type",
            "type": "text",
            "description": "The type of the protocol, preferably coming from an Ontology, e.g. Extraction Protocol"
          }, {
            "id": "title",
            "label": "Study title",
            "type": "long-text",
            "description": "A title for the study"
          }, {
            "id": "protocolDescription",
            "label": "Protocol description",
            "type": "long-text",
            "description": "A description of the protocol"
          }, {
            "id": "protocolParametersName",
            "label": "Parameters names",
            "type": "text",
            "description": "The parameters used when executing this protocol"
          }, {
            "id": "protocolName",
            "label": "Protocol name",
            "type": "text",
            "description": "The name of the protocol, e.g.Extraction Protocol"
          }, {
            "id": "protocolVersion",
            "label": "Protocol version",
            "type": "text",
            "description": "The version of the protocol used, where applicable."
          }, {
            "id": "protocolURI",
            "label": "Protocol URI",
            "type": "text",
            "description": "A URI to link out to a publication, web page, etc. describing the protocol"
          }, {
            "id": "accreditationProcedureForTheAssayTechnology",
            "label": "Accreditation procedure for assay",
            "type": "text",
            "description": "Accreditation procedure for the analytical method used"
          }],
          "laboratory": [{
            "id": "country",
            "label": "Laboratory country",
            "type": "text",
            "description": "Country where the laboratory is placed. (ISO 3166-1-alpha-2)"
          }, {
            "id": "name",
            "label": "Laboratory name",
            "type": "text",
            "description": "Laboratory code (National laboratory code if available) or Laboratory name "
          }, {
            "id": "accreditation",
            "label": "Laboratory accreditation",
            "description": "The laboratory accreditation to ISO/IEC 17025"
          }],
          "assay": [{
            "id": "contaminationRange",
            "label": "Range of contamination",
            "type": "text",
            "description": "Range of result of the analytical measure reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "uncertaintyValue",
            "label": "Uncertainty value",
            "type": "text",
            "description": "Indicate the expanded uncertainty (usually 95% confidence interval) value associated with the measurement expressed in the unit reported in the field Hazard unit"
          }, {
            "id": "fatPercentage",
            "label": "Percentage of fat",
            "type": "text",
            "description": "Percentage of fat in the original sample"
          }, {
            "id": "name",
            "label": "Assay name",
            "type": "text",
            "description": "A name given to the assay"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the assay. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "moisturePercentage",
            "label": "Percentage of moisture",
            "type": "text",
            "description": "Percentage of moisture in the original sample"
          }, {
            "id": "leftCensoredData",
            "label": "Left-censored data",
            "type": "text",
            "description": "Percentage of measures equal to LOQ and/or LOD"
          }, {
            "id": "detectionLimit",
            "label": "Limit of detection",
            "type": "text",
            "description": "Limit of detection reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "quantificationLimit",
            "label": "Limit of quantification",
            "type": "text",
            "description": "Limit of quantification reported in the unit specified by the variable Hazard unit"
          }],
          "studySample": [{
            "id": "sampleName",
            "label": "Name",
            "type": "text",
            "description": "An unambiguous ID given to the samples used in the assay"
          }, {
            "id": "samplingWeight",
            "label": "Sampling weight",
            "type": "text",
            "description": "Description of the method employed to compute sampling weight (nonresponse-adjusted weight)"
          }, {
            "id": "protocolOfSampleCollection",
            "label": "Protocol of sample collection",
            "type": "text",
            "description": "Additional protocol for sample and sample collection. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "samplingStrategy",
            "label": "Sampling strategy",
            "type": "text",
            "description": "Sampling strategy (ref. EUROSTAT - Typology of sampling strategy, version of July 2009)"
          }, {
            "id": "samplingSize",
            "label": "Sampling size",
            "type": "text",
            "description": "Number of units, full participants, partial participants, eligibles, not eligible, unresolved (eligibility status not resolved)"
          }, {
            "id": "lotSizeUnit",
            "label": "Lot size unit",
            "type": "text",
            "description": "Unit in which the lot size is expressed"
          }, {
            "id": "samplingPoint",
            "label": "Sampling point",
            "type": "text",
            "description": "Point in the food chain where the sample was taken. (Doc. ESTAT/F5/ES/155 Data dictionary of activities of the establishments)"
          }, {
            "id": "samplingMethod",
            "label": "Sampling method",
            "type": "text",
            "description": "Sampling method used to take the sample"
          }, {
            "id": "typeOfSamplingProgram",
            "label": "Type of sampling program",
            "type": "text",
            "description": "Indicate the type of programm for which the samples have been collected"
          }, {
            "id": "samplingPlan",
            "label": "Sampling plan",
            "type": "text",
            "description": "Description of data collection technique: stratified or complex sampling (several stages)"
          }]
        },
        "modelMath": {
          "modelEquation": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "modelEquation": [{
              "id": "modelEquation",
              "label": "Equation",
              "type": "text",
              "description": "The pointer to the file that holds the software code (e.g. R-script)"
            }, {
              "id": "name",
              "label": "Model equation name",
              "type": "text",
              "description": "A name given to the model equation"
            }, {
              "id": "modelHypothesis",
              "label": "Hypothesis of the model",
              "description": "Description of the hypothesis of the model"
            }, {
              "id": "modelEquationClass",
              "label": "Model equation class",
              "type": "text",
              "description": "Information on that helps to categorize model equations"
            }]
          },
          "exposure": [{
            "id": "treatment",
            "label": "Left-censored data treatment",
            "description": "Description of the mathematical method to replace left-censored data (recommandation of WHO (2013), distribution or others)"
          }, {
            "id": "scenario",
            "label": "Scenario",
            "description": "Description of the different scenarios of exposure assessment"
          }, {
            "id": "uncertaintyEstimation",
            "label": "Uncertainty estimation",
            "type": "text",
            "description": "Analysis to estimate uncertainty"
          }, {
            "id": "type",
            "label": "Type of exposure",
            "type": "text",
            "description": "Description of the type of exposure"
          }, {
            "id": "contamination",
            "label": "Contam level post data treatment",
            "description": "Description of the range of of the level of contamination after left censored data treatment"
          }],
          "parameter": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "parameter": [{
              "id": "subject",
              "label": "Parameter subject",
              "type": "text",
              "description": "Scope of the parameter, e.g. if it refers to an animal, a batch of animals, a batch of products, a carcass, a carcass skin etc"
            }, {
              "id": "maxValue",
              "label": "Value max",
              "type": "text",
              "description": "Numerical value of the maximum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "dataType",
              "label": "Data type",
              "type": "text",
              "description": "Information on the data format of the parameter, e.g. if it is a categorical variable: int, double, array of size x,y,z "
            }, {
              "id": "description",
              "label": "Description",
              "type": "text",
              "description": "General description of the parameter"
            }, {
              "id": "source",
              "label": "Parameter source",
              "type": "text",
              "description": "Information on the type of knowledge used to define the parameter value"
            }, {
              "id": "classification",
              "label": "Parameter classification",
              "type": "text",
              "description": "General classification of the parameter (e.g. Input, Constant, Output etc)"
            }, {
              "id": "distribution",
              "label": "Parameter distribution",
              "type": "text",
              "description": "Distribution describing the parameter variabilty. If no distribution selected this means the value provided in 'Parameter value' is a point estimate. In case a distribution is selected the value provided in 'Parameter value' is a string that the model code can parse in order to sample from the named distribution"
            }, {
              "id": "error",
              "label": "Error",
              "type": "text",
              "description": "Error of the parameter value"
            }, {
              "id": "variabilitySubject",
              "label": "Parameter variability subject",
              "type": "text",
              "description": "Information on which the variability is described. It can be variability between broiler in a flock, variability between all meat packages sold in Denmark, variability between days, etc."
            }, {
              "id": "unit",
              "label": "Unit",
              "type": "text",
              "description": "Unit of the parameter"
            }, {
              "id": "minValue",
              "label": "Value min",
              "type": "text",
              "description": "Numerical value of the minimum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "unitCategory",
              "label": "Unit category",
              "type": "text",
              "description": "General classification of the parameter unit"
            }, {
              "id": "name",
              "label": "Parameter name",
              "type": "text",
              "description": "A name given to the parameter"
            }, {
              "id": "id",
              "label": "Parameter ID",
              "type": "text",
              "description": "An unambiguous ID given to each of the parameters - preferably autogenerated by a software tool and compatible with SBML ID requirements, only letters from A to Z, numbers and '_'"
            }, {
              "id": "value",
              "label": "Value",
              "type": "text",
              "description": "A default value for the parameter. This is mandatory (needs to be provided) for all parameters of type 'Input'"
            }]
          },
          "qualityMeasures": [{
            "id": "rsquared",
            "label": "R squared",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sse",
            "label": "SSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "rmse",
            "label": "RMSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "aic",
            "label": "AIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sensitivityAnalysis",
            "label": "Sensitivity analysis",
            "type": "long-text",
            "description": "Description of the results of an sensitivity analysis, i.e. how independence assumptions are met or how variables will affect the output of model"
          }, {
            "id": "bic",
            "label": "BIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "mse",
            "label": "MSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }],
          "modelMath": [{
            "id": "fittingProcedure",
            "label": "Fitting procedure",
            "type": "text",
            "description": "Procedure used to fit the data to the model equation"
          }, {
            "id": "event",
            "label": "Event",
            "description": "Definition of time-dependent parameter changes"
          }]
        },
        "scope": {
          "populationGroup": [{
            "id": "populationRiskFactor",
            "label": "Risk and population factors",
            "description": "Population risk factor that may influence the outcomes of the study, confounder should be included"
          }, {
            "id": "country",
            "label": "Country",
            "description": "Country on which the population group of the model or data applies"
          }, {
            "id": "populationSpan",
            "label": "Population span (years)",
            "description": "Temporal information on the exposure duration"
          }, {
            "id": "populationGender",
            "label": "Population gender",
            "type": "text",
            "description": "Description of the percentage of gender"
          }, {
            "id": "populationDescription",
            "label": "Description",
            "description": "Description of the population for which the model applies (demographic and socio-economic characteristics for example). Background information that are needed in the data analysis phase, size of household, education level, employment status, professional category, ethnicity, etc."
          }, {
            "id": "populationAge",
            "label": "Population age",
            "description": "Description of the range of age or group of age"
          }, {
            "id": "patternConsumption",
            "label": "Consumption pattern",
            "description": "Description of the consumption of different food items, frequency, portion size"
          }, {
            "id": "name",
            "label": "Population name",
            "type": "text",
            "description": "Name of the population for which the model or data applies"
          }, {
            "id": "season",
            "label": "Season",
            "description": "Distribution of surveyed people according to the season (influence consumption pattern)"
          }, {
            "id": "region",
            "label": "Region",
            "description": "Spatial information (area) on which the population group of the model or data applies"
          }, {
            "id": "targetPopulation",
            "label": "Target population",
            "type": "text",
            "description": "Population of individual that we are interested in describing and making statistical inferences about"
          }, {
            "id": "bmi",
            "label": "BMI",
            "description": "Description of the range of BMI or class of BMI or BMI mean"
          }, {
            "id": "specialDietGroups",
            "label": "Special diet groups",
            "description": "Description of sub-population with special diets (vegetarians, diabetics, group following special ethnic diets)"
          }],
          "hazard": [{
            "id": "maximumResidueLimit",
            "label": "Maximum Residue Limit (MRL)",
            "type": "text",
            "description": "International regulations and permissible maximum residue levels in food and drinking water"
          }, {
            "id": "sourceOfContamination",
            "label": "Source of contamination",
            "type": "text",
            "description": "rigin of the contamination, source"
          }, {
            "id": "indSum",
            "label": "Individual or Summed Hazard",
            "type": "text",
            "description": "Define if the parameter reported is an individual residue/analyte, a summed residue definition or part of a sum a summed residue definition"
          }, {
            "id": "acceptableOperatorsExposureLevel",
            "label": "Acceptable Operator Exposure Level (AOEL)",
            "type": "text",
            "description": "Maximum amount of active substance to which the operator may be exposed without any adverse health effects. The AOEL is expressed as milligrams of the chemical per kilogram body weight of the operator"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Description of the hazard for which the model or data applies"
          }, {
            "id": "type",
            "label": "Hazard type",
            "type": "text",
            "description": "General classification of the hazard for which the model or data applies"
          }, {
            "id": "adverseEffect",
            "label": "Adverse effect",
            "type": "text",
            "description": "Adverse effect induced by hazard about morbidity, mortality, and etcetera"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the hazard for which the model or data applies"
          }, {
            "id": "noObservedAdverseAffectLevel",
            "label": "No Observed Adverse Affect Level (NOAEL)",
            "type": "text",
            "description": "Level of exposure of an organism, found by experiment or observation, at which there is no biologically or statistically significant increase in the frequency or severity of any adverse effects in the exposed population when compared to its appropriate control"
          }, {
            "id": "acuteReferenceDose",
            "label": "Acute Reference Dose (ARfD)",
            "type": "text",
            "description": "An estimate (with uncertainty spanning perhaps an order of magnitude) of a daily oral exposure for an acute duration (24 hours or less) to the human population (including sensitive subgroups) that is likely to be without an appreciable risk of deleterious effects during a lifetime"
          }, {
            "id": "name",
            "label": "Hazard name",
            "type": "text",
            "description": "Name of the hazard (agent, contaminant, chemical) for which the data or model applies"
          }, {
            "id": "lowestObservedAdverseAffectLevel",
            "label": "Lowest Observed Adverse Effect Level (LOAEL)",
            "type": "text",
            "description": "Lowest concentration or amount of a substance found by experiment or observation that causes an adverse alteration of morphology, function, capacity, growth, development, or lifespan of a target organism distinguished from normal organisms of the same species under defined conditions of exposure"
          }, {
            "id": "benchmarkDose",
            "label": "Benchmark Dose (BMD)",
            "type": "text",
            "description": "A dose or concentration that produces a predetermined change in response rate of an adverse effect (called the benchmark response or BMR) compared to background"
          }, {
            "id": "acceptableDailyIntake",
            "label": "Acceptable Daily Intake (ADI)",
            "type": "text",
            "description": "Measure of amount of a specific substance in food or in drinking water tahta can be ingested (orally) on a daily basis over a lifetime without an appreciable health risk"
          }],
          "scope": [{
            "id": "spatialInformation",
            "label": "Spatial information",
            "description": "Spatial information (area) on which the model or data applies"
          }, {
            "id": "generalComment",
            "label": "General comment",
            "type": "long-text",
            "description": "General comments on the scope of the study, data or model"
          }, {
            "id": "temporalInformation",
            "label": "Temporal information",
            "type": "long-text",
            "description": "Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)"
          }]
        },
        "generalInformation": {
          "creator": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "author": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "reference": [{
            "id": "date",
            "label": "Date",
            "type": "year_date",
            "description": "Temporal information on the publication date"
          }, {
            "id": "website",
            "label": "Website",
            "type": "text",
            "description": "A link to the publication website (different from DOI)"
          }, {
            "id": "issue",
            "label": "Issue",
            "type": "text",
            "description": "Data on the details of the issue in which the model or date has been described"
          }, {
            "id": "publicationType",
            "label": "Publication type",
            "type": "text",
            "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
          }, {
            "id": "abstract",
            "label": "Abstract",
            "type": "text",
            "description": "Abstract of the publication in which the model or the data has been described "
          }, {
            "id": "isReferenceDescription",
            "label": "Is_reference_description?",
            "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
          }, {
            "id": "title",
            "label": "Title",
            "type": "long-text",
            "description": "Title of publication in which the model or date has been described"
          }, {
            "id": "pmid",
            "label": "PubMed ID",
            "type": "text",
            "description": "The PubMed ID related to this publication"
          }, {
            "id": "volume",
            "label": "Volume",
            "type": "text",
            "description": "Data on the details of the volume in which the model or date has been described"
          }, {
            "id": "journal",
            "label": "Journal",
            "type": "long-text",
            "description": "Data on the details of the journal in which the model or date has been described"
          }, {
            "id": "authorList",
            "label": "Author list",
            "type": "long-text",
            "description": "Name and surname of the authors who contributed to this publication"
          }, {
            "id": "comment",
            "label": "Comment",
            "type": "long-text",
            "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
          }, {
            "id": "doi",
            "label": "Publication DOI",
            "type": "long-text",
            "description": "The DOI related to this publication"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The status of this publication, e.g. Published, Submitted, etc."
          }],
          "modelCategory": [{
            "id": "modelClassComment",
            "label": "Comment",
            "type": "long-text",
            "description": "Comment with further details on the model class"
          }, {
            "id": "basicProcess",
            "label": "Basic process",
            "description": "Defines the impact of the process on the hazard (so far only valid for process models and predictive models)"
          }, {
            "id": "modelClass",
            "label": "Model class",
            "type": "text",
            "description": "Type of model according to RAKIP classification"
          }, {
            "id": "modelSubClass",
            "label": "Subclass",
            "description": "Sub-classification of the model given the Model Class"
          }],
          "generalInformation": [{
            "id": "identifier",
            "label": "Identifier",
            "type": "text",
            "description": "An unambiguous ID given to the model or data. This can also be created automatically by a software tool"
          }, {
            "id": "software",
            "label": "Software",
            "type": "text",
            "description": "The program or software language in which the model has been implemented"
          }, {
            "id": "format",
            "label": "Format",
            "type": "text",
            "description": "File extension of the model or data file (including version number of format if applicable)"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the study, data or model"
          }, {
            "id": "language",
            "label": "Language",
            "type": "text",
            "description": "A language of the resource (some data or reports can be available in French language for example)"
          }, {
            "id": "source",
            "label": "Source",
            "type": "text",
            "description": "A source from which the model/data is derived"
          }, {
            "id": "availability",
            "label": "Availability",
            "type": "text",
            "description": "Availability of data or model, i.e. if the annotated model code / data is included in this FSK file"
          }, {
            "id": "creationDate",
            "label": "Creation date",
            "type": "date",
            "description": "Creation date/time of the FSK file"
          }, {
            "id": "url",
            "label": "URL",
            "type": "text",
            "description": "Web address referencing the resource location (data for example)"
          }, {
            "id": "objective",
            "label": "Objective",
            "type": "long-text",
            "description": "Objective of the model or data"
          }, {
            "id": "modificationDate",
            "label": "Modification date",
            "description": "Date/time of the last version of the FSK file"
          }, {
            "id": "rights",
            "label": "Rights",
            "type": "text",
            "description": "Rights granted for usage, distribution and modification of this FSK file"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "A name given to the model or data"
          }, {
            "id": "languageWrittenIn",
            "label": "Language written in",
            "type": "text",
            "description": "Software language used to write the model, e.g. R or MatLab"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The curation status of the model"
          }]
        }
      };
    }
    // Validate this.panels and return boolean
  }, {
    key: "validate",
    value: function validate() {
      var isValid = true;
      if (!this.panels.generalInformation.validate()) isValid = false;
      if (!this.panels.modelCategory.validate()) isValid = false;
      if (!this.panels.scopeGeneral.validate()) isValid = false;
      if (!this.panels.study.validate()) isValid = false;
      return isValid;
    }
  }, {
    key: "_createPanels",
    value: function _createPanels() {
      var port = window.port || -1;
      var schema = schemas.genericModel;
      return _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
        study: new _FormPanel.FormPanel("Study", this.jsonSchema.dataBackground.study, this._metadata.dataBackground ? this._metadata.dataBackground.study : {}, port),
        laboratory: new _TablePanel.TablePanel("Laboratory", this.jsonSchema.dataBackground.laboratory, this._metadata.dataBackground ? this._metadata.dataBackground.laboratory : {}, port),
        assay: new _TablePanel.TablePanel("Assay", this.jsonSchema.dataBackground.assay, this._metadata.dataBackground ? this._metadata.dataBackground.assay : {}, port),
        studySample: new _TablePanel.TablePanel("Study Sample", this.jsonSchema.dataBackground.studySample, this._metadata.dataBackground ? this._metadata.dataBackground.studySample : {}, port),
        modelMath: new _FormPanel.FormPanel("Model Math", this.jsonSchema.modelMath.modelMath, this._metadata.modelMath, port),
        modelEquation: new _TablePanel.TablePanel("Model Equation", this.jsonSchema.modelMath.modelEquation.modelEquation, this._metadata.modelMath ? this._metadata.modelMath.modelEquation : {}, port),
        reference: new _TablePanel.TablePanel("Reference", this.jsonSchema.modelMath.modelEquation.reference, this._metadata.modelMath.modelEquation ? this._metadata.modelMath.modelEquation.reference : {}, port),
        exposure: new _TablePanel.TablePanel("Exposure", this.jsonSchema.modelMath.exposure, this._metadata.modelMath ? this._metadata.modelMath.exposure : {}, port),
        parameter: new _TablePanel.TablePanel("Parameter", this.jsonSchema.modelMath.parameter.parameter, this._metadata.modelMath ? this._metadata.modelMath.parameter : {}, port)
      }, "reference", new _FormPanel.FormPanel("Reference", this.jsonSchema.modelMath.parameter.reference, this._metadata.modelMath.parameter ? this._metadata.modelMath.parameter.reference : {}, port)), "qualityMeasures", new _TablePanel.TablePanel("Quality Measures", this.jsonSchema.modelMath.qualityMeasures, this._metadata.modelMath ? this._metadata.modelMath.qualityMeasures : {}, port)), "scope", new _FormPanel.FormPanel("Scope", this.jsonSchema.scope.scope, this._metadata.scope, port)), "populationGroup", new _TablePanel.TablePanel("Population Group", this.jsonSchema.scope.populationGroup, this._metadata.scope ? this._metadata.scope.populationGroup : {}, port)), "hazard", new _TablePanel.TablePanel("Hazard", this.jsonSchema.scope.hazard, this._metadata.scope ? this._metadata.scope.hazard : {}, port)), "generalInformation", new _FormPanel.FormPanel("General Information", this.jsonSchema.generalInformation.generalInformation, this._metadata.generalInformation, port)), "creator", new _TablePanel.TablePanel("Creator", this.jsonSchema.generalInformation.creator, this._metadata.generalInformation ? this._metadata.generalInformation.creator : {}, port)), "author", new _TablePanel.TablePanel("Author", this.jsonSchema.generalInformation.author, this._metadata.generalInformation ? this._metadata.generalInformation.author : {}, port)), "reference", new _TablePanel.TablePanel("Reference", this.jsonSchema.generalInformation.reference, this._metadata.generalInformation ? this._metadata.generalInformation.reference : {}, port)), "modelCategory", new _FormPanel.FormPanel("Model Category", this.jsonSchema.generalInformation.modelCategory, this._metadata.generalInformation ? this._metadata.generalInformation.modelCategory : {}, port));
    }
  }]);
}(_ModelView2.ModelView);

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./GenericModelModelMathView":101,"./HealthModelScopeView":109,"./ModelView":118,"./PredictiveModelDataBackgroundView":135,"./PredictiveModelGeneralInformationView":137}],111:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Laboratory = void 0;
var _ApiClient = require("../ApiClient");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Laboratory model module.
 * @module model/Laboratory
 * @version 1.0.0
 */
var Laboratory = exports.Laboratory = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>Laboratory</code>.
   * @alias module:model/Laboratory
   * @class
   * @param accreditation {} The laboratory accreditation to ISO/IEC 17025
   */
  function Laboratory(accreditation) {
    _classCallCheck(this, Laboratory);
    this.accreditation = accreditation;
  }

  /**
   * Constructs a <code>Laboratory</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/Laboratory} obj Optional instance to populate.
   * @return {module:model/Laboratory} The populated <code>Laboratory</code> instance.
   */
  return _createClass(Laboratory, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new Laboratory();
        if (data.hasOwnProperty('country')) obj.country = _ApiClient.ApiClient.convertToType(data['country'], 'String');
        if (data.hasOwnProperty('name')) obj.name = _ApiClient.ApiClient.convertToType(data['name'], 'String');
        if (data.hasOwnProperty('accreditation')) obj.accreditation = _ApiClient.ApiClient.convertToType(data['accreditation'], ['String']);
      }
      return obj;
    }
  }]);
}();
/**
 * Country where the laboratory is placed. (ISO 3166-1-alpha-2)
 * @member {String} country
 */
Laboratory.prototype.country = undefined;

/**
 * Laboratory code (National laboratory code if available) or Laboratory name 
 * @member {String} name
 */
Laboratory.prototype.name = undefined;

/**
 * The laboratory accreditation to ISO/IEC 17025
 * @member {Array.<String>} accreditation
 */
Laboratory.prototype.accreditation = undefined;

},{"../ApiClient":44}],112:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LaboratoryView = void 0;
var _ApiClient = require("../ApiClient");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Laboratory View  module.
 * @module model/Laboratory
 * @version 1.0.0
 */
var LaboratoryView = exports.LaboratoryView = /*#__PURE__*/_createClass(function LaboratoryView() {
  _classCallCheck(this, LaboratoryView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63}],113:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Model = void 0;
var _ApiClient = require("../ApiClient");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Model model module.
 * @module model/Model
 * @version 1.0.0
 */
var Model = exports.Model = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>Model</code>.
   * @alias module:model/Model
   * @class
   * @param modelType {} 
   */
  function Model(modelType) {
    _classCallCheck(this, Model);
    this.modelType = modelType;
  }

  /**
   * Constructs a <code>Model</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/Model} obj Optional instance to populate.
   * @return {module:model/Model} The populated <code>Model</code> instance.
   */
  return _createClass(Model, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new Model();
        if (data.hasOwnProperty('modelType')) obj.modelType = _ApiClient.ApiClient.convertToType(data['modelType'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * @member {String} modelType
 */
Model.prototype.modelType = undefined;

},{"../ApiClient":44}],114:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModelCategory = void 0;
var _ApiClient = require("../ApiClient");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ModelCategory model module.
 * @module model/ModelCategory
 * @version 1.0.0
 */
var ModelCategory = exports.ModelCategory = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>ModelCategory</code>.
   * @alias module:model/ModelCategory
   * @class
   * @param modelClass {} Type of model according to RAKIP classification
   */
  function ModelCategory(modelClass) {
    _classCallCheck(this, ModelCategory);
    this.modelClass = modelClass;
  }

  /**
   * Constructs a <code>ModelCategory</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/ModelCategory} obj Optional instance to populate.
   * @return {module:model/ModelCategory} The populated <code>ModelCategory</code> instance.
   */
  return _createClass(ModelCategory, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new ModelCategory();
        if (data.hasOwnProperty('modelClassComment')) obj.modelClassComment = _ApiClient.ApiClient.convertToType(data['modelClassComment'], 'String');
        if (data.hasOwnProperty('basicProcess')) obj.basicProcess = _ApiClient.ApiClient.convertToType(data['basicProcess'], ['String']);
        if (data.hasOwnProperty('modelClass')) obj.modelClass = _ApiClient.ApiClient.convertToType(data['modelClass'], 'String');
        if (data.hasOwnProperty('modelSubClass')) obj.modelSubClass = _ApiClient.ApiClient.convertToType(data['modelSubClass'], ['String']);
      }
      return obj;
    }
  }]);
}();
/**
 * Comment with further details on the model class
 * @member {String} modelClassComment
 */
ModelCategory.prototype.modelClassComment = undefined;

/**
 * Defines the impact of the process on the hazard (so far only valid for process models and predictive models)
 * @member {Array.<String>} basicProcess
 */
ModelCategory.prototype.basicProcess = undefined;

/**
 * Type of model according to RAKIP classification
 * @member {String} modelClass
 */
ModelCategory.prototype.modelClass = undefined;

/**
 * Sub-classification of the model given the Model Class
 * @member {Array.<String>} modelSubClass
 */
ModelCategory.prototype.modelSubClass = undefined;

},{"../ApiClient":44}],115:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModelCategoryView = void 0;
var _ApiClient = require("../ApiClient");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ModelCategory View  module.
 * @module model/ModelCategory
 * @version 1.0.0
 */
var ModelCategoryView = exports.ModelCategoryView = /*#__PURE__*/_createClass(function ModelCategoryView() {
  _classCallCheck(this, ModelCategoryView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63}],116:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModelEquation = void 0;
var _ApiClient = require("../ApiClient");
var _Reference = require("./Reference");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ModelEquation model module.
 * @module model/ModelEquation
 * @version 1.0.0
 */
var ModelEquation = exports.ModelEquation = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>ModelEquation</code>.
   * @alias module:model/ModelEquation
   * @class
   * @param modelEquation {} The pointer to the file that holds the software code (e.g. R-script)
   * @param name {} A name given to the model equation
   */
  function ModelEquation(modelEquationname) {
    _classCallCheck(this, ModelEquation);
    this.modelEquation = modelEquation;
    this.name = name;
  }

  /**
   * Constructs a <code>ModelEquation</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/ModelEquation} obj Optional instance to populate.
   * @return {module:model/ModelEquation} The populated <code>ModelEquation</code> instance.
   */
  return _createClass(ModelEquation, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new ModelEquation();
        if (data.hasOwnProperty('reference')) obj.reference = _ApiClient.ApiClient.convertToType(data['reference'], [_Reference.Reference]);
        if (data.hasOwnProperty('modelEquation')) obj.modelEquation = _ApiClient.ApiClient.convertToType(data['modelEquation'], 'String');
        if (data.hasOwnProperty('name')) obj.name = _ApiClient.ApiClient.convertToType(data['name'], 'String');
        if (data.hasOwnProperty('modelHypothesis')) obj.modelHypothesis = _ApiClient.ApiClient.convertToType(data['modelHypothesis'], ['String']);
        if (data.hasOwnProperty('modelEquationClass')) obj.modelEquationClass = _ApiClient.ApiClient.convertToType(data['modelEquationClass'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * Information on the source, where the equation has been extracted from - if available
 * @member {Array.<module:model/Reference>} reference
 */
ModelEquation.prototype.reference = undefined;

/**
 * The pointer to the file that holds the software code (e.g. R-script)
 * @member {String} modelEquation
 */
ModelEquation.prototype.modelEquation = undefined;

/**
 * A name given to the model equation
 * @member {String} name
 */
ModelEquation.prototype.name = undefined;

/**
 * Description of the hypothesis of the model
 * @member {Array.<String>} modelHypothesis
 */
ModelEquation.prototype.modelHypothesis = undefined;

/**
 * Information on that helps to categorize model equations
 * @member {String} modelEquationClass
 */
ModelEquation.prototype.modelEquationClass = undefined;

},{"../ApiClient":44,"./Reference":155}],117:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModelEquationView = void 0;
var _ApiClient = require("../ApiClient");
var _ReferenceView = require("./ReferenceView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ModelEquation View  module.
 * @module model/ModelEquation
 * @version 1.0.0
 */
var ModelEquationView = exports.ModelEquationView = /*#__PURE__*/_createClass(function ModelEquationView() {
  _classCallCheck(this, ModelEquationView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./ReferenceView":156}],118:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModelView = void 0;
var _ApiClient = require("../ApiClient");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Model View  module.
 * @module model/Model
 * @version 1.0.0
 */
var ModelView = exports.ModelView = /*#__PURE__*/_createClass(function ModelView(metadata, img, modelScript, visScript, readme) {
  _classCallCheck(this, ModelView);
  this._metadata = metadata;
  this._schema = {};
  this._menu = [];
  this._img = img;
  this._modelScript = modelScript;
  this._visScript = visScript;
  this.readme = readme;
  this.panels = {};
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63}],119:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OtherModel = void 0;
var _ApiClient = require("../ApiClient");
var _Model2 = require("./Model");
var _OtherModelDataBackground = require("./OtherModelDataBackground");
var _OtherModelGeneralInformation = require("./OtherModelGeneralInformation");
var _OtherModelModelMath = require("./OtherModelModelMath");
var _OtherModelScope = require("./OtherModelScope");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The OtherModel model module.
 * @module model/OtherModel
 * @version 1.0.0
 */
var OtherModel = exports.OtherModel = /*#__PURE__*/function (_Model) {
  /**
   * Constructs a new <code>OtherModel</code>.
   * @alias module:model/OtherModel
   * @class
   * @extends module:model/Model
   * @param modelType {} 
   */
  function OtherModel(modelType) {
    _classCallCheck(this, OtherModel);
    return _callSuper(this, OtherModel, [modelType]);
  }

  /**
   * Constructs a <code>OtherModel</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/OtherModel} obj Optional instance to populate.
   * @return {module:model/OtherModel} The populated <code>OtherModel</code> instance.
   */
  _inherits(OtherModel, _Model);
  return _createClass(OtherModel, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new OtherModel();
        _Model2.Model.constructFromObject(data, obj);
        if (data.hasOwnProperty('dataBackground')) obj.dataBackground = _OtherModelDataBackground.OtherModelDataBackground.constructFromObject(data['dataBackground']);
        if (data.hasOwnProperty('modelMath')) obj.modelMath = _OtherModelModelMath.OtherModelModelMath.constructFromObject(data['modelMath']);
        if (data.hasOwnProperty('scope')) obj.scope = _OtherModelScope.OtherModelScope.constructFromObject(data['scope']);
        if (data.hasOwnProperty('generalInformation')) obj.generalInformation = _OtherModelGeneralInformation.OtherModelGeneralInformation.constructFromObject(data['generalInformation']);
      }
      return obj;
    }
  }]);
}(_Model2.Model);
/**
 * @member {module:model/OtherModelDataBackground} dataBackground
 */
OtherModel.prototype.dataBackground = undefined;

/**
 * @member {module:model/OtherModelModelMath} modelMath
 */
OtherModel.prototype.modelMath = undefined;

/**
 * @member {module:model/OtherModelScope} scope
 */
OtherModel.prototype.scope = undefined;

/**
 * @member {module:model/OtherModelGeneralInformation} generalInformation
 */
OtherModel.prototype.generalInformation = undefined;

},{"../ApiClient":44,"./Model":113,"./OtherModelDataBackground":120,"./OtherModelGeneralInformation":122,"./OtherModelModelMath":124,"./OtherModelScope":126}],120:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OtherModelDataBackground = void 0;
var _ApiClient = require("../ApiClient");
var _Assay = require("./Assay");
var _Laboratory = require("./Laboratory");
var _Study = require("./Study");
var _StudySample = require("./StudySample");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The OtherModelDataBackground model module.
 * @module model/OtherModelDataBackground
 * @version 1.0.0
 */
var OtherModelDataBackground = exports.OtherModelDataBackground = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>OtherModelDataBackground</code>.
   * @alias module:model/OtherModelDataBackground
   * @class
   * @param study {} 
   */
  function OtherModelDataBackground(study) {
    _classCallCheck(this, OtherModelDataBackground);
    this.study = study;
  }

  /**
   * Constructs a <code>OtherModelDataBackground</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/OtherModelDataBackground} obj Optional instance to populate.
   * @return {module:model/OtherModelDataBackground} The populated <code>OtherModelDataBackground</code> instance.
   */
  return _createClass(OtherModelDataBackground, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new OtherModelDataBackground();
        if (data.hasOwnProperty('study')) obj.study = _Study.Study.constructFromObject(data['study']);
        if (data.hasOwnProperty('laboratory')) obj.laboratory = _ApiClient.ApiClient.convertToType(data['laboratory'], [_Laboratory.Laboratory]);
        if (data.hasOwnProperty('assay')) obj.assay = _ApiClient.ApiClient.convertToType(data['assay'], [_Assay.Assay]);
        if (data.hasOwnProperty('studySample')) obj.studySample = _ApiClient.ApiClient.convertToType(data['studySample'], [_StudySample.StudySample]);
      }
      return obj;
    }
  }]);
}();
/**
 * @member {module:model/Study} study
 */
OtherModelDataBackground.prototype.study = undefined;

/**
 * @member {Array.<module:model/Laboratory>} laboratory
 */
OtherModelDataBackground.prototype.laboratory = undefined;

/**
 * @member {Array.<module:model/Assay>} assay
 */
OtherModelDataBackground.prototype.assay = undefined;

/**
 * @member {Array.<module:model/StudySample>} studySample
 */
OtherModelDataBackground.prototype.studySample = undefined;

},{"../ApiClient":44,"./Assay":65,"./Laboratory":111,"./Study":159,"./StudySample":160}],121:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OtherModelDataBackgroundView = void 0;
var _ApiClient = require("../ApiClient");
var _AssayView = require("./AssayView");
var _LaboratoryView = require("./LaboratoryView");
var _StudyView = require("./StudyView");
var _StudySampleView = require("./StudySampleView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The OtherModelDataBackground View  module.
 * @module model/OtherModelDataBackground
 * @version 1.0.0
 */
var OtherModelDataBackgroundView = exports.OtherModelDataBackgroundView = /*#__PURE__*/_createClass(function OtherModelDataBackgroundView() {
  _classCallCheck(this, OtherModelDataBackgroundView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./AssayView":66,"./LaboratoryView":112,"./StudySampleView":161,"./StudyView":162}],122:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OtherModelGeneralInformation = void 0;
var _ApiClient = require("../ApiClient");
var _Contact = require("./Contact");
var _ModelCategory = require("./ModelCategory");
var _Reference = require("./Reference");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The OtherModelGeneralInformation model module.
 * @module model/OtherModelGeneralInformation
 * @version 1.0.0
 */
var OtherModelGeneralInformation = exports.OtherModelGeneralInformation = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>OtherModelGeneralInformation</code>.
   * @alias module:model/OtherModelGeneralInformation
   * @class
   * @param identifier {} An unambiguous ID given to the model or data. This can also be created automatically by a software tool
   * @param creationDate {} Creation date/time of the FSK file
   * @param rights {} Rights granted for usage, distribution and modification of this FSK file
   * @param name {} A name given to the model or data
   */
  function OtherModelGeneralInformation(identifiercreationDaterightsname) {
    _classCallCheck(this, OtherModelGeneralInformation);
    this.identifier = identifier;
    this.creationDate = creationDate;
    this.rights = rights;
    this.name = name;
  }

  /**
   * Constructs a <code>OtherModelGeneralInformation</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/OtherModelGeneralInformation} obj Optional instance to populate.
   * @return {module:model/OtherModelGeneralInformation} The populated <code>OtherModelGeneralInformation</code> instance.
   */
  return _createClass(OtherModelGeneralInformation, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new OtherModelGeneralInformation();
        if (data.hasOwnProperty('identifier')) obj.identifier = _ApiClient.ApiClient.convertToType(data['identifier'], 'String');
        if (data.hasOwnProperty('creator')) obj.creator = _ApiClient.ApiClient.convertToType(data['creator'], [_Contact.Contact]);
        if (data.hasOwnProperty('software')) obj.software = _ApiClient.ApiClient.convertToType(data['software'], 'String');
        if (data.hasOwnProperty('author')) obj.author = _ApiClient.ApiClient.convertToType(data['author'], [_Contact.Contact]);
        if (data.hasOwnProperty('format')) obj.format = _ApiClient.ApiClient.convertToType(data['format'], 'String');
        if (data.hasOwnProperty('description')) obj.description = _ApiClient.ApiClient.convertToType(data['description'], 'String');
        if (data.hasOwnProperty('language')) obj.language = _ApiClient.ApiClient.convertToType(data['language'], 'String');
        if (data.hasOwnProperty('source')) obj.source = _ApiClient.ApiClient.convertToType(data['source'], 'String');
        if (data.hasOwnProperty('availability')) obj.availability = _ApiClient.ApiClient.convertToType(data['availability'], 'String');
        if (data.hasOwnProperty('creationDate')) obj.creationDate = _ApiClient.ApiClient.convertToType(data['creationDate'], 'Date');
        if (data.hasOwnProperty('url')) obj.url = _ApiClient.ApiClient.convertToType(data['url'], 'String');
        if (data.hasOwnProperty('objective')) obj.objective = _ApiClient.ApiClient.convertToType(data['objective'], 'String');
        if (data.hasOwnProperty('reference')) obj.reference = _ApiClient.ApiClient.convertToType(data['reference'], [_Reference.Reference]);
        if (data.hasOwnProperty('modificationDate')) obj.modificationDate = _ApiClient.ApiClient.convertToType(data['modificationDate'], ['Date']);
        if (data.hasOwnProperty('rights')) obj.rights = _ApiClient.ApiClient.convertToType(data['rights'], 'String');
        if (data.hasOwnProperty('name')) obj.name = _ApiClient.ApiClient.convertToType(data['name'], 'String');
        if (data.hasOwnProperty('languageWrittenIn')) obj.languageWrittenIn = _ApiClient.ApiClient.convertToType(data['languageWrittenIn'], 'String');
        if (data.hasOwnProperty('modelCategory')) obj.modelCategory = _ModelCategory.ModelCategory.constructFromObject(data['modelCategory']);
        if (data.hasOwnProperty('status')) obj.status = _ApiClient.ApiClient.convertToType(data['status'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * An unambiguous ID given to the model or data. This can also be created automatically by a software tool
 * @member {String} identifier
 */
OtherModelGeneralInformation.prototype.identifier = undefined;

/**
 * The person(s) that created this FSK file including all metadata
 * @member {Array.<module:model/Contact>} creator
 */
OtherModelGeneralInformation.prototype.creator = undefined;

/**
 * The program or software language in which the model has been implemented
 * @member {String} software
 */
OtherModelGeneralInformation.prototype.software = undefined;

/**
 * Person(s) who generated the model code or generated the data set originally
 * @member {Array.<module:model/Contact>} author
 */
OtherModelGeneralInformation.prototype.author = undefined;

/**
 * File extension of the model or data file (including version number of format if applicable)
 * @member {String} format
 */
OtherModelGeneralInformation.prototype.format = undefined;

/**
 * General description of the study, data or model
 * @member {String} description
 */
OtherModelGeneralInformation.prototype.description = undefined;

/**
 * A language of the resource (some data or reports can be available in French language for example)
 * @member {String} language
 */
OtherModelGeneralInformation.prototype.language = undefined;

/**
 * A source from which the model/data is derived
 * @member {String} source
 */
OtherModelGeneralInformation.prototype.source = undefined;

/**
 * Availability of data or model, i.e. if the annotated model code / data is included in this FSK file
 * @member {String} availability
 */
OtherModelGeneralInformation.prototype.availability = undefined;

/**
 * Creation date/time of the FSK file
 * @member {Date} creationDate
 */
OtherModelGeneralInformation.prototype.creationDate = undefined;

/**
 * Web address referencing the resource location (data for example)
 * @member {String} url
 */
OtherModelGeneralInformation.prototype.url = undefined;

/**
 * Objective of the model or data
 * @member {String} objective
 */
OtherModelGeneralInformation.prototype.objective = undefined;

/**
 * @member {Array.<module:model/Reference>} reference
 */
OtherModelGeneralInformation.prototype.reference = undefined;

/**
 * Date/time of the last version of the FSK file
 * @member {Array.<Date>} modificationDate
 */
OtherModelGeneralInformation.prototype.modificationDate = undefined;

/**
 * Rights granted for usage, distribution and modification of this FSK file
 * @member {String} rights
 */
OtherModelGeneralInformation.prototype.rights = undefined;

/**
 * A name given to the model or data
 * @member {String} name
 */
OtherModelGeneralInformation.prototype.name = undefined;

/**
 * Software language used to write the model, e.g. R or MatLab
 * @member {String} languageWrittenIn
 */
OtherModelGeneralInformation.prototype.languageWrittenIn = undefined;

/**
 * @member {module:model/ModelCategory} modelCategory
 */
OtherModelGeneralInformation.prototype.modelCategory = undefined;

/**
 * The curation status of the model
 * @member {String} status
 */
OtherModelGeneralInformation.prototype.status = undefined;

},{"../ApiClient":44,"./Contact":71,"./ModelCategory":114,"./Reference":155}],123:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OtherModelGeneralInformationView = void 0;
var _ApiClient = require("../ApiClient");
var _ContactView = require("./ContactView");
var _ModelCategoryView = require("./ModelCategoryView");
var _ReferenceView = require("./ReferenceView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The OtherModelGeneralInformation View  module.
 * @module model/OtherModelGeneralInformation
 * @version 1.0.0
 */
var OtherModelGeneralInformationView = exports.OtherModelGeneralInformationView = /*#__PURE__*/_createClass(function OtherModelGeneralInformationView() {
  _classCallCheck(this, OtherModelGeneralInformationView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./ContactView":72,"./ModelCategoryView":115,"./ReferenceView":156}],124:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OtherModelModelMath = void 0;
var _ApiClient = require("../ApiClient");
var _ModelEquation = require("./ModelEquation");
var _Parameter = require("./Parameter");
var _QualityMeasures = require("./QualityMeasures");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The OtherModelModelMath model module.
 * @module model/OtherModelModelMath
 * @version 1.0.0
 */
var OtherModelModelMath = exports.OtherModelModelMath = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>OtherModelModelMath</code>.
   * @alias module:model/OtherModelModelMath
   * @class
   * @param parameter {} 
   */
  function OtherModelModelMath(parameter) {
    _classCallCheck(this, OtherModelModelMath);
    this.parameter = parameter;
  }

  /**
   * Constructs a <code>OtherModelModelMath</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/OtherModelModelMath} obj Optional instance to populate.
   * @return {module:model/OtherModelModelMath} The populated <code>OtherModelModelMath</code> instance.
   */
  return _createClass(OtherModelModelMath, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new OtherModelModelMath();
        if (data.hasOwnProperty('fittingProcedure')) obj.fittingProcedure = _ApiClient.ApiClient.convertToType(data['fittingProcedure'], 'String');
        if (data.hasOwnProperty('modelEquation')) obj.modelEquation = _ApiClient.ApiClient.convertToType(data['modelEquation'], [_ModelEquation.ModelEquation]);
        if (data.hasOwnProperty('parameter')) obj.parameter = _ApiClient.ApiClient.convertToType(data['parameter'], [_Parameter.Parameter]);
        if (data.hasOwnProperty('qualityMeasures')) obj.qualityMeasures = _ApiClient.ApiClient.convertToType(data['qualityMeasures'], [_QualityMeasures.QualityMeasures]);
        if (data.hasOwnProperty('event')) obj.event = _ApiClient.ApiClient.convertToType(data['event'], ['String']);
      }
      return obj;
    }
  }]);
}();
/**
 * Procedure used to fit the data to the model equation
 * @member {String} fittingProcedure
 */
OtherModelModelMath.prototype.fittingProcedure = undefined;

/**
 * @member {Array.<module:model/ModelEquation>} modelEquation
 */
OtherModelModelMath.prototype.modelEquation = undefined;

/**
 * @member {Array.<module:model/Parameter>} parameter
 */
OtherModelModelMath.prototype.parameter = undefined;

/**
 * @member {Array.<module:model/QualityMeasures>} qualityMeasures
 */
OtherModelModelMath.prototype.qualityMeasures = undefined;

/**
 * Definition of time-dependent parameter changes
 * @member {Array.<String>} event
 */
OtherModelModelMath.prototype.event = undefined;

},{"../ApiClient":44,"./ModelEquation":116,"./Parameter":129,"./QualityMeasures":153}],125:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OtherModelModelMathView = void 0;
var _ApiClient = require("../ApiClient");
var _ModelEquationView = require("./ModelEquationView");
var _ParameterView = require("./ParameterView");
var _QualityMeasuresView = require("./QualityMeasuresView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The OtherModelModelMath View  module.
 * @module model/OtherModelModelMath
 * @version 1.0.0
 */
var OtherModelModelMathView = exports.OtherModelModelMathView = /*#__PURE__*/_createClass(function OtherModelModelMathView() {
  _classCallCheck(this, OtherModelModelMathView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./ModelEquationView":117,"./ParameterView":130,"./QualityMeasuresView":154}],126:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OtherModelScope = void 0;
var _ApiClient = require("../ApiClient");
var _Hazard = require("./Hazard");
var _PopulationGroup = require("./PopulationGroup");
var _Product = require("./Product");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The OtherModelScope model module.
 * @module model/OtherModelScope
 * @version 1.0.0
 */
var OtherModelScope = exports.OtherModelScope = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>OtherModelScope</code>.
   * @alias module:model/OtherModelScope
   * @class
   */
  function OtherModelScope() {
    _classCallCheck(this, OtherModelScope);
  }

  /**
   * Constructs a <code>OtherModelScope</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/OtherModelScope} obj Optional instance to populate.
   * @return {module:model/OtherModelScope} The populated <code>OtherModelScope</code> instance.
   */
  return _createClass(OtherModelScope, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new OtherModelScope();
        if (data.hasOwnProperty('spatialInformation')) obj.spatialInformation = _ApiClient.ApiClient.convertToType(data['spatialInformation'], ['String']);
        if (data.hasOwnProperty('product')) obj.product = _ApiClient.ApiClient.convertToType(data['product'], [_Product.Product]);
        if (data.hasOwnProperty('populationGroup')) obj.populationGroup = _ApiClient.ApiClient.convertToType(data['populationGroup'], [_PopulationGroup.PopulationGroup]);
        if (data.hasOwnProperty('hazard')) obj.hazard = _ApiClient.ApiClient.convertToType(data['hazard'], [_Hazard.Hazard]);
        if (data.hasOwnProperty('generalComment')) obj.generalComment = _ApiClient.ApiClient.convertToType(data['generalComment'], 'String');
        if (data.hasOwnProperty('temporalInformation')) obj.temporalInformation = _ApiClient.ApiClient.convertToType(data['temporalInformation'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * Spatial information (area) on which the model or data applies
 * @member {Array.<String>} spatialInformation
 */
OtherModelScope.prototype.spatialInformation = undefined;

/**
 * @member {Array.<module:model/Product>} product
 */
OtherModelScope.prototype.product = undefined;

/**
 * @member {Array.<module:model/PopulationGroup>} populationGroup
 */
OtherModelScope.prototype.populationGroup = undefined;

/**
 * @member {Array.<module:model/Hazard>} hazard
 */
OtherModelScope.prototype.hazard = undefined;

/**
 * General comments on the scope of the study, data or model
 * @member {String} generalComment
 */
OtherModelScope.prototype.generalComment = undefined;

/**
 * Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)
 * @member {String} temporalInformation
 */
OtherModelScope.prototype.temporalInformation = undefined;

},{"../ApiClient":44,"./Hazard":105,"./PopulationGroup":131,"./Product":149}],127:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OtherModelScopeView = void 0;
var _ApiClient = require("../ApiClient");
var _HazardView = require("./HazardView");
var _PopulationGroupView = require("./PopulationGroupView");
var _ProductView = require("./ProductView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The OtherModelScope View  module.
 * @module model/OtherModelScope
 * @version 1.0.0
 */
var OtherModelScopeView = exports.OtherModelScopeView = /*#__PURE__*/_createClass(function OtherModelScopeView() {
  _classCallCheck(this, OtherModelScopeView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./HazardView":106,"./PopulationGroupView":132,"./ProductView":150}],128:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OtherModelView = void 0;
var _ApiClient = require("../ApiClient");
var _ModelView2 = require("./ModelView");
var _OtherModelDataBackgroundView = require("./OtherModelDataBackgroundView");
var _OtherModelGeneralInformationView = require("./OtherModelGeneralInformationView");
var _OtherModelModelMathView = require("./OtherModelModelMathView");
var _OtherModelScopeView = require("./OtherModelScopeView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The OtherModel View  module.
 * @module model/OtherModel
 * @version 1.0.0
 */
var OtherModelView = exports.OtherModelView = /*#__PURE__*/function (_ModelView) {
  function OtherModelView(metadata, img, state, modelScript, visScript, readme) {
    var _this$_panels;
    var _this;
    _classCallCheck(this, OtherModelView);
    _this = _callSuper(this, OtherModelView, [metadata, img, modelScript, visScript, readme]);
    _this._schema = schemas.genericModel;
    if (state) {
      _this.panels = _this._createPanels();
    }
    _this._menu = [{
      "label": "General Information",
      "id": "generalInformation",
      "submenus": [{
        "label": "General Information",
        "id": "generalInformation"
      }, {
        "label": "Model Category",
        "id": "modelCategory"
      }, {
        "label": "Reference",
        "id": "reference"
      }, {
        "label": "Author",
        "id": "author"
      }, {
        "label": "Creator",
        "id": "creator"
      }]
    }, {
      "label": "Scope",
      "id": "scope",
      "submenus": [{
        "label": "Scope",
        "id": "scope"
      }, {
        "label": "Hazard",
        "id": "hazard"
      }, {
        "label": "Population Group",
        "id": "populationGroup"
      }, {
        "label": "Product",
        "id": "product"
      }]
    }, {
      "label": "Model Math",
      "id": "modelMath",
      "submenus": [{
        "label": "Model Math",
        "id": "modelMath"
      }, {
        "label": "Quality Measures",
        "id": "qualityMeasures"
      }, {
        "label": "Parameter",
        "id": "parameter",
        "submenus": [{
          "label": "Parameter",
          "id": "parameter"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }, {
        "label": "Model Equation",
        "id": "modelEquation",
        "submenus": [{
          "label": "Model Equation",
          "id": "modelEquation"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }]
    }, {
      "label": "Data Background",
      "id": "dataBackground",
      "submenus": [{
        "label": "Study Sample",
        "id": "studySample"
      }, {
        "label": "Assay",
        "id": "assay"
      }, {
        "label": "Laboratory",
        "id": "laboratory"
      }, {
        "label": "Study",
        "id": "study"
      }]
    }];
    _this._panels = (_this$_panels = {
      study: {
        type: 'simple',
        schema: _this.jsonSchema.dataBackgroundstudy,
        metadata: _this._metadata.study
      },
      laboratory: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundlaboratory,
        metadata: _this._metadata.laboratory
      },
      assay: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundassay,
        metadata: _this._metadata.assay
      },
      studySample: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundstudySample,
        metadata: _this._metadata.studySample
      },
      modelMath: {
        type: 'simple',
        schema: _this.jsonSchema.modelMathmodelMath,
        metadata: _this._metadata.modelMath
      },
      modelEquation: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationmodelEquation,
        metadata: _this._metadata.modelEquation
      },
      reference: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationreference,
        metadata: _this._metadata.reference
      },
      parameter: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.parameterparameter,
        metadata: _this._metadata.parameter
      }
    }, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_this$_panels, "reference", {
      type: 'simple',
      schema: _this.jsonSchema.modelMath.parameterreference,
      metadata: _this._metadata.reference
    }), "qualityMeasures", {
      type: 'complex',
      schema: _this.jsonSchema.modelMathqualityMeasures,
      metadata: _this._metadata.qualityMeasures
    }), "scope", {
      type: 'simple',
      schema: _this.jsonSchema.scopescope,
      metadata: _this._metadata.scope
    }), "product", {
      type: 'complex',
      schema: _this.jsonSchema.scopeproduct,
      metadata: _this._metadata.product
    }), "populationGroup", {
      type: 'complex',
      schema: _this.jsonSchema.scopepopulationGroup,
      metadata: _this._metadata.populationGroup
    }), "hazard", {
      type: 'complex',
      schema: _this.jsonSchema.scopehazard,
      metadata: _this._metadata.hazard
    }), "generalInformation", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationgeneralInformation,
      metadata: _this._metadata.generalInformation
    }), "creator", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationcreator,
      metadata: _this._metadata.creator
    }), "author", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationauthor,
      metadata: _this._metadata.author
    }), "reference", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationreference,
      metadata: _this._metadata.reference
    }), _defineProperty(_this$_panels, "modelCategory", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationmodelCategory,
      metadata: _this._metadata.modelCategory
    }));
    return _this;
  }
  _inherits(OtherModelView, _ModelView);
  return _createClass(OtherModelView, [{
    key: "metaData",
    get: function get() {
      try {
        this._metadata.dataBackground.study = this.panels.study.data;
        this._metadata.dataBackground.laboratory = this.panels.laboratory.data;
        this._metadata.dataBackground.assay = this.panels.assay.data;
        this._metadata.dataBackground.studySample = this.panels.studySample.data;
        this._metadata.modelMath = this.panels.modelMath.data;
        this._metadata.modelMath.modelEquation = this.panels.modelEquation.data;
        this._metadata.modelMath.modelEquation.reference = this.panels.reference.data;
        this._metadata.modelMath.parameter = this.panels.parameter.data;
        this._metadata.modelMath.parameter.reference = this.panels.reference.data;
        this._metadata.modelMath.qualityMeasures = this.panels.qualityMeasures.data;
        this._metadata.scope = this.panels.scope.data;
        this._metadata.scope.product = this.panels.product.data;
        this._metadata.scope.populationGroup = this.panels.populationGroup.data;
        this._metadata.scope.hazard = this.panels.hazard.data;
        this._metadata.generalInformation = this.panels.generalInformation.data;
        this._metadata.generalInformation.creator = this.panels.creator.data;
        this._metadata.generalInformation.author = this.panels.author.data;
        this._metadata.generalInformation.reference = this.panels.reference.data;
        this._metadata.generalInformation.modelCategory = this.panels.modelCategory.data;
        this._metadata.modelType = "OtherModel";
        this._metadata = metadataFix(this._metadata);
      } catch (error) {
        console.log(error);
      }
      return this._metadata;
    }
  }, {
    key: "jsonSchema",
    get: function get() {
      return {
        "dataBackground": {
          "study": [{
            "id": "identifier",
            "label": "Study identifier",
            "type": "text",
            "description": "A user defined identifier for the study"
          }, {
            "id": "protocolComponentsName",
            "label": "Components names",
            "type": "text",
            "description": "The names of the components used when carrying out this protocol"
          }, {
            "id": "designType",
            "label": "Design type",
            "type": "text",
            "description": "The type of study design being employed"
          }, {
            "id": "assayMeasurementType",
            "label": "Assay measurement type",
            "type": "text",
            "description": "The measurement being observed in this assay"
          }, {
            "id": "protocolComponentsType",
            "label": "Protocol components type",
            "type": "text",
            "description": "Description"
          }, {
            "id": "description",
            "label": "Study description",
            "type": "long-text",
            "description": "A brief description of the study aims"
          }, {
            "id": "assayTechnologyPlatform",
            "label": "Assay technology platform",
            "type": "text",
            "description": "The technology platform used"
          }, {
            "id": "assayTechnologyType",
            "label": "Assay technology type",
            "type": "text",
            "description": "The technology being employed to observe this measurement"
          }, {
            "id": "protocolType",
            "label": "Protocol type",
            "type": "text",
            "description": "The type of the protocol, preferably coming from an Ontology, e.g. Extraction Protocol"
          }, {
            "id": "title",
            "label": "Study title",
            "type": "long-text",
            "description": "A title for the study"
          }, {
            "id": "protocolDescription",
            "label": "Protocol description",
            "type": "long-text",
            "description": "A description of the protocol"
          }, {
            "id": "protocolParametersName",
            "label": "Parameters names",
            "type": "text",
            "description": "The parameters used when executing this protocol"
          }, {
            "id": "protocolName",
            "label": "Protocol name",
            "type": "text",
            "description": "The name of the protocol, e.g.Extraction Protocol"
          }, {
            "id": "protocolVersion",
            "label": "Protocol version",
            "type": "text",
            "description": "The version of the protocol used, where applicable."
          }, {
            "id": "protocolURI",
            "label": "Protocol URI",
            "type": "text",
            "description": "A URI to link out to a publication, web page, etc. describing the protocol"
          }, {
            "id": "accreditationProcedureForTheAssayTechnology",
            "label": "Accreditation procedure for assay",
            "type": "text",
            "description": "Accreditation procedure for the analytical method used"
          }],
          "laboratory": [{
            "id": "country",
            "label": "Laboratory country",
            "type": "text",
            "description": "Country where the laboratory is placed. (ISO 3166-1-alpha-2)"
          }, {
            "id": "name",
            "label": "Laboratory name",
            "type": "text",
            "description": "Laboratory code (National laboratory code if available) or Laboratory name "
          }, {
            "id": "accreditation",
            "label": "Laboratory accreditation",
            "description": "The laboratory accreditation to ISO/IEC 17025"
          }],
          "assay": [{
            "id": "contaminationRange",
            "label": "Range of contamination",
            "type": "text",
            "description": "Range of result of the analytical measure reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "uncertaintyValue",
            "label": "Uncertainty value",
            "type": "text",
            "description": "Indicate the expanded uncertainty (usually 95% confidence interval) value associated with the measurement expressed in the unit reported in the field Hazard unit"
          }, {
            "id": "fatPercentage",
            "label": "Percentage of fat",
            "type": "text",
            "description": "Percentage of fat in the original sample"
          }, {
            "id": "name",
            "label": "Assay name",
            "type": "text",
            "description": "A name given to the assay"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the assay. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "moisturePercentage",
            "label": "Percentage of moisture",
            "type": "text",
            "description": "Percentage of moisture in the original sample"
          }, {
            "id": "leftCensoredData",
            "label": "Left-censored data",
            "type": "text",
            "description": "Percentage of measures equal to LOQ and/or LOD"
          }, {
            "id": "detectionLimit",
            "label": "Limit of detection",
            "type": "text",
            "description": "Limit of detection reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "quantificationLimit",
            "label": "Limit of quantification",
            "type": "text",
            "description": "Limit of quantification reported in the unit specified by the variable Hazard unit"
          }],
          "studySample": [{
            "id": "sampleName",
            "label": "Name",
            "type": "text",
            "description": "An unambiguous ID given to the samples used in the assay"
          }, {
            "id": "samplingWeight",
            "label": "Sampling weight",
            "type": "text",
            "description": "Description of the method employed to compute sampling weight (nonresponse-adjusted weight)"
          }, {
            "id": "protocolOfSampleCollection",
            "label": "Protocol of sample collection",
            "type": "text",
            "description": "Additional protocol for sample and sample collection. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "samplingStrategy",
            "label": "Sampling strategy",
            "type": "text",
            "description": "Sampling strategy (ref. EUROSTAT - Typology of sampling strategy, version of July 2009)"
          }, {
            "id": "samplingSize",
            "label": "Sampling size",
            "type": "text",
            "description": "Number of units, full participants, partial participants, eligibles, not eligible, unresolved (eligibility status not resolved)"
          }, {
            "id": "lotSizeUnit",
            "label": "Lot size unit",
            "type": "text",
            "description": "Unit in which the lot size is expressed"
          }, {
            "id": "samplingPoint",
            "label": "Sampling point",
            "type": "text",
            "description": "Point in the food chain where the sample was taken. (Doc. ESTAT/F5/ES/155 Data dictionary of activities of the establishments)"
          }, {
            "id": "samplingMethod",
            "label": "Sampling method",
            "type": "text",
            "description": "Sampling method used to take the sample"
          }, {
            "id": "typeOfSamplingProgram",
            "label": "Type of sampling program",
            "type": "text",
            "description": "Indicate the type of programm for which the samples have been collected"
          }, {
            "id": "samplingPlan",
            "label": "Sampling plan",
            "type": "text",
            "description": "Description of data collection technique: stratified or complex sampling (several stages)"
          }]
        },
        "modelMath": {
          "modelEquation": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "modelEquation": [{
              "id": "modelEquation",
              "label": "Equation",
              "type": "text",
              "description": "The pointer to the file that holds the software code (e.g. R-script)"
            }, {
              "id": "name",
              "label": "Model equation name",
              "type": "text",
              "description": "A name given to the model equation"
            }, {
              "id": "modelHypothesis",
              "label": "Hypothesis of the model",
              "description": "Description of the hypothesis of the model"
            }, {
              "id": "modelEquationClass",
              "label": "Model equation class",
              "type": "text",
              "description": "Information on that helps to categorize model equations"
            }]
          },
          "parameter": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "parameter": [{
              "id": "subject",
              "label": "Parameter subject",
              "type": "text",
              "description": "Scope of the parameter, e.g. if it refers to an animal, a batch of animals, a batch of products, a carcass, a carcass skin etc"
            }, {
              "id": "maxValue",
              "label": "Value max",
              "type": "text",
              "description": "Numerical value of the maximum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "dataType",
              "label": "Data type",
              "type": "text",
              "description": "Information on the data format of the parameter, e.g. if it is a categorical variable: int, double, array of size x,y,z "
            }, {
              "id": "description",
              "label": "Description",
              "type": "text",
              "description": "General description of the parameter"
            }, {
              "id": "source",
              "label": "Parameter source",
              "type": "text",
              "description": "Information on the type of knowledge used to define the parameter value"
            }, {
              "id": "classification",
              "label": "Parameter classification",
              "type": "text",
              "description": "General classification of the parameter (e.g. Input, Constant, Output etc)"
            }, {
              "id": "distribution",
              "label": "Parameter distribution",
              "type": "text",
              "description": "Distribution describing the parameter variabilty. If no distribution selected this means the value provided in 'Parameter value' is a point estimate. In case a distribution is selected the value provided in 'Parameter value' is a string that the model code can parse in order to sample from the named distribution"
            }, {
              "id": "error",
              "label": "Error",
              "type": "text",
              "description": "Error of the parameter value"
            }, {
              "id": "variabilitySubject",
              "label": "Parameter variability subject",
              "type": "text",
              "description": "Information on which the variability is described. It can be variability between broiler in a flock, variability between all meat packages sold in Denmark, variability between days, etc."
            }, {
              "id": "unit",
              "label": "Unit",
              "type": "text",
              "description": "Unit of the parameter"
            }, {
              "id": "minValue",
              "label": "Value min",
              "type": "text",
              "description": "Numerical value of the minimum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "unitCategory",
              "label": "Unit category",
              "type": "text",
              "description": "General classification of the parameter unit"
            }, {
              "id": "name",
              "label": "Parameter name",
              "type": "text",
              "description": "A name given to the parameter"
            }, {
              "id": "id",
              "label": "Parameter ID",
              "type": "text",
              "description": "An unambiguous ID given to each of the parameters - preferably autogenerated by a software tool and compatible with SBML ID requirements, only letters from A to Z, numbers and '_'"
            }, {
              "id": "value",
              "label": "Value",
              "type": "text",
              "description": "A default value for the parameter. This is mandatory (needs to be provided) for all parameters of type 'Input'"
            }]
          },
          "qualityMeasures": [{
            "id": "rsquared",
            "label": "R squared",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sse",
            "label": "SSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "rmse",
            "label": "RMSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "aic",
            "label": "AIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sensitivityAnalysis",
            "label": "Sensitivity analysis",
            "type": "long-text",
            "description": "Description of the results of an sensitivity analysis, i.e. how independence assumptions are met or how variables will affect the output of model"
          }, {
            "id": "bic",
            "label": "BIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "mse",
            "label": "MSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }],
          "modelMath": [{
            "id": "fittingProcedure",
            "label": "Fitting procedure",
            "type": "text",
            "description": "Procedure used to fit the data to the model equation"
          }, {
            "id": "event",
            "label": "Event",
            "description": "Definition of time-dependent parameter changes"
          }]
        },
        "scope": {
          "product": [{
            "id": "expiryDate",
            "label": "Expiration date",
            "type": "date",
            "description": "Expiry date of food/product"
          }, {
            "id": "treatment",
            "label": "Treatment",
            "description": "Used to characterise a product/matrix based on the treatment or processes applied to the product or any indexed ingredient"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the product, matrix or environment for which the model or data applies"
          }, {
            "id": "productionDate",
            "label": "Production date",
            "type": "date",
            "description": "Date of production of food/product"
          }, {
            "id": "method",
            "label": "Method of production",
            "description": "Type of production for the product/ matrix"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "The product, matrix or environment (e.g food product, lab media, soil etc.) for which the model or data applies"
          }, {
            "id": "originCountry",
            "label": "Country of origin",
            "type": "text",
            "description": "Country of origin of the food/product (ISO 3166-1-alpha-2 country code)"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Detailed description of the product, matrix or environment for which the model or data applies"
          }, {
            "id": "packaging",
            "label": "Packaging",
            "description": "Describe container or wrapper that holds the product/matrix. Common type of packaging (paper or plastic bags, boxes, tinplate or aluminium cans, plastic trays, plastic bottles, glass bottles or jars)"
          }, {
            "id": "fisheriesArea",
            "label": "Fisheries area",
            "type": "text",
            "description": "Fisheries or aquaculture area specifying the origin of the sample (FAO Fisheries areas)."
          }, {
            "id": "originArea",
            "label": "Area of origin",
            "type": "text",
            "description": "Area of origin of the food/product (Nomenclature of territorial units for statistics  NUTS  coding system valid only for EEA and Switzerland)."
          }],
          "populationGroup": [{
            "id": "populationRiskFactor",
            "label": "Risk and population factors",
            "description": "Population risk factor that may influence the outcomes of the study, confounder should be included"
          }, {
            "id": "country",
            "label": "Country",
            "description": "Country on which the population group of the model or data applies"
          }, {
            "id": "populationSpan",
            "label": "Population span (years)",
            "description": "Temporal information on the exposure duration"
          }, {
            "id": "populationGender",
            "label": "Population gender",
            "type": "text",
            "description": "Description of the percentage of gender"
          }, {
            "id": "populationDescription",
            "label": "Description",
            "description": "Description of the population for which the model applies (demographic and socio-economic characteristics for example). Background information that are needed in the data analysis phase, size of household, education level, employment status, professional category, ethnicity, etc."
          }, {
            "id": "populationAge",
            "label": "Population age",
            "description": "Description of the range of age or group of age"
          }, {
            "id": "patternConsumption",
            "label": "Consumption pattern",
            "description": "Description of the consumption of different food items, frequency, portion size"
          }, {
            "id": "name",
            "label": "Population name",
            "type": "text",
            "description": "Name of the population for which the model or data applies"
          }, {
            "id": "season",
            "label": "Season",
            "description": "Distribution of surveyed people according to the season (influence consumption pattern)"
          }, {
            "id": "region",
            "label": "Region",
            "description": "Spatial information (area) on which the population group of the model or data applies"
          }, {
            "id": "targetPopulation",
            "label": "Target population",
            "type": "text",
            "description": "Population of individual that we are interested in describing and making statistical inferences about"
          }, {
            "id": "bmi",
            "label": "BMI",
            "description": "Description of the range of BMI or class of BMI or BMI mean"
          }, {
            "id": "specialDietGroups",
            "label": "Special diet groups",
            "description": "Description of sub-population with special diets (vegetarians, diabetics, group following special ethnic diets)"
          }],
          "hazard": [{
            "id": "maximumResidueLimit",
            "label": "Maximum Residue Limit (MRL)",
            "type": "text",
            "description": "International regulations and permissible maximum residue levels in food and drinking water"
          }, {
            "id": "sourceOfContamination",
            "label": "Source of contamination",
            "type": "text",
            "description": "rigin of the contamination, source"
          }, {
            "id": "indSum",
            "label": "Individual or Summed Hazard",
            "type": "text",
            "description": "Define if the parameter reported is an individual residue/analyte, a summed residue definition or part of a sum a summed residue definition"
          }, {
            "id": "acceptableOperatorsExposureLevel",
            "label": "Acceptable Operator Exposure Level (AOEL)",
            "type": "text",
            "description": "Maximum amount of active substance to which the operator may be exposed without any adverse health effects. The AOEL is expressed as milligrams of the chemical per kilogram body weight of the operator"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Description of the hazard for which the model or data applies"
          }, {
            "id": "type",
            "label": "Hazard type",
            "type": "text",
            "description": "General classification of the hazard for which the model or data applies"
          }, {
            "id": "adverseEffect",
            "label": "Adverse effect",
            "type": "text",
            "description": "Adverse effect induced by hazard about morbidity, mortality, and etcetera"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the hazard for which the model or data applies"
          }, {
            "id": "noObservedAdverseAffectLevel",
            "label": "No Observed Adverse Affect Level (NOAEL)",
            "type": "text",
            "description": "Level of exposure of an organism, found by experiment or observation, at which there is no biologically or statistically significant increase in the frequency or severity of any adverse effects in the exposed population when compared to its appropriate control"
          }, {
            "id": "acuteReferenceDose",
            "label": "Acute Reference Dose (ARfD)",
            "type": "text",
            "description": "An estimate (with uncertainty spanning perhaps an order of magnitude) of a daily oral exposure for an acute duration (24 hours or less) to the human population (including sensitive subgroups) that is likely to be without an appreciable risk of deleterious effects during a lifetime"
          }, {
            "id": "name",
            "label": "Hazard name",
            "type": "text",
            "description": "Name of the hazard (agent, contaminant, chemical) for which the data or model applies"
          }, {
            "id": "lowestObservedAdverseAffectLevel",
            "label": "Lowest Observed Adverse Effect Level (LOAEL)",
            "type": "text",
            "description": "Lowest concentration or amount of a substance found by experiment or observation that causes an adverse alteration of morphology, function, capacity, growth, development, or lifespan of a target organism distinguished from normal organisms of the same species under defined conditions of exposure"
          }, {
            "id": "benchmarkDose",
            "label": "Benchmark Dose (BMD)",
            "type": "text",
            "description": "A dose or concentration that produces a predetermined change in response rate of an adverse effect (called the benchmark response or BMR) compared to background"
          }, {
            "id": "acceptableDailyIntake",
            "label": "Acceptable Daily Intake (ADI)",
            "type": "text",
            "description": "Measure of amount of a specific substance in food or in drinking water tahta can be ingested (orally) on a daily basis over a lifetime without an appreciable health risk"
          }],
          "scope": [{
            "id": "spatialInformation",
            "label": "Spatial information",
            "description": "Spatial information (area) on which the model or data applies"
          }, {
            "id": "generalComment",
            "label": "General comment",
            "type": "long-text",
            "description": "General comments on the scope of the study, data or model"
          }, {
            "id": "temporalInformation",
            "label": "Temporal information",
            "type": "long-text",
            "description": "Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)"
          }]
        },
        "generalInformation": {
          "creator": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "author": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "reference": [{
            "id": "date",
            "label": "Date",
            "type": "year_date",
            "description": "Temporal information on the publication date"
          }, {
            "id": "website",
            "label": "Website",
            "type": "text",
            "description": "A link to the publication website (different from DOI)"
          }, {
            "id": "issue",
            "label": "Issue",
            "type": "text",
            "description": "Data on the details of the issue in which the model or date has been described"
          }, {
            "id": "publicationType",
            "label": "Publication type",
            "type": "text",
            "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
          }, {
            "id": "abstract",
            "label": "Abstract",
            "type": "text",
            "description": "Abstract of the publication in which the model or the data has been described "
          }, {
            "id": "isReferenceDescription",
            "label": "Is_reference_description?",
            "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
          }, {
            "id": "title",
            "label": "Title",
            "type": "long-text",
            "description": "Title of publication in which the model or date has been described"
          }, {
            "id": "pmid",
            "label": "PubMed ID",
            "type": "text",
            "description": "The PubMed ID related to this publication"
          }, {
            "id": "volume",
            "label": "Volume",
            "type": "text",
            "description": "Data on the details of the volume in which the model or date has been described"
          }, {
            "id": "journal",
            "label": "Journal",
            "type": "long-text",
            "description": "Data on the details of the journal in which the model or date has been described"
          }, {
            "id": "authorList",
            "label": "Author list",
            "type": "long-text",
            "description": "Name and surname of the authors who contributed to this publication"
          }, {
            "id": "comment",
            "label": "Comment",
            "type": "long-text",
            "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
          }, {
            "id": "doi",
            "label": "Publication DOI",
            "type": "long-text",
            "description": "The DOI related to this publication"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The status of this publication, e.g. Published, Submitted, etc."
          }],
          "modelCategory": [{
            "id": "modelClassComment",
            "label": "Comment",
            "type": "long-text",
            "description": "Comment with further details on the model class"
          }, {
            "id": "basicProcess",
            "label": "Basic process",
            "description": "Defines the impact of the process on the hazard (so far only valid for process models and predictive models)"
          }, {
            "id": "modelClass",
            "label": "Model class",
            "type": "text",
            "description": "Type of model according to RAKIP classification"
          }, {
            "id": "modelSubClass",
            "label": "Subclass",
            "description": "Sub-classification of the model given the Model Class"
          }],
          "generalInformation": [{
            "id": "identifier",
            "label": "Identifier",
            "type": "text",
            "description": "An unambiguous ID given to the model or data. This can also be created automatically by a software tool"
          }, {
            "id": "software",
            "label": "Software",
            "type": "text",
            "description": "The program or software language in which the model has been implemented"
          }, {
            "id": "format",
            "label": "Format",
            "type": "text",
            "description": "File extension of the model or data file (including version number of format if applicable)"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the study, data or model"
          }, {
            "id": "language",
            "label": "Language",
            "type": "text",
            "description": "A language of the resource (some data or reports can be available in French language for example)"
          }, {
            "id": "source",
            "label": "Source",
            "type": "text",
            "description": "A source from which the model/data is derived"
          }, {
            "id": "availability",
            "label": "Availability",
            "type": "text",
            "description": "Availability of data or model, i.e. if the annotated model code / data is included in this FSK file"
          }, {
            "id": "creationDate",
            "label": "Creation date",
            "type": "date",
            "description": "Creation date/time of the FSK file"
          }, {
            "id": "url",
            "label": "URL",
            "type": "text",
            "description": "Web address referencing the resource location (data for example)"
          }, {
            "id": "objective",
            "label": "Objective",
            "type": "long-text",
            "description": "Objective of the model or data"
          }, {
            "id": "modificationDate",
            "label": "Modification date",
            "description": "Date/time of the last version of the FSK file"
          }, {
            "id": "rights",
            "label": "Rights",
            "type": "text",
            "description": "Rights granted for usage, distribution and modification of this FSK file"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "A name given to the model or data"
          }, {
            "id": "languageWrittenIn",
            "label": "Language written in",
            "type": "text",
            "description": "Software language used to write the model, e.g. R or MatLab"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The curation status of the model"
          }]
        }
      };
    }
    // Validate this.panels and return boolean
  }, {
    key: "validate",
    value: function validate() {
      var isValid = true;
      if (!this.panels.generalInformation.validate()) isValid = false;
      if (!this.panels.modelCategory.validate()) isValid = false;
      if (!this.panels.scopeGeneral.validate()) isValid = false;
      if (!this.panels.study.validate()) isValid = false;
      return isValid;
    }
  }, {
    key: "_createPanels",
    value: function _createPanels() {
      var _ref;
      var port = window.port || -1;
      var schema = schemas.genericModel;
      return _ref = {
        study: new _FormPanel.FormPanel("Study", this.jsonSchema.dataBackground.study, this._metadata.dataBackground ? this._metadata.dataBackground.study : {}, port),
        laboratory: new _TablePanel.TablePanel("Laboratory", this.jsonSchema.dataBackground.laboratory, this._metadata.dataBackground ? this._metadata.dataBackground.laboratory : {}, port),
        assay: new _TablePanel.TablePanel("Assay", this.jsonSchema.dataBackground.assay, this._metadata.dataBackground ? this._metadata.dataBackground.assay : {}, port),
        studySample: new _TablePanel.TablePanel("Study Sample", this.jsonSchema.dataBackground.studySample, this._metadata.dataBackground ? this._metadata.dataBackground.studySample : {}, port),
        modelMath: new _FormPanel.FormPanel("Model Math", this.jsonSchema.modelMath.modelMath, this._metadata.modelMath, port),
        modelEquation: new _TablePanel.TablePanel("Model Equation", this.jsonSchema.modelMath.modelEquation.modelEquation, this._metadata.modelMath ? this._metadata.modelMath.modelEquation : {}, port),
        reference: new _TablePanel.TablePanel("Reference", this.jsonSchema.modelMath.modelEquation.reference, this._metadata.modelMath.modelEquation ? this._metadata.modelMath.modelEquation.reference : {}, port),
        parameter: new _TablePanel.TablePanel("Parameter", this.jsonSchema.modelMath.parameter.parameter, this._metadata.modelMath ? this._metadata.modelMath.parameter : {}, port)
      }, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref, "reference", new _FormPanel.FormPanel("Reference", this.jsonSchema.modelMath.parameter.reference, this._metadata.modelMath.parameter ? this._metadata.modelMath.parameter.reference : {}, port)), "qualityMeasures", new _TablePanel.TablePanel("Quality Measures", this.jsonSchema.modelMath.qualityMeasures, this._metadata.modelMath ? this._metadata.modelMath.qualityMeasures : {}, port)), "scope", new _FormPanel.FormPanel("Scope", this.jsonSchema.scope.scope, this._metadata.scope, port)), "product", new _TablePanel.TablePanel("Product", this.jsonSchema.scope.product, this._metadata.scope ? this._metadata.scope.product : {}, port)), "populationGroup", new _TablePanel.TablePanel("Population Group", this.jsonSchema.scope.populationGroup, this._metadata.scope ? this._metadata.scope.populationGroup : {}, port)), "hazard", new _TablePanel.TablePanel("Hazard", this.jsonSchema.scope.hazard, this._metadata.scope ? this._metadata.scope.hazard : {}, port)), "generalInformation", new _FormPanel.FormPanel("General Information", this.jsonSchema.generalInformation.generalInformation, this._metadata.generalInformation, port)), "creator", new _TablePanel.TablePanel("Creator", this.jsonSchema.generalInformation.creator, this._metadata.generalInformation ? this._metadata.generalInformation.creator : {}, port)), "author", new _TablePanel.TablePanel("Author", this.jsonSchema.generalInformation.author, this._metadata.generalInformation ? this._metadata.generalInformation.author : {}, port)), "reference", new _TablePanel.TablePanel("Reference", this.jsonSchema.generalInformation.reference, this._metadata.generalInformation ? this._metadata.generalInformation.reference : {}, port)), _defineProperty(_ref, "modelCategory", new _FormPanel.FormPanel("Model Category", this.jsonSchema.generalInformation.modelCategory, this._metadata.generalInformation ? this._metadata.generalInformation.modelCategory : {}, port));
    }
  }]);
}(_ModelView2.ModelView);

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./ModelView":118,"./OtherModelDataBackgroundView":121,"./OtherModelGeneralInformationView":123,"./OtherModelModelMathView":125,"./OtherModelScopeView":127}],129:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Parameter = void 0;
var _ApiClient = require("../ApiClient");
var _Reference = require("./Reference");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Parameter model module.
 * @module model/Parameter
 * @version 1.0.0
 */
var Parameter = exports.Parameter = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>Parameter</code>.
   * @alias module:model/Parameter
   * @class
   * @param dataType {} Information on the data format of the parameter, e.g. if it is a categorical variable: int, double, array of size x,y,z 
   * @param classification {} General classification of the parameter (e.g. Input, Constant, Output etc)
   * @param unit {} Unit of the parameter
   * @param name {} A name given to the parameter
   * @param id {} An unambiguous ID given to each of the parameters - preferably autogenerated by a software tool and compatible with SBML ID requirements, only letters from A to Z, numbers and '_'
   */
  function Parameter(dataTypeclassificationunitnameid) {
    _classCallCheck(this, Parameter);
    this.dataType = dataType;
    this.classification = classification;
    this.unit = unit;
    this.name = name;
    this.id = id;
  }

  /**
   * Constructs a <code>Parameter</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/Parameter} obj Optional instance to populate.
   * @return {module:model/Parameter} The populated <code>Parameter</code> instance.
   */
  return _createClass(Parameter, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new Parameter();
        if (data.hasOwnProperty('subject')) obj.subject = _ApiClient.ApiClient.convertToType(data['subject'], 'String');
        if (data.hasOwnProperty('maxValue')) obj.maxValue = _ApiClient.ApiClient.convertToType(data['maxValue'], 'String');
        if (data.hasOwnProperty('dataType')) obj.dataType = _ApiClient.ApiClient.convertToType(data['dataType'], 'String');
        if (data.hasOwnProperty('description')) obj.description = _ApiClient.ApiClient.convertToType(data['description'], 'String');
        if (data.hasOwnProperty('source')) obj.source = _ApiClient.ApiClient.convertToType(data['source'], 'String');
        if (data.hasOwnProperty('classification')) obj.classification = _ApiClient.ApiClient.convertToType(data['classification'], 'String');
        if (data.hasOwnProperty('distribution')) obj.distribution = _ApiClient.ApiClient.convertToType(data['distribution'], 'String');
        if (data.hasOwnProperty('error')) obj.error = _ApiClient.ApiClient.convertToType(data['error'], 'String');
        if (data.hasOwnProperty('variabilitySubject')) obj.variabilitySubject = _ApiClient.ApiClient.convertToType(data['variabilitySubject'], 'String');
        if (data.hasOwnProperty('reference')) obj.reference = _Reference.Reference.constructFromObject(data['reference']);
        if (data.hasOwnProperty('unit')) obj.unit = _ApiClient.ApiClient.convertToType(data['unit'], 'String');
        if (data.hasOwnProperty('minValue')) obj.minValue = _ApiClient.ApiClient.convertToType(data['minValue'], 'String');
        if (data.hasOwnProperty('unitCategory')) obj.unitCategory = _ApiClient.ApiClient.convertToType(data['unitCategory'], 'String');
        if (data.hasOwnProperty('name')) obj.name = _ApiClient.ApiClient.convertToType(data['name'], 'String');
        if (data.hasOwnProperty('id')) obj.id = _ApiClient.ApiClient.convertToType(data['id'], 'String');
        if (data.hasOwnProperty('value')) obj.value = _ApiClient.ApiClient.convertToType(data['value'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * Scope of the parameter, e.g. if it refers to an animal, a batch of animals, a batch of products, a carcass, a carcass skin etc
 * @member {String} subject
 */
Parameter.prototype.subject = undefined;

/**
 * Numerical value of the maximum limit of the parameter that determines the range of applicability for which the model applies
 * @member {String} maxValue
 */
Parameter.prototype.maxValue = undefined;

/**
 * Allowed values for the <code>dataType</code> property.
 * @enum {String}
 * @readonly
 */
Parameter.DataTypeEnum = {
  /**
   * value: "INTEGER"
   * @const
   */
  INTEGER: "INTEGER",
  /**
   * value: "DOUBLE"
   * @const
   */
  DOUBLE: "DOUBLE",
  /**
   * value: "NUMBER"
   * @const
   */
  NUMBER: "NUMBER",
  /**
   * value: "DATE"
   * @const
   */
  DATE: "DATE",
  /**
   * value: "FILE"
   * @const
   */
  FILE: "FILE",
  /**
   * value: "BOOLEAN"
   * @const
   */
  BOOLEAN: "BOOLEAN",
  /**
   * value: "VECTOROFNUMBERS"
   * @const
   */
  VECTOROFNUMBERS: "VECTOROFNUMBERS",
  /**
   * value: "VECTOROFSTRINGS"
   * @const
   */
  VECTOROFSTRINGS: "VECTOROFSTRINGS",
  /**
   * value: "MATRIXOFNUMBERS"
   * @const
   */
  MATRIXOFNUMBERS: "MATRIXOFNUMBERS",
  /**
   * value: "MATRIXOFSTRINGS"
   * @const
   */
  MATRIXOFSTRINGS: "MATRIXOFSTRINGS",
  /**
   * value: "OBJECT"
   * @const
   */
  OBJECT: "OBJECT",
  /**
   * value: "STRING"
   * @const
   */
  STRING: "STRING"
};
/**
 * Information on the data format of the parameter, e.g. if it is a categorical variable: int, double, array of size x,y,z 
 * @member {module:model/Parameter.DataTypeEnum} dataType
 */
Parameter.prototype.dataType = undefined;

/**
 * General description of the parameter
 * @member {String} description
 */
Parameter.prototype.description = undefined;

/**
 * Information on the type of knowledge used to define the parameter value
 * @member {String} source
 */
Parameter.prototype.source = undefined;

/**
 * Allowed values for the <code>classification</code> property.
 * @enum {String}
 * @readonly
 */
Parameter.ClassificationEnum = {
  /**
   * value: "CONSTANT"
   * @const
   */
  CONSTANT: "CONSTANT",
  /**
   * value: "INPUT"
   * @const
   */
  INPUT: "INPUT",
  /**
   * value: "OUTPUT"
   * @const
   */
  OUTPUT: "OUTPUT"
};
/**
 * General classification of the parameter (e.g. Input, Constant, Output etc)
 * @member {module:model/Parameter.ClassificationEnum} classification
 */
Parameter.prototype.classification = undefined;

/**
 * Distribution describing the parameter variabilty. If no distribution selected this means the value provided in 'Parameter value' is a point estimate. In case a distribution is selected the value provided in 'Parameter value' is a string that the model code can parse in order to sample from the named distribution
 * @member {String} distribution
 */
Parameter.prototype.distribution = undefined;

/**
 * Error of the parameter value
 * @member {String} error
 */
Parameter.prototype.error = undefined;

/**
 * Information on which the variability is described. It can be variability between broiler in a flock, variability between all meat packages sold in Denmark, variability between days, etc.
 * @member {String} variabilitySubject
 */
Parameter.prototype.variabilitySubject = undefined;

/**
 * @member {module:model/Reference} reference
 */
Parameter.prototype.reference = undefined;

/**
 * Unit of the parameter
 * @member {String} unit
 */
Parameter.prototype.unit = undefined;

/**
 * Numerical value of the minimum limit of the parameter that determines the range of applicability for which the model applies
 * @member {String} minValue
 */
Parameter.prototype.minValue = undefined;

/**
 * General classification of the parameter unit
 * @member {String} unitCategory
 */
Parameter.prototype.unitCategory = undefined;

/**
 * A name given to the parameter
 * @member {String} name
 */
Parameter.prototype.name = undefined;

/**
 * An unambiguous ID given to each of the parameters - preferably autogenerated by a software tool and compatible with SBML ID requirements, only letters from A to Z, numbers and '_'
 * @member {String} id
 */
Parameter.prototype.id = undefined;

/**
 * A default value for the parameter. This is mandatory (needs to be provided) for all parameters of type 'Input'
 * @member {String} value
 */
Parameter.prototype.value = undefined;

},{"../ApiClient":44,"./Reference":155}],130:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ParameterView = void 0;
var _ApiClient = require("../ApiClient");
var _ReferenceView = require("./ReferenceView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Parameter View  module.
 * @module model/Parameter
 * @version 1.0.0
 */
var ParameterView = exports.ParameterView = /*#__PURE__*/_createClass(function ParameterView() {
  _classCallCheck(this, ParameterView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./ReferenceView":156}],131:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PopulationGroup = void 0;
var _ApiClient = require("../ApiClient");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The PopulationGroup model module.
 * @module model/PopulationGroup
 * @version 1.0.0
 */
var PopulationGroup = exports.PopulationGroup = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>PopulationGroup</code>.
   * @alias module:model/PopulationGroup
   * @class
   * @param name {} Name of the population for which the model or data applies
   */
  function PopulationGroup(name) {
    _classCallCheck(this, PopulationGroup);
    this.name = name;
  }

  /**
   * Constructs a <code>PopulationGroup</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/PopulationGroup} obj Optional instance to populate.
   * @return {module:model/PopulationGroup} The populated <code>PopulationGroup</code> instance.
   */
  return _createClass(PopulationGroup, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new PopulationGroup();
        if (data.hasOwnProperty('populationRiskFactor')) obj.populationRiskFactor = _ApiClient.ApiClient.convertToType(data['populationRiskFactor'], ['String']);
        if (data.hasOwnProperty('country')) obj.country = _ApiClient.ApiClient.convertToType(data['country'], ['String']);
        if (data.hasOwnProperty('populationSpan')) obj.populationSpan = _ApiClient.ApiClient.convertToType(data['populationSpan'], ['String']);
        if (data.hasOwnProperty('populationGender')) obj.populationGender = _ApiClient.ApiClient.convertToType(data['populationGender'], 'String');
        if (data.hasOwnProperty('populationDescription')) obj.populationDescription = _ApiClient.ApiClient.convertToType(data['populationDescription'], ['String']);
        if (data.hasOwnProperty('populationAge')) obj.populationAge = _ApiClient.ApiClient.convertToType(data['populationAge'], ['String']);
        if (data.hasOwnProperty('patternConsumption')) obj.patternConsumption = _ApiClient.ApiClient.convertToType(data['patternConsumption'], ['String']);
        if (data.hasOwnProperty('name')) obj.name = _ApiClient.ApiClient.convertToType(data['name'], 'String');
        if (data.hasOwnProperty('season')) obj.season = _ApiClient.ApiClient.convertToType(data['season'], ['String']);
        if (data.hasOwnProperty('region')) obj.region = _ApiClient.ApiClient.convertToType(data['region'], ['String']);
        if (data.hasOwnProperty('targetPopulation')) obj.targetPopulation = _ApiClient.ApiClient.convertToType(data['targetPopulation'], 'String');
        if (data.hasOwnProperty('bmi')) obj.bmi = _ApiClient.ApiClient.convertToType(data['bmi'], ['String']);
        if (data.hasOwnProperty('specialDietGroups')) obj.specialDietGroups = _ApiClient.ApiClient.convertToType(data['specialDietGroups'], ['String']);
      }
      return obj;
    }
  }]);
}();
/**
 * Population risk factor that may influence the outcomes of the study, confounder should be included
 * @member {Array.<String>} populationRiskFactor
 */
PopulationGroup.prototype.populationRiskFactor = undefined;

/**
 * Country on which the population group of the model or data applies
 * @member {Array.<String>} country
 */
PopulationGroup.prototype.country = undefined;

/**
 * Temporal information on the exposure duration
 * @member {Array.<String>} populationSpan
 */
PopulationGroup.prototype.populationSpan = undefined;

/**
 * Description of the percentage of gender
 * @member {String} populationGender
 */
PopulationGroup.prototype.populationGender = undefined;

/**
 * Description of the population for which the model applies (demographic and socio-economic characteristics for example). Background information that are needed in the data analysis phase, size of household, education level, employment status, professional category, ethnicity, etc.
 * @member {Array.<String>} populationDescription
 */
PopulationGroup.prototype.populationDescription = undefined;

/**
 * Description of the range of age or group of age
 * @member {Array.<String>} populationAge
 */
PopulationGroup.prototype.populationAge = undefined;

/**
 * Description of the consumption of different food items, frequency, portion size
 * @member {Array.<String>} patternConsumption
 */
PopulationGroup.prototype.patternConsumption = undefined;

/**
 * Name of the population for which the model or data applies
 * @member {String} name
 */
PopulationGroup.prototype.name = undefined;

/**
 * Distribution of surveyed people according to the season (influence consumption pattern)
 * @member {Array.<String>} season
 */
PopulationGroup.prototype.season = undefined;

/**
 * Spatial information (area) on which the population group of the model or data applies
 * @member {Array.<String>} region
 */
PopulationGroup.prototype.region = undefined;

/**
 * Population of individual that we are interested in describing and making statistical inferences about
 * @member {String} targetPopulation
 */
PopulationGroup.prototype.targetPopulation = undefined;

/**
 * Description of the range of BMI or class of BMI or BMI mean
 * @member {Array.<String>} bmi
 */
PopulationGroup.prototype.bmi = undefined;

/**
 * Description of sub-population with special diets (vegetarians, diabetics, group following special ethnic diets)
 * @member {Array.<String>} specialDietGroups
 */
PopulationGroup.prototype.specialDietGroups = undefined;

},{"../ApiClient":44}],132:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PopulationGroupView = void 0;
var _ApiClient = require("../ApiClient");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The PopulationGroup View  module.
 * @module model/PopulationGroup
 * @version 1.0.0
 */
var PopulationGroupView = exports.PopulationGroupView = /*#__PURE__*/_createClass(function PopulationGroupView() {
  _classCallCheck(this, PopulationGroupView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63}],133:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PredictiveModel = void 0;
var _ApiClient = require("../ApiClient");
var _Model2 = require("./Model");
var _PredictiveModelDataBackground = require("./PredictiveModelDataBackground");
var _PredictiveModelGeneralInformation = require("./PredictiveModelGeneralInformation");
var _PredictiveModelModelMath = require("./PredictiveModelModelMath");
var _PredictiveModelScope = require("./PredictiveModelScope");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The PredictiveModel model module.
 * @module model/PredictiveModel
 * @version 1.0.0
 */
var PredictiveModel = exports.PredictiveModel = /*#__PURE__*/function (_Model) {
  /**
   * Constructs a new <code>PredictiveModel</code>.
   * @alias module:model/PredictiveModel
   * @class
   * @extends module:model/Model
   * @param modelType {} 
   */
  function PredictiveModel(modelType) {
    _classCallCheck(this, PredictiveModel);
    return _callSuper(this, PredictiveModel, [modelType]);
  }

  /**
   * Constructs a <code>PredictiveModel</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/PredictiveModel} obj Optional instance to populate.
   * @return {module:model/PredictiveModel} The populated <code>PredictiveModel</code> instance.
   */
  _inherits(PredictiveModel, _Model);
  return _createClass(PredictiveModel, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new PredictiveModel();
        _Model2.Model.constructFromObject(data, obj);
        if (data.hasOwnProperty('dataBackground')) obj.dataBackground = _PredictiveModelDataBackground.PredictiveModelDataBackground.constructFromObject(data['dataBackground']);
        if (data.hasOwnProperty('modelMath')) obj.modelMath = _PredictiveModelModelMath.PredictiveModelModelMath.constructFromObject(data['modelMath']);
        if (data.hasOwnProperty('scope')) obj.scope = _PredictiveModelScope.PredictiveModelScope.constructFromObject(data['scope']);
        if (data.hasOwnProperty('generalInformation')) obj.generalInformation = _PredictiveModelGeneralInformation.PredictiveModelGeneralInformation.constructFromObject(data['generalInformation']);
      }
      return obj;
    }
  }]);
}(_Model2.Model);
/**
 * @member {module:model/PredictiveModelDataBackground} dataBackground
 */
PredictiveModel.prototype.dataBackground = undefined;

/**
 * @member {module:model/PredictiveModelModelMath} modelMath
 */
PredictiveModel.prototype.modelMath = undefined;

/**
 * @member {module:model/PredictiveModelScope} scope
 */
PredictiveModel.prototype.scope = undefined;

/**
 * @member {module:model/PredictiveModelGeneralInformation} generalInformation
 */
PredictiveModel.prototype.generalInformation = undefined;

},{"../ApiClient":44,"./Model":113,"./PredictiveModelDataBackground":134,"./PredictiveModelGeneralInformation":136,"./PredictiveModelModelMath":138,"./PredictiveModelScope":140}],134:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PredictiveModelDataBackground = void 0;
var _ApiClient = require("../ApiClient");
var _Assay = require("./Assay");
var _Laboratory = require("./Laboratory");
var _Study = require("./Study");
var _StudySample = require("./StudySample");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The PredictiveModelDataBackground model module.
 * @module model/PredictiveModelDataBackground
 * @version 1.0.0
 */
var PredictiveModelDataBackground = exports.PredictiveModelDataBackground = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>PredictiveModelDataBackground</code>.
   * @alias module:model/PredictiveModelDataBackground
   * @class
   * @param study {} 
   */
  function PredictiveModelDataBackground(study) {
    _classCallCheck(this, PredictiveModelDataBackground);
    this.study = study;
  }

  /**
   * Constructs a <code>PredictiveModelDataBackground</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/PredictiveModelDataBackground} obj Optional instance to populate.
   * @return {module:model/PredictiveModelDataBackground} The populated <code>PredictiveModelDataBackground</code> instance.
   */
  return _createClass(PredictiveModelDataBackground, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new PredictiveModelDataBackground();
        if (data.hasOwnProperty('study')) obj.study = _Study.Study.constructFromObject(data['study']);
        if (data.hasOwnProperty('laboratory')) obj.laboratory = _ApiClient.ApiClient.convertToType(data['laboratory'], [_Laboratory.Laboratory]);
        if (data.hasOwnProperty('assay')) obj.assay = _ApiClient.ApiClient.convertToType(data['assay'], [_Assay.Assay]);
        if (data.hasOwnProperty('studySample')) obj.studySample = _ApiClient.ApiClient.convertToType(data['studySample'], [_StudySample.StudySample]);
      }
      return obj;
    }
  }]);
}();
/**
 * @member {module:model/Study} study
 */
PredictiveModelDataBackground.prototype.study = undefined;

/**
 * @member {Array.<module:model/Laboratory>} laboratory
 */
PredictiveModelDataBackground.prototype.laboratory = undefined;

/**
 * @member {Array.<module:model/Assay>} assay
 */
PredictiveModelDataBackground.prototype.assay = undefined;

/**
 * @member {Array.<module:model/StudySample>} studySample
 */
PredictiveModelDataBackground.prototype.studySample = undefined;

},{"../ApiClient":44,"./Assay":65,"./Laboratory":111,"./Study":159,"./StudySample":160}],135:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PredictiveModelDataBackgroundView = void 0;
var _ApiClient = require("../ApiClient");
var _AssayView = require("./AssayView");
var _LaboratoryView = require("./LaboratoryView");
var _StudyView = require("./StudyView");
var _StudySampleView = require("./StudySampleView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The PredictiveModelDataBackground View  module.
 * @module model/PredictiveModelDataBackground
 * @version 1.0.0
 */
var PredictiveModelDataBackgroundView = exports.PredictiveModelDataBackgroundView = /*#__PURE__*/_createClass(function PredictiveModelDataBackgroundView() {
  _classCallCheck(this, PredictiveModelDataBackgroundView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./AssayView":66,"./LaboratoryView":112,"./StudySampleView":161,"./StudyView":162}],136:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PredictiveModelGeneralInformation = void 0;
var _ApiClient = require("../ApiClient");
var _Contact = require("./Contact");
var _ModelCategory = require("./ModelCategory");
var _Reference = require("./Reference");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The PredictiveModelGeneralInformation model module.
 * @module model/PredictiveModelGeneralInformation
 * @version 1.0.0
 */
var PredictiveModelGeneralInformation = exports.PredictiveModelGeneralInformation = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>PredictiveModelGeneralInformation</code>.
   * @alias module:model/PredictiveModelGeneralInformation
   * @class
   * @param identifier {} An unambiguous ID given to the model or data. This can also be created automatically by a software tool
   * @param creationDate {} Creation date/time of the FSK file
   * @param reference {} 
   * @param rights {} Rights granted for usage, distribution and modification of this FSK file
   * @param name {} A name given to the model or data
   * @param languageWrittenIn {} Software language used to write the model, e.g. R or MatLab
   */
  function PredictiveModelGeneralInformation(identifiercreationDatereferencerightsnamelanguageWrittenIn) {
    _classCallCheck(this, PredictiveModelGeneralInformation);
    this.identifier = identifier;
    this.creationDate = creationDate;
    this.reference = reference;
    this.rights = rights;
    this.name = name;
    this.languageWrittenIn = languageWrittenIn;
  }

  /**
   * Constructs a <code>PredictiveModelGeneralInformation</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/PredictiveModelGeneralInformation} obj Optional instance to populate.
   * @return {module:model/PredictiveModelGeneralInformation} The populated <code>PredictiveModelGeneralInformation</code> instance.
   */
  return _createClass(PredictiveModelGeneralInformation, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new PredictiveModelGeneralInformation();
        if (data.hasOwnProperty('identifier')) obj.identifier = _ApiClient.ApiClient.convertToType(data['identifier'], 'String');
        if (data.hasOwnProperty('creator')) obj.creator = _ApiClient.ApiClient.convertToType(data['creator'], [_Contact.Contact]);
        if (data.hasOwnProperty('software')) obj.software = _ApiClient.ApiClient.convertToType(data['software'], 'String');
        if (data.hasOwnProperty('author')) obj.author = _ApiClient.ApiClient.convertToType(data['author'], [_Contact.Contact]);
        if (data.hasOwnProperty('format')) obj.format = _ApiClient.ApiClient.convertToType(data['format'], 'String');
        if (data.hasOwnProperty('description')) obj.description = _ApiClient.ApiClient.convertToType(data['description'], 'String');
        if (data.hasOwnProperty('language')) obj.language = _ApiClient.ApiClient.convertToType(data['language'], 'String');
        if (data.hasOwnProperty('source')) obj.source = _ApiClient.ApiClient.convertToType(data['source'], 'String');
        if (data.hasOwnProperty('availability')) obj.availability = _ApiClient.ApiClient.convertToType(data['availability'], 'String');
        if (data.hasOwnProperty('creationDate')) obj.creationDate = _ApiClient.ApiClient.convertToType(data['creationDate'], 'Date');
        if (data.hasOwnProperty('url')) obj.url = _ApiClient.ApiClient.convertToType(data['url'], 'String');
        if (data.hasOwnProperty('objective')) obj.objective = _ApiClient.ApiClient.convertToType(data['objective'], 'String');
        if (data.hasOwnProperty('reference')) obj.reference = _ApiClient.ApiClient.convertToType(data['reference'], [_Reference.Reference]);
        if (data.hasOwnProperty('modificationDate')) obj.modificationDate = _ApiClient.ApiClient.convertToType(data['modificationDate'], ['Date']);
        if (data.hasOwnProperty('rights')) obj.rights = _ApiClient.ApiClient.convertToType(data['rights'], 'String');
        if (data.hasOwnProperty('name')) obj.name = _ApiClient.ApiClient.convertToType(data['name'], 'String');
        if (data.hasOwnProperty('languageWrittenIn')) obj.languageWrittenIn = _ApiClient.ApiClient.convertToType(data['languageWrittenIn'], 'String');
        if (data.hasOwnProperty('modelCategory')) obj.modelCategory = _ModelCategory.ModelCategory.constructFromObject(data['modelCategory']);
        if (data.hasOwnProperty('status')) obj.status = _ApiClient.ApiClient.convertToType(data['status'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * An unambiguous ID given to the model or data. This can also be created automatically by a software tool
 * @member {String} identifier
 */
PredictiveModelGeneralInformation.prototype.identifier = undefined;

/**
 * The person(s) that created this FSK file including all metadata
 * @member {Array.<module:model/Contact>} creator
 */
PredictiveModelGeneralInformation.prototype.creator = undefined;

/**
 * The program or software language in which the model has been implemented
 * @member {String} software
 */
PredictiveModelGeneralInformation.prototype.software = undefined;

/**
 * Person(s) who generated the model code or generated the data set originally
 * @member {Array.<module:model/Contact>} author
 */
PredictiveModelGeneralInformation.prototype.author = undefined;

/**
 * File extension of the model or data file (including version number of format if applicable)
 * @member {String} format
 */
PredictiveModelGeneralInformation.prototype.format = undefined;

/**
 * General description of the study, data or model
 * @member {String} description
 */
PredictiveModelGeneralInformation.prototype.description = undefined;

/**
 * A language of the resource (some data or reports can be available in French language for example)
 * @member {String} language
 */
PredictiveModelGeneralInformation.prototype.language = undefined;

/**
 * A source from which the model/data is derived
 * @member {String} source
 */
PredictiveModelGeneralInformation.prototype.source = undefined;

/**
 * Availability of data or model, i.e. if the annotated model code / data is included in this FSK file
 * @member {String} availability
 */
PredictiveModelGeneralInformation.prototype.availability = undefined;

/**
 * Creation date/time of the FSK file
 * @member {Date} creationDate
 */
PredictiveModelGeneralInformation.prototype.creationDate = undefined;

/**
 * Web address referencing the resource location (data for example)
 * @member {String} url
 */
PredictiveModelGeneralInformation.prototype.url = undefined;

/**
 * Objective of the model or data
 * @member {String} objective
 */
PredictiveModelGeneralInformation.prototype.objective = undefined;

/**
 * @member {Array.<module:model/Reference>} reference
 */
PredictiveModelGeneralInformation.prototype.reference = undefined;

/**
 * Date/time of the last version of the FSK file
 * @member {Array.<Date>} modificationDate
 */
PredictiveModelGeneralInformation.prototype.modificationDate = undefined;

/**
 * Rights granted for usage, distribution and modification of this FSK file
 * @member {String} rights
 */
PredictiveModelGeneralInformation.prototype.rights = undefined;

/**
 * A name given to the model or data
 * @member {String} name
 */
PredictiveModelGeneralInformation.prototype.name = undefined;

/**
 * Software language used to write the model, e.g. R or MatLab
 * @member {String} languageWrittenIn
 */
PredictiveModelGeneralInformation.prototype.languageWrittenIn = undefined;

/**
 * @member {module:model/ModelCategory} modelCategory
 */
PredictiveModelGeneralInformation.prototype.modelCategory = undefined;

/**
 * The curation status of the model
 * @member {String} status
 */
PredictiveModelGeneralInformation.prototype.status = undefined;

},{"../ApiClient":44,"./Contact":71,"./ModelCategory":114,"./Reference":155}],137:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PredictiveModelGeneralInformationView = void 0;
var _ApiClient = require("../ApiClient");
var _ContactView = require("./ContactView");
var _ModelCategoryView = require("./ModelCategoryView");
var _ReferenceView = require("./ReferenceView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The PredictiveModelGeneralInformation View  module.
 * @module model/PredictiveModelGeneralInformation
 * @version 1.0.0
 */
var PredictiveModelGeneralInformationView = exports.PredictiveModelGeneralInformationView = /*#__PURE__*/_createClass(function PredictiveModelGeneralInformationView() {
  _classCallCheck(this, PredictiveModelGeneralInformationView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./ContactView":72,"./ModelCategoryView":115,"./ReferenceView":156}],138:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PredictiveModelModelMath = void 0;
var _ApiClient = require("../ApiClient");
var _ModelEquation = require("./ModelEquation");
var _Parameter = require("./Parameter");
var _QualityMeasures = require("./QualityMeasures");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The PredictiveModelModelMath model module.
 * @module model/PredictiveModelModelMath
 * @version 1.0.0
 */
var PredictiveModelModelMath = exports.PredictiveModelModelMath = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>PredictiveModelModelMath</code>.
   * @alias module:model/PredictiveModelModelMath
   * @class
   * @param parameter {} 
   */
  function PredictiveModelModelMath(parameter) {
    _classCallCheck(this, PredictiveModelModelMath);
    this.parameter = parameter;
  }

  /**
   * Constructs a <code>PredictiveModelModelMath</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/PredictiveModelModelMath} obj Optional instance to populate.
   * @return {module:model/PredictiveModelModelMath} The populated <code>PredictiveModelModelMath</code> instance.
   */
  return _createClass(PredictiveModelModelMath, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new PredictiveModelModelMath();
        if (data.hasOwnProperty('fittingProcedure')) obj.fittingProcedure = _ApiClient.ApiClient.convertToType(data['fittingProcedure'], 'String');
        if (data.hasOwnProperty('modelEquation')) obj.modelEquation = _ApiClient.ApiClient.convertToType(data['modelEquation'], [_ModelEquation.ModelEquation]);
        if (data.hasOwnProperty('parameter')) obj.parameter = _ApiClient.ApiClient.convertToType(data['parameter'], [_Parameter.Parameter]);
        if (data.hasOwnProperty('qualityMeasures')) obj.qualityMeasures = _ApiClient.ApiClient.convertToType(data['qualityMeasures'], [_QualityMeasures.QualityMeasures]);
        if (data.hasOwnProperty('event')) obj.event = _ApiClient.ApiClient.convertToType(data['event'], ['String']);
      }
      return obj;
    }
  }]);
}();
/**
 * Procedure used to fit the data to the model equation
 * @member {String} fittingProcedure
 */
PredictiveModelModelMath.prototype.fittingProcedure = undefined;

/**
 * @member {Array.<module:model/ModelEquation>} modelEquation
 */
PredictiveModelModelMath.prototype.modelEquation = undefined;

/**
 * @member {Array.<module:model/Parameter>} parameter
 */
PredictiveModelModelMath.prototype.parameter = undefined;

/**
 * @member {Array.<module:model/QualityMeasures>} qualityMeasures
 */
PredictiveModelModelMath.prototype.qualityMeasures = undefined;

/**
 * Definition of time-dependent parameter changes
 * @member {Array.<String>} event
 */
PredictiveModelModelMath.prototype.event = undefined;

},{"../ApiClient":44,"./ModelEquation":116,"./Parameter":129,"./QualityMeasures":153}],139:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PredictiveModelModelMathView = void 0;
var _ApiClient = require("../ApiClient");
var _ModelEquationView = require("./ModelEquationView");
var _ParameterView = require("./ParameterView");
var _QualityMeasuresView = require("./QualityMeasuresView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The PredictiveModelModelMath View  module.
 * @module model/PredictiveModelModelMath
 * @version 1.0.0
 */
var PredictiveModelModelMathView = exports.PredictiveModelModelMathView = /*#__PURE__*/_createClass(function PredictiveModelModelMathView() {
  _classCallCheck(this, PredictiveModelModelMathView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./ModelEquationView":117,"./ParameterView":130,"./QualityMeasuresView":154}],140:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PredictiveModelScope = void 0;
var _ApiClient = require("../ApiClient");
var _Hazard = require("./Hazard");
var _PredictiveModelScopeProduct = require("./PredictiveModelScopeProduct");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The PredictiveModelScope model module.
 * @module model/PredictiveModelScope
 * @version 1.0.0
 */
var PredictiveModelScope = exports.PredictiveModelScope = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>PredictiveModelScope</code>.
   * @alias module:model/PredictiveModelScope
   * @class
   */
  function PredictiveModelScope() {
    _classCallCheck(this, PredictiveModelScope);
  }

  /**
   * Constructs a <code>PredictiveModelScope</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/PredictiveModelScope} obj Optional instance to populate.
   * @return {module:model/PredictiveModelScope} The populated <code>PredictiveModelScope</code> instance.
   */
  return _createClass(PredictiveModelScope, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new PredictiveModelScope();
        if (data.hasOwnProperty('spatialInformation')) obj.spatialInformation = _ApiClient.ApiClient.convertToType(data['spatialInformation'], ['String']);
        if (data.hasOwnProperty('product')) obj.product = _ApiClient.ApiClient.convertToType(data['product'], [_PredictiveModelScopeProduct.PredictiveModelScopeProduct]);
        if (data.hasOwnProperty('hazard')) obj.hazard = _ApiClient.ApiClient.convertToType(data['hazard'], [_Hazard.Hazard]);
        if (data.hasOwnProperty('generalComment')) obj.generalComment = _ApiClient.ApiClient.convertToType(data['generalComment'], 'String');
        if (data.hasOwnProperty('temporalInformation')) obj.temporalInformation = _ApiClient.ApiClient.convertToType(data['temporalInformation'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * Spatial information (area) on which the model or data applies
 * @member {Array.<String>} spatialInformation
 */
PredictiveModelScope.prototype.spatialInformation = undefined;

/**
 * @member {Array.<module:model/PredictiveModelScopeProduct>} product
 */
PredictiveModelScope.prototype.product = undefined;

/**
 * @member {Array.<module:model/Hazard>} hazard
 */
PredictiveModelScope.prototype.hazard = undefined;

/**
 * General comments on the scope of the study, data or model
 * @member {String} generalComment
 */
PredictiveModelScope.prototype.generalComment = undefined;

/**
 * Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)
 * @member {String} temporalInformation
 */
PredictiveModelScope.prototype.temporalInformation = undefined;

},{"../ApiClient":44,"./Hazard":105,"./PredictiveModelScopeProduct":141}],141:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PredictiveModelScopeProduct = void 0;
var _ApiClient = require("../ApiClient");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The PredictiveModelScopeProduct model module.
 * @module model/PredictiveModelScopeProduct
 * @version 1.0.0
 */
var PredictiveModelScopeProduct = exports.PredictiveModelScopeProduct = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>PredictiveModelScopeProduct</code>.
   * @alias module:model/PredictiveModelScopeProduct
   * @class
   * @param unit {} Unit of the product, matrix or environment for which the model or data applies
   * @param name {} The product, matrix or environment (e.g food product, lab media, soil etc.) for which the model or data applies
   */
  function PredictiveModelScopeProduct(unitname) {
    _classCallCheck(this, PredictiveModelScopeProduct);
    this.unit = unit;
    this.name = name;
  }

  /**
   * Constructs a <code>PredictiveModelScopeProduct</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/PredictiveModelScopeProduct} obj Optional instance to populate.
   * @return {module:model/PredictiveModelScopeProduct} The populated <code>PredictiveModelScopeProduct</code> instance.
   */
  return _createClass(PredictiveModelScopeProduct, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new PredictiveModelScopeProduct();
        if (data.hasOwnProperty('expiryDate')) obj.expiryDate = _ApiClient.ApiClient.convertToType(data['expiryDate'], 'Date');
        if (data.hasOwnProperty('treatment')) obj.treatment = _ApiClient.ApiClient.convertToType(data['treatment'], ['String']);
        if (data.hasOwnProperty('unit')) obj.unit = _ApiClient.ApiClient.convertToType(data['unit'], 'String');
        if (data.hasOwnProperty('productionDate')) obj.productionDate = _ApiClient.ApiClient.convertToType(data['productionDate'], 'Date');
        if (data.hasOwnProperty('method')) obj.method = _ApiClient.ApiClient.convertToType(data['method'], ['String']);
        if (data.hasOwnProperty('name')) obj.name = _ApiClient.ApiClient.convertToType(data['name'], 'String');
        if (data.hasOwnProperty('originCountry')) obj.originCountry = _ApiClient.ApiClient.convertToType(data['originCountry'], 'String');
        if (data.hasOwnProperty('description')) obj.description = _ApiClient.ApiClient.convertToType(data['description'], 'String');
        if (data.hasOwnProperty('packaging')) obj.packaging = _ApiClient.ApiClient.convertToType(data['packaging'], ['String']);
        if (data.hasOwnProperty('fisheriesArea')) obj.fisheriesArea = _ApiClient.ApiClient.convertToType(data['fisheriesArea'], 'String');
        if (data.hasOwnProperty('originArea')) obj.originArea = _ApiClient.ApiClient.convertToType(data['originArea'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * Expiry date of food/product
 * @member {Date} expiryDate
 */
PredictiveModelScopeProduct.prototype.expiryDate = undefined;

/**
 * Used to characterise a product/matrix based on the treatment or processes applied to the product or any indexed ingredient
 * @member {Array.<String>} treatment
 */
PredictiveModelScopeProduct.prototype.treatment = undefined;

/**
 * Unit of the product, matrix or environment for which the model or data applies
 * @member {String} unit
 */
PredictiveModelScopeProduct.prototype.unit = undefined;

/**
 * Date of production of food/product
 * @member {Date} productionDate
 */
PredictiveModelScopeProduct.prototype.productionDate = undefined;

/**
 * Type of production for the product/ matrix
 * @member {Array.<String>} method
 */
PredictiveModelScopeProduct.prototype.method = undefined;

/**
 * The product, matrix or environment (e.g food product, lab media, soil etc.) for which the model or data applies
 * @member {String} name
 */
PredictiveModelScopeProduct.prototype.name = undefined;

/**
 * Country of origin of the food/product (ISO 3166-1-alpha-2 country code)
 * @member {String} originCountry
 */
PredictiveModelScopeProduct.prototype.originCountry = undefined;

/**
 * Detailed description of the product, matrix or environment for which the model or data applies
 * @member {String} description
 */
PredictiveModelScopeProduct.prototype.description = undefined;

/**
 * Describe container or wrapper that holds the product/matrix. Common type of packaging (paper or plastic bags, boxes, tinplate or aluminium cans, plastic trays, plastic bottles, glass bottles or jars)
 * @member {Array.<String>} packaging
 */
PredictiveModelScopeProduct.prototype.packaging = undefined;

/**
 * Fisheries or aquaculture area specifying the origin of the sample (FAO Fisheries areas).
 * @member {String} fisheriesArea
 */
PredictiveModelScopeProduct.prototype.fisheriesArea = undefined;

/**
 * Area of origin of the food/product (Nomenclature of territorial units for statistics  NUTS  coding system valid only for EEA and Switzerland).
 * @member {String} originArea
 */
PredictiveModelScopeProduct.prototype.originArea = undefined;

},{"../ApiClient":44}],142:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PredictiveModelScopeProductView = void 0;
var _ApiClient = require("../ApiClient");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The PredictiveModelScopeProduct View  module.
 * @module model/PredictiveModelScopeProduct
 * @version 1.0.0
 */
var PredictiveModelScopeProductView = exports.PredictiveModelScopeProductView = /*#__PURE__*/_createClass(function PredictiveModelScopeProductView() {
  _classCallCheck(this, PredictiveModelScopeProductView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63}],143:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PredictiveModelScopeView = void 0;
var _ApiClient = require("../ApiClient");
var _HazardView = require("./HazardView");
var _PredictiveModelScopeProductView = require("./PredictiveModelScopeProductView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The PredictiveModelScope View  module.
 * @module model/PredictiveModelScope
 * @version 1.0.0
 */
var PredictiveModelScopeView = exports.PredictiveModelScopeView = /*#__PURE__*/_createClass(function PredictiveModelScopeView() {
  _classCallCheck(this, PredictiveModelScopeView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./HazardView":106,"./PredictiveModelScopeProductView":142}],144:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PredictiveModelView = void 0;
var _ApiClient = require("../ApiClient");
var _ModelView2 = require("./ModelView");
var _PredictiveModelDataBackgroundView = require("./PredictiveModelDataBackgroundView");
var _PredictiveModelGeneralInformationView = require("./PredictiveModelGeneralInformationView");
var _PredictiveModelModelMathView = require("./PredictiveModelModelMathView");
var _PredictiveModelScopeView = require("./PredictiveModelScopeView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The PredictiveModel View  module.
 * @module model/PredictiveModel
 * @version 1.0.0
 */
var PredictiveModelView = exports.PredictiveModelView = /*#__PURE__*/function (_ModelView) {
  function PredictiveModelView(metadata, img, state, modelScript, visScript, readme) {
    var _this;
    _classCallCheck(this, PredictiveModelView);
    _this = _callSuper(this, PredictiveModelView, [metadata, img, modelScript, visScript, readme]);
    _this._schema = schemas.genericModel;
    if (state) {
      _this.panels = _this._createPanels();
    }
    _this._menu = [{
      "label": "General Information",
      "id": "generalInformation",
      "submenus": [{
        "label": "General Information",
        "id": "generalInformation"
      }, {
        "label": "Model Category",
        "id": "modelCategory"
      }, {
        "label": "Reference",
        "id": "reference"
      }, {
        "label": "Author",
        "id": "author"
      }, {
        "label": "Creator",
        "id": "creator"
      }]
    }, {
      "label": "Scope",
      "id": "scope",
      "submenus": [{
        "label": "Scope",
        "id": "scope"
      }, {
        "label": "Hazard",
        "id": "hazard"
      }, {
        "label": "Product",
        "id": "product"
      }]
    }, {
      "label": "Model Math",
      "id": "modelMath",
      "submenus": [{
        "label": "Model Math",
        "id": "modelMath"
      }, {
        "label": "Quality Measures",
        "id": "qualityMeasures"
      }, {
        "label": "Parameter",
        "id": "parameter",
        "submenus": [{
          "label": "Parameter",
          "id": "parameter"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }, {
        "label": "Model Equation",
        "id": "modelEquation",
        "submenus": [{
          "label": "Model Equation",
          "id": "modelEquation"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }]
    }, {
      "label": "Data Background",
      "id": "dataBackground",
      "submenus": [{
        "label": "Study Sample",
        "id": "studySample"
      }, {
        "label": "Assay",
        "id": "assay"
      }, {
        "label": "Laboratory",
        "id": "laboratory"
      }, {
        "label": "Study",
        "id": "study"
      }]
    }];
    _this._panels = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
      study: {
        type: 'simple',
        schema: _this.jsonSchema.dataBackgroundstudy,
        metadata: _this._metadata.study
      },
      laboratory: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundlaboratory,
        metadata: _this._metadata.laboratory
      },
      assay: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundassay,
        metadata: _this._metadata.assay
      },
      studySample: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundstudySample,
        metadata: _this._metadata.studySample
      },
      modelMath: {
        type: 'simple',
        schema: _this.jsonSchema.modelMathmodelMath,
        metadata: _this._metadata.modelMath
      },
      modelEquation: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationmodelEquation,
        metadata: _this._metadata.modelEquation
      },
      reference: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationreference,
        metadata: _this._metadata.reference
      },
      parameter: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.parameterparameter,
        metadata: _this._metadata.parameter
      }
    }, "reference", {
      type: 'simple',
      schema: _this.jsonSchema.modelMath.parameterreference,
      metadata: _this._metadata.reference
    }), "qualityMeasures", {
      type: 'complex',
      schema: _this.jsonSchema.modelMathqualityMeasures,
      metadata: _this._metadata.qualityMeasures
    }), "scope", {
      type: 'simple',
      schema: _this.jsonSchema.scopescope,
      metadata: _this._metadata.scope
    }), "product", {
      type: 'complex',
      schema: _this.jsonSchema.scopeproduct,
      metadata: _this._metadata.product
    }), "hazard", {
      type: 'complex',
      schema: _this.jsonSchema.scopehazard,
      metadata: _this._metadata.hazard
    }), "generalInformation", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationgeneralInformation,
      metadata: _this._metadata.generalInformation
    }), "creator", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationcreator,
      metadata: _this._metadata.creator
    }), "author", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationauthor,
      metadata: _this._metadata.author
    }), "reference", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationreference,
      metadata: _this._metadata.reference
    }), "modelCategory", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationmodelCategory,
      metadata: _this._metadata.modelCategory
    });
    return _this;
  }
  _inherits(PredictiveModelView, _ModelView);
  return _createClass(PredictiveModelView, [{
    key: "metaData",
    get: function get() {
      try {
        this._metadata.dataBackground.study = this.panels.study.data;
        this._metadata.dataBackground.laboratory = this.panels.laboratory.data;
        this._metadata.dataBackground.assay = this.panels.assay.data;
        this._metadata.dataBackground.studySample = this.panels.studySample.data;
        this._metadata.modelMath = this.panels.modelMath.data;
        this._metadata.modelMath.modelEquation = this.panels.modelEquation.data;
        this._metadata.modelMath.modelEquation.reference = this.panels.reference.data;
        this._metadata.modelMath.parameter = this.panels.parameter.data;
        this._metadata.modelMath.parameter.reference = this.panels.reference.data;
        this._metadata.modelMath.qualityMeasures = this.panels.qualityMeasures.data;
        this._metadata.scope = this.panels.scope.data;
        this._metadata.scope.product = this.panels.product.data;
        this._metadata.scope.hazard = this.panels.hazard.data;
        this._metadata.generalInformation = this.panels.generalInformation.data;
        this._metadata.generalInformation.creator = this.panels.creator.data;
        this._metadata.generalInformation.author = this.panels.author.data;
        this._metadata.generalInformation.reference = this.panels.reference.data;
        this._metadata.generalInformation.modelCategory = this.panels.modelCategory.data;
        this._metadata.modelType = "PredictiveModel";
        this._metadata = metadataFix(this._metadata);
      } catch (error) {
        console.log(error);
      }
      return this._metadata;
    }
  }, {
    key: "jsonSchema",
    get: function get() {
      return {
        "dataBackground": {
          "study": [{
            "id": "identifier",
            "label": "Study identifier",
            "type": "text",
            "description": "A user defined identifier for the study"
          }, {
            "id": "protocolComponentsName",
            "label": "Components names",
            "type": "text",
            "description": "The names of the components used when carrying out this protocol"
          }, {
            "id": "designType",
            "label": "Design type",
            "type": "text",
            "description": "The type of study design being employed"
          }, {
            "id": "assayMeasurementType",
            "label": "Assay measurement type",
            "type": "text",
            "description": "The measurement being observed in this assay"
          }, {
            "id": "protocolComponentsType",
            "label": "Protocol components type",
            "type": "text",
            "description": "Description"
          }, {
            "id": "description",
            "label": "Study description",
            "type": "long-text",
            "description": "A brief description of the study aims"
          }, {
            "id": "assayTechnologyPlatform",
            "label": "Assay technology platform",
            "type": "text",
            "description": "The technology platform used"
          }, {
            "id": "assayTechnologyType",
            "label": "Assay technology type",
            "type": "text",
            "description": "The technology being employed to observe this measurement"
          }, {
            "id": "protocolType",
            "label": "Protocol type",
            "type": "text",
            "description": "The type of the protocol, preferably coming from an Ontology, e.g. Extraction Protocol"
          }, {
            "id": "title",
            "label": "Study title",
            "type": "long-text",
            "description": "A title for the study"
          }, {
            "id": "protocolDescription",
            "label": "Protocol description",
            "type": "long-text",
            "description": "A description of the protocol"
          }, {
            "id": "protocolParametersName",
            "label": "Parameters names",
            "type": "text",
            "description": "The parameters used when executing this protocol"
          }, {
            "id": "protocolName",
            "label": "Protocol name",
            "type": "text",
            "description": "The name of the protocol, e.g.Extraction Protocol"
          }, {
            "id": "protocolVersion",
            "label": "Protocol version",
            "type": "text",
            "description": "The version of the protocol used, where applicable."
          }, {
            "id": "protocolURI",
            "label": "Protocol URI",
            "type": "text",
            "description": "A URI to link out to a publication, web page, etc. describing the protocol"
          }, {
            "id": "accreditationProcedureForTheAssayTechnology",
            "label": "Accreditation procedure for assay",
            "type": "text",
            "description": "Accreditation procedure for the analytical method used"
          }],
          "laboratory": [{
            "id": "country",
            "label": "Laboratory country",
            "type": "text",
            "description": "Country where the laboratory is placed. (ISO 3166-1-alpha-2)"
          }, {
            "id": "name",
            "label": "Laboratory name",
            "type": "text",
            "description": "Laboratory code (National laboratory code if available) or Laboratory name "
          }, {
            "id": "accreditation",
            "label": "Laboratory accreditation",
            "description": "The laboratory accreditation to ISO/IEC 17025"
          }],
          "assay": [{
            "id": "contaminationRange",
            "label": "Range of contamination",
            "type": "text",
            "description": "Range of result of the analytical measure reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "uncertaintyValue",
            "label": "Uncertainty value",
            "type": "text",
            "description": "Indicate the expanded uncertainty (usually 95% confidence interval) value associated with the measurement expressed in the unit reported in the field Hazard unit"
          }, {
            "id": "fatPercentage",
            "label": "Percentage of fat",
            "type": "text",
            "description": "Percentage of fat in the original sample"
          }, {
            "id": "name",
            "label": "Assay name",
            "type": "text",
            "description": "A name given to the assay"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the assay. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "moisturePercentage",
            "label": "Percentage of moisture",
            "type": "text",
            "description": "Percentage of moisture in the original sample"
          }, {
            "id": "leftCensoredData",
            "label": "Left-censored data",
            "type": "text",
            "description": "Percentage of measures equal to LOQ and/or LOD"
          }, {
            "id": "detectionLimit",
            "label": "Limit of detection",
            "type": "text",
            "description": "Limit of detection reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "quantificationLimit",
            "label": "Limit of quantification",
            "type": "text",
            "description": "Limit of quantification reported in the unit specified by the variable Hazard unit"
          }],
          "studySample": [{
            "id": "sampleName",
            "label": "Name",
            "type": "text",
            "description": "An unambiguous ID given to the samples used in the assay"
          }, {
            "id": "samplingWeight",
            "label": "Sampling weight",
            "type": "text",
            "description": "Description of the method employed to compute sampling weight (nonresponse-adjusted weight)"
          }, {
            "id": "protocolOfSampleCollection",
            "label": "Protocol of sample collection",
            "type": "text",
            "description": "Additional protocol for sample and sample collection. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "samplingStrategy",
            "label": "Sampling strategy",
            "type": "text",
            "description": "Sampling strategy (ref. EUROSTAT - Typology of sampling strategy, version of July 2009)"
          }, {
            "id": "samplingSize",
            "label": "Sampling size",
            "type": "text",
            "description": "Number of units, full participants, partial participants, eligibles, not eligible, unresolved (eligibility status not resolved)"
          }, {
            "id": "lotSizeUnit",
            "label": "Lot size unit",
            "type": "text",
            "description": "Unit in which the lot size is expressed"
          }, {
            "id": "samplingPoint",
            "label": "Sampling point",
            "type": "text",
            "description": "Point in the food chain where the sample was taken. (Doc. ESTAT/F5/ES/155 Data dictionary of activities of the establishments)"
          }, {
            "id": "samplingMethod",
            "label": "Sampling method",
            "type": "text",
            "description": "Sampling method used to take the sample"
          }, {
            "id": "typeOfSamplingProgram",
            "label": "Type of sampling program",
            "type": "text",
            "description": "Indicate the type of programm for which the samples have been collected"
          }, {
            "id": "samplingPlan",
            "label": "Sampling plan",
            "type": "text",
            "description": "Description of data collection technique: stratified or complex sampling (several stages)"
          }]
        },
        "modelMath": {
          "modelEquation": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "modelEquation": [{
              "id": "modelEquation",
              "label": "Equation",
              "type": "text",
              "description": "The pointer to the file that holds the software code (e.g. R-script)"
            }, {
              "id": "name",
              "label": "Model equation name",
              "type": "text",
              "description": "A name given to the model equation"
            }, {
              "id": "modelHypothesis",
              "label": "Hypothesis of the model",
              "description": "Description of the hypothesis of the model"
            }, {
              "id": "modelEquationClass",
              "label": "Model equation class",
              "type": "text",
              "description": "Information on that helps to categorize model equations"
            }]
          },
          "parameter": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "parameter": [{
              "id": "subject",
              "label": "Parameter subject",
              "type": "text",
              "description": "Scope of the parameter, e.g. if it refers to an animal, a batch of animals, a batch of products, a carcass, a carcass skin etc"
            }, {
              "id": "maxValue",
              "label": "Value max",
              "type": "text",
              "description": "Numerical value of the maximum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "dataType",
              "label": "Data type",
              "type": "text",
              "description": "Information on the data format of the parameter, e.g. if it is a categorical variable: int, double, array of size x,y,z "
            }, {
              "id": "description",
              "label": "Description",
              "type": "text",
              "description": "General description of the parameter"
            }, {
              "id": "source",
              "label": "Parameter source",
              "type": "text",
              "description": "Information on the type of knowledge used to define the parameter value"
            }, {
              "id": "classification",
              "label": "Parameter classification",
              "type": "text",
              "description": "General classification of the parameter (e.g. Input, Constant, Output etc)"
            }, {
              "id": "distribution",
              "label": "Parameter distribution",
              "type": "text",
              "description": "Distribution describing the parameter variabilty. If no distribution selected this means the value provided in 'Parameter value' is a point estimate. In case a distribution is selected the value provided in 'Parameter value' is a string that the model code can parse in order to sample from the named distribution"
            }, {
              "id": "error",
              "label": "Error",
              "type": "text",
              "description": "Error of the parameter value"
            }, {
              "id": "variabilitySubject",
              "label": "Parameter variability subject",
              "type": "text",
              "description": "Information on which the variability is described. It can be variability between broiler in a flock, variability between all meat packages sold in Denmark, variability between days, etc."
            }, {
              "id": "unit",
              "label": "Unit",
              "type": "text",
              "description": "Unit of the parameter"
            }, {
              "id": "minValue",
              "label": "Value min",
              "type": "text",
              "description": "Numerical value of the minimum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "unitCategory",
              "label": "Unit category",
              "type": "text",
              "description": "General classification of the parameter unit"
            }, {
              "id": "name",
              "label": "Parameter name",
              "type": "text",
              "description": "A name given to the parameter"
            }, {
              "id": "id",
              "label": "Parameter ID",
              "type": "text",
              "description": "An unambiguous ID given to each of the parameters - preferably autogenerated by a software tool and compatible with SBML ID requirements, only letters from A to Z, numbers and '_'"
            }, {
              "id": "value",
              "label": "Value",
              "type": "text",
              "description": "A default value for the parameter. This is mandatory (needs to be provided) for all parameters of type 'Input'"
            }]
          },
          "qualityMeasures": [{
            "id": "rsquared",
            "label": "R squared",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sse",
            "label": "SSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "rmse",
            "label": "RMSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "aic",
            "label": "AIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sensitivityAnalysis",
            "label": "Sensitivity analysis",
            "type": "long-text",
            "description": "Description of the results of an sensitivity analysis, i.e. how independence assumptions are met or how variables will affect the output of model"
          }, {
            "id": "bic",
            "label": "BIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "mse",
            "label": "MSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }],
          "modelMath": [{
            "id": "fittingProcedure",
            "label": "Fitting procedure",
            "type": "text",
            "description": "Procedure used to fit the data to the model equation"
          }, {
            "id": "event",
            "label": "Event",
            "description": "Definition of time-dependent parameter changes"
          }]
        },
        "scope": {
          "product": [{
            "id": "expiryDate",
            "label": "Expiration date",
            "type": "date",
            "description": "Expiry date of food/product"
          }, {
            "id": "treatment",
            "label": "Treatment",
            "description": "Used to characterise a product/matrix based on the treatment or processes applied to the product or any indexed ingredient"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the product, matrix or environment for which the model or data applies"
          }, {
            "id": "productionDate",
            "label": "Production date",
            "type": "date",
            "description": "Date of production of food/product"
          }, {
            "id": "method",
            "label": "Method of production",
            "description": "Type of production for the product/ matrix"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "The product, matrix or environment (e.g food product, lab media, soil etc.) for which the model or data applies"
          }, {
            "id": "originCountry",
            "label": "Country of origin",
            "type": "text",
            "description": "Country of origin of the food/product (ISO 3166-1-alpha-2 country code)"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Detailed description of the product, matrix or environment for which the model or data applies"
          }, {
            "id": "packaging",
            "label": "Packaging",
            "description": "Describe container or wrapper that holds the product/matrix. Common type of packaging (paper or plastic bags, boxes, tinplate or aluminium cans, plastic trays, plastic bottles, glass bottles or jars)"
          }, {
            "id": "fisheriesArea",
            "label": "Fisheries area",
            "type": "text",
            "description": "Fisheries or aquaculture area specifying the origin of the sample (FAO Fisheries areas)."
          }, {
            "id": "originArea",
            "label": "Area of origin",
            "type": "text",
            "description": "Area of origin of the food/product (Nomenclature of territorial units for statistics  NUTS  coding system valid only for EEA and Switzerland)."
          }],
          "hazard": [{
            "id": "maximumResidueLimit",
            "label": "Maximum Residue Limit (MRL)",
            "type": "text",
            "description": "International regulations and permissible maximum residue levels in food and drinking water"
          }, {
            "id": "sourceOfContamination",
            "label": "Source of contamination",
            "type": "text",
            "description": "rigin of the contamination, source"
          }, {
            "id": "indSum",
            "label": "Individual or Summed Hazard",
            "type": "text",
            "description": "Define if the parameter reported is an individual residue/analyte, a summed residue definition or part of a sum a summed residue definition"
          }, {
            "id": "acceptableOperatorsExposureLevel",
            "label": "Acceptable Operator Exposure Level (AOEL)",
            "type": "text",
            "description": "Maximum amount of active substance to which the operator may be exposed without any adverse health effects. The AOEL is expressed as milligrams of the chemical per kilogram body weight of the operator"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Description of the hazard for which the model or data applies"
          }, {
            "id": "type",
            "label": "Hazard type",
            "type": "text",
            "description": "General classification of the hazard for which the model or data applies"
          }, {
            "id": "adverseEffect",
            "label": "Adverse effect",
            "type": "text",
            "description": "Adverse effect induced by hazard about morbidity, mortality, and etcetera"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the hazard for which the model or data applies"
          }, {
            "id": "noObservedAdverseAffectLevel",
            "label": "No Observed Adverse Affect Level (NOAEL)",
            "type": "text",
            "description": "Level of exposure of an organism, found by experiment or observation, at which there is no biologically or statistically significant increase in the frequency or severity of any adverse effects in the exposed population when compared to its appropriate control"
          }, {
            "id": "acuteReferenceDose",
            "label": "Acute Reference Dose (ARfD)",
            "type": "text",
            "description": "An estimate (with uncertainty spanning perhaps an order of magnitude) of a daily oral exposure for an acute duration (24 hours or less) to the human population (including sensitive subgroups) that is likely to be without an appreciable risk of deleterious effects during a lifetime"
          }, {
            "id": "name",
            "label": "Hazard name",
            "type": "text",
            "description": "Name of the hazard (agent, contaminant, chemical) for which the data or model applies"
          }, {
            "id": "lowestObservedAdverseAffectLevel",
            "label": "Lowest Observed Adverse Effect Level (LOAEL)",
            "type": "text",
            "description": "Lowest concentration or amount of a substance found by experiment or observation that causes an adverse alteration of morphology, function, capacity, growth, development, or lifespan of a target organism distinguished from normal organisms of the same species under defined conditions of exposure"
          }, {
            "id": "benchmarkDose",
            "label": "Benchmark Dose (BMD)",
            "type": "text",
            "description": "A dose or concentration that produces a predetermined change in response rate of an adverse effect (called the benchmark response or BMR) compared to background"
          }, {
            "id": "acceptableDailyIntake",
            "label": "Acceptable Daily Intake (ADI)",
            "type": "text",
            "description": "Measure of amount of a specific substance in food or in drinking water tahta can be ingested (orally) on a daily basis over a lifetime without an appreciable health risk"
          }],
          "scope": [{
            "id": "spatialInformation",
            "label": "Spatial information",
            "description": "Spatial information (area) on which the model or data applies"
          }, {
            "id": "generalComment",
            "label": "General comment",
            "type": "long-text",
            "description": "General comments on the scope of the study, data or model"
          }, {
            "id": "temporalInformation",
            "label": "Temporal information",
            "type": "long-text",
            "description": "Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)"
          }]
        },
        "generalInformation": {
          "creator": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "author": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "reference": [{
            "id": "date",
            "label": "Date",
            "type": "year_date",
            "description": "Temporal information on the publication date"
          }, {
            "id": "website",
            "label": "Website",
            "type": "text",
            "description": "A link to the publication website (different from DOI)"
          }, {
            "id": "issue",
            "label": "Issue",
            "type": "text",
            "description": "Data on the details of the issue in which the model or date has been described"
          }, {
            "id": "publicationType",
            "label": "Publication type",
            "type": "text",
            "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
          }, {
            "id": "abstract",
            "label": "Abstract",
            "type": "text",
            "description": "Abstract of the publication in which the model or the data has been described "
          }, {
            "id": "isReferenceDescription",
            "label": "Is_reference_description?",
            "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
          }, {
            "id": "title",
            "label": "Title",
            "type": "long-text",
            "description": "Title of publication in which the model or date has been described"
          }, {
            "id": "pmid",
            "label": "PubMed ID",
            "type": "text",
            "description": "The PubMed ID related to this publication"
          }, {
            "id": "volume",
            "label": "Volume",
            "type": "text",
            "description": "Data on the details of the volume in which the model or date has been described"
          }, {
            "id": "journal",
            "label": "Journal",
            "type": "long-text",
            "description": "Data on the details of the journal in which the model or date has been described"
          }, {
            "id": "authorList",
            "label": "Author list",
            "type": "long-text",
            "description": "Name and surname of the authors who contributed to this publication"
          }, {
            "id": "comment",
            "label": "Comment",
            "type": "long-text",
            "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
          }, {
            "id": "doi",
            "label": "Publication DOI",
            "type": "long-text",
            "description": "The DOI related to this publication"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The status of this publication, e.g. Published, Submitted, etc."
          }],
          "modelCategory": [{
            "id": "modelClassComment",
            "label": "Comment",
            "type": "long-text",
            "description": "Comment with further details on the model class"
          }, {
            "id": "basicProcess",
            "label": "Basic process",
            "description": "Defines the impact of the process on the hazard (so far only valid for process models and predictive models)"
          }, {
            "id": "modelClass",
            "label": "Model class",
            "type": "text",
            "description": "Type of model according to RAKIP classification"
          }, {
            "id": "modelSubClass",
            "label": "Subclass",
            "description": "Sub-classification of the model given the Model Class"
          }],
          "generalInformation": [{
            "id": "identifier",
            "label": "Identifier",
            "type": "text",
            "description": "An unambiguous ID given to the model or data. This can also be created automatically by a software tool"
          }, {
            "id": "software",
            "label": "Software",
            "type": "text",
            "description": "The program or software language in which the model has been implemented"
          }, {
            "id": "format",
            "label": "Format",
            "type": "text",
            "description": "File extension of the model or data file (including version number of format if applicable)"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the study, data or model"
          }, {
            "id": "language",
            "label": "Language",
            "type": "text",
            "description": "A language of the resource (some data or reports can be available in French language for example)"
          }, {
            "id": "source",
            "label": "Source",
            "type": "text",
            "description": "A source from which the model/data is derived"
          }, {
            "id": "availability",
            "label": "Availability",
            "type": "text",
            "description": "Availability of data or model, i.e. if the annotated model code / data is included in this FSK file"
          }, {
            "id": "creationDate",
            "label": "Creation date",
            "type": "date",
            "description": "Creation date/time of the FSK file"
          }, {
            "id": "url",
            "label": "URL",
            "type": "text",
            "description": "Web address referencing the resource location (data for example)"
          }, {
            "id": "objective",
            "label": "Objective",
            "type": "long-text",
            "description": "Objective of the model or data"
          }, {
            "id": "modificationDate",
            "label": "Modification date",
            "description": "Date/time of the last version of the FSK file"
          }, {
            "id": "rights",
            "label": "Rights",
            "type": "text",
            "description": "Rights granted for usage, distribution and modification of this FSK file"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "A name given to the model or data"
          }, {
            "id": "languageWrittenIn",
            "label": "Language written in",
            "type": "text",
            "description": "Software language used to write the model, e.g. R or MatLab"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The curation status of the model"
          }]
        }
      };
    }
    // Validate this.panels and return boolean
  }, {
    key: "validate",
    value: function validate() {
      var isValid = true;
      if (!this.panels.generalInformation.validate()) isValid = false;
      if (!this.panels.modelCategory.validate()) isValid = false;
      if (!this.panels.scopeGeneral.validate()) isValid = false;
      if (!this.panels.study.validate()) isValid = false;
      return isValid;
    }
  }, {
    key: "_createPanels",
    value: function _createPanels() {
      var port = window.port || -1;
      var schema = schemas.genericModel;
      return _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
        study: new _FormPanel.FormPanel("Study", this.jsonSchema.dataBackground.study, this._metadata.dataBackground ? this._metadata.dataBackground.study : {}, port),
        laboratory: new _TablePanel.TablePanel("Laboratory", this.jsonSchema.dataBackground.laboratory, this._metadata.dataBackground ? this._metadata.dataBackground.laboratory : {}, port),
        assay: new _TablePanel.TablePanel("Assay", this.jsonSchema.dataBackground.assay, this._metadata.dataBackground ? this._metadata.dataBackground.assay : {}, port),
        studySample: new _TablePanel.TablePanel("Study Sample", this.jsonSchema.dataBackground.studySample, this._metadata.dataBackground ? this._metadata.dataBackground.studySample : {}, port),
        modelMath: new _FormPanel.FormPanel("Model Math", this.jsonSchema.modelMath.modelMath, this._metadata.modelMath, port),
        modelEquation: new _TablePanel.TablePanel("Model Equation", this.jsonSchema.modelMath.modelEquation.modelEquation, this._metadata.modelMath ? this._metadata.modelMath.modelEquation : {}, port),
        reference: new _TablePanel.TablePanel("Reference", this.jsonSchema.modelMath.modelEquation.reference, this._metadata.modelMath.modelEquation ? this._metadata.modelMath.modelEquation.reference : {}, port),
        parameter: new _TablePanel.TablePanel("Parameter", this.jsonSchema.modelMath.parameter.parameter, this._metadata.modelMath ? this._metadata.modelMath.parameter : {}, port)
      }, "reference", new _FormPanel.FormPanel("Reference", this.jsonSchema.modelMath.parameter.reference, this._metadata.modelMath.parameter ? this._metadata.modelMath.parameter.reference : {}, port)), "qualityMeasures", new _TablePanel.TablePanel("Quality Measures", this.jsonSchema.modelMath.qualityMeasures, this._metadata.modelMath ? this._metadata.modelMath.qualityMeasures : {}, port)), "scope", new _FormPanel.FormPanel("Scope", this.jsonSchema.scope.scope, this._metadata.scope, port)), "product", new _TablePanel.TablePanel("Product", this.jsonSchema.scope.product, this._metadata.scope ? this._metadata.scope.product : {}, port)), "hazard", new _TablePanel.TablePanel("Hazard", this.jsonSchema.scope.hazard, this._metadata.scope ? this._metadata.scope.hazard : {}, port)), "generalInformation", new _FormPanel.FormPanel("General Information", this.jsonSchema.generalInformation.generalInformation, this._metadata.generalInformation, port)), "creator", new _TablePanel.TablePanel("Creator", this.jsonSchema.generalInformation.creator, this._metadata.generalInformation ? this._metadata.generalInformation.creator : {}, port)), "author", new _TablePanel.TablePanel("Author", this.jsonSchema.generalInformation.author, this._metadata.generalInformation ? this._metadata.generalInformation.author : {}, port)), "reference", new _TablePanel.TablePanel("Reference", this.jsonSchema.generalInformation.reference, this._metadata.generalInformation ? this._metadata.generalInformation.reference : {}, port)), "modelCategory", new _FormPanel.FormPanel("Model Category", this.jsonSchema.generalInformation.modelCategory, this._metadata.generalInformation ? this._metadata.generalInformation.modelCategory : {}, port));
    }
  }]);
}(_ModelView2.ModelView);

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./ModelView":118,"./PredictiveModelDataBackgroundView":135,"./PredictiveModelGeneralInformationView":137,"./PredictiveModelModelMathView":139,"./PredictiveModelScopeView":143}],145:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProcessModel = void 0;
var _ApiClient = require("../ApiClient");
var _Model2 = require("./Model");
var _PredictiveModelDataBackground = require("./PredictiveModelDataBackground");
var _PredictiveModelGeneralInformation = require("./PredictiveModelGeneralInformation");
var _PredictiveModelModelMath = require("./PredictiveModelModelMath");
var _ProcessModelScope = require("./ProcessModelScope");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ProcessModel model module.
 * @module model/ProcessModel
 * @version 1.0.0
 */
var ProcessModel = exports.ProcessModel = /*#__PURE__*/function (_Model) {
  /**
   * Constructs a new <code>ProcessModel</code>.
   * @alias module:model/ProcessModel
   * @class
   * @extends module:model/Model
   * @param modelMath {} 
   * @param scope {} 
   * @param generalInformation {} 
   * @param modelType {} 
   */
  function ProcessModel(modelMathscopegeneralInformationmodelType) {
    var _this;
    _classCallCheck(this, ProcessModel);
    _this = _callSuper(this, ProcessModel, [modelType]);
    _this.modelMath = modelMath;
    _this.scope = scope;
    _this.generalInformation = generalInformation;
    return _this;
  }

  /**
   * Constructs a <code>ProcessModel</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/ProcessModel} obj Optional instance to populate.
   * @return {module:model/ProcessModel} The populated <code>ProcessModel</code> instance.
   */
  _inherits(ProcessModel, _Model);
  return _createClass(ProcessModel, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new ProcessModel();
        _Model2.Model.constructFromObject(data, obj);
        if (data.hasOwnProperty('dataBackground')) obj.dataBackground = _PredictiveModelDataBackground.PredictiveModelDataBackground.constructFromObject(data['dataBackground']);
        if (data.hasOwnProperty('modelMath')) obj.modelMath = _PredictiveModelModelMath.PredictiveModelModelMath.constructFromObject(data['modelMath']);
        if (data.hasOwnProperty('scope')) obj.scope = _ProcessModelScope.ProcessModelScope.constructFromObject(data['scope']);
        if (data.hasOwnProperty('generalInformation')) obj.generalInformation = _PredictiveModelGeneralInformation.PredictiveModelGeneralInformation.constructFromObject(data['generalInformation']);
      }
      return obj;
    }
  }]);
}(_Model2.Model);
/**
 * @member {module:model/PredictiveModelDataBackground} dataBackground
 */
ProcessModel.prototype.dataBackground = undefined;

/**
 * @member {module:model/PredictiveModelModelMath} modelMath
 */
ProcessModel.prototype.modelMath = undefined;

/**
 * @member {module:model/ProcessModelScope} scope
 */
ProcessModel.prototype.scope = undefined;

/**
 * @member {module:model/PredictiveModelGeneralInformation} generalInformation
 */
ProcessModel.prototype.generalInformation = undefined;

},{"../ApiClient":44,"./Model":113,"./PredictiveModelDataBackground":134,"./PredictiveModelGeneralInformation":136,"./PredictiveModelModelMath":138,"./ProcessModelScope":146}],146:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProcessModelScope = void 0;
var _ApiClient = require("../ApiClient");
var _Hazard = require("./Hazard");
var _Product = require("./Product");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ProcessModelScope model module.
 * @module model/ProcessModelScope
 * @version 1.0.0
 */
var ProcessModelScope = exports.ProcessModelScope = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>ProcessModelScope</code>.
   * @alias module:model/ProcessModelScope
   * @class
   */
  function ProcessModelScope() {
    _classCallCheck(this, ProcessModelScope);
  }

  /**
   * Constructs a <code>ProcessModelScope</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/ProcessModelScope} obj Optional instance to populate.
   * @return {module:model/ProcessModelScope} The populated <code>ProcessModelScope</code> instance.
   */
  return _createClass(ProcessModelScope, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new ProcessModelScope();
        if (data.hasOwnProperty('spatialInformation')) obj.spatialInformation = _ApiClient.ApiClient.convertToType(data['spatialInformation'], ['String']);
        if (data.hasOwnProperty('product')) obj.product = _ApiClient.ApiClient.convertToType(data['product'], [_Product.Product]);
        if (data.hasOwnProperty('hazard')) obj.hazard = _ApiClient.ApiClient.convertToType(data['hazard'], [_Hazard.Hazard]);
        if (data.hasOwnProperty('generalComment')) obj.generalComment = _ApiClient.ApiClient.convertToType(data['generalComment'], 'String');
        if (data.hasOwnProperty('temporalInformation')) obj.temporalInformation = _ApiClient.ApiClient.convertToType(data['temporalInformation'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * Spatial information (area) on which the model or data applies
 * @member {Array.<String>} spatialInformation
 */
ProcessModelScope.prototype.spatialInformation = undefined;

/**
 * @member {Array.<module:model/Product>} product
 */
ProcessModelScope.prototype.product = undefined;

/**
 * @member {Array.<module:model/Hazard>} hazard
 */
ProcessModelScope.prototype.hazard = undefined;

/**
 * General comments on the scope of the study, data or model
 * @member {String} generalComment
 */
ProcessModelScope.prototype.generalComment = undefined;

/**
 * Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)
 * @member {String} temporalInformation
 */
ProcessModelScope.prototype.temporalInformation = undefined;

},{"../ApiClient":44,"./Hazard":105,"./Product":149}],147:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProcessModelScopeView = void 0;
var _ApiClient = require("../ApiClient");
var _HazardView = require("./HazardView");
var _ProductView = require("./ProductView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ProcessModelScope View  module.
 * @module model/ProcessModelScope
 * @version 1.0.0
 */
var ProcessModelScopeView = exports.ProcessModelScopeView = /*#__PURE__*/_createClass(function ProcessModelScopeView() {
  _classCallCheck(this, ProcessModelScopeView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./HazardView":106,"./ProductView":150}],148:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProcessModelView = void 0;
var _ApiClient = require("../ApiClient");
var _ModelView2 = require("./ModelView");
var _PredictiveModelDataBackgroundView = require("./PredictiveModelDataBackgroundView");
var _PredictiveModelGeneralInformationView = require("./PredictiveModelGeneralInformationView");
var _PredictiveModelModelMathView = require("./PredictiveModelModelMathView");
var _ProcessModelScopeView = require("./ProcessModelScopeView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ProcessModel View  module.
 * @module model/ProcessModel
 * @version 1.0.0
 */
var ProcessModelView = exports.ProcessModelView = /*#__PURE__*/function (_ModelView) {
  function ProcessModelView(metadata, img, state, modelScript, visScript, readme) {
    var _this;
    _classCallCheck(this, ProcessModelView);
    _this = _callSuper(this, ProcessModelView, [metadata, img, modelScript, visScript, readme]);
    _this._schema = schemas.genericModel;
    if (state) {
      _this.panels = _this._createPanels();
    }
    _this._menu = [{
      "label": "General Information",
      "id": "generalInformation",
      "submenus": [{
        "label": "General Information",
        "id": "generalInformation"
      }, {
        "label": "Model Category",
        "id": "modelCategory"
      }, {
        "label": "Reference",
        "id": "reference"
      }, {
        "label": "Author",
        "id": "author"
      }, {
        "label": "Creator",
        "id": "creator"
      }]
    }, {
      "label": "Scope",
      "id": "scope",
      "submenus": [{
        "label": "Scope",
        "id": "scope"
      }, {
        "label": "Hazard",
        "id": "hazard"
      }, {
        "label": "Product",
        "id": "product"
      }]
    }, {
      "label": "Model Math",
      "id": "modelMath",
      "submenus": [{
        "label": "Model Math",
        "id": "modelMath"
      }, {
        "label": "Quality Measures",
        "id": "qualityMeasures"
      }, {
        "label": "Parameter",
        "id": "parameter",
        "submenus": [{
          "label": "Parameter",
          "id": "parameter"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }, {
        "label": "Model Equation",
        "id": "modelEquation",
        "submenus": [{
          "label": "Model Equation",
          "id": "modelEquation"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }]
    }, {
      "label": "Data Background",
      "id": "dataBackground",
      "submenus": [{
        "label": "Study Sample",
        "id": "studySample"
      }, {
        "label": "Assay",
        "id": "assay"
      }, {
        "label": "Laboratory",
        "id": "laboratory"
      }, {
        "label": "Study",
        "id": "study"
      }]
    }];
    _this._panels = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
      study: {
        type: 'simple',
        schema: _this.jsonSchema.dataBackgroundstudy,
        metadata: _this._metadata.study
      },
      laboratory: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundlaboratory,
        metadata: _this._metadata.laboratory
      },
      assay: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundassay,
        metadata: _this._metadata.assay
      },
      studySample: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundstudySample,
        metadata: _this._metadata.studySample
      },
      modelMath: {
        type: 'simple',
        schema: _this.jsonSchema.modelMathmodelMath,
        metadata: _this._metadata.modelMath
      },
      modelEquation: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationmodelEquation,
        metadata: _this._metadata.modelEquation
      },
      reference: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationreference,
        metadata: _this._metadata.reference
      },
      parameter: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.parameterparameter,
        metadata: _this._metadata.parameter
      }
    }, "reference", {
      type: 'simple',
      schema: _this.jsonSchema.modelMath.parameterreference,
      metadata: _this._metadata.reference
    }), "qualityMeasures", {
      type: 'complex',
      schema: _this.jsonSchema.modelMathqualityMeasures,
      metadata: _this._metadata.qualityMeasures
    }), "scope", {
      type: 'simple',
      schema: _this.jsonSchema.scopescope,
      metadata: _this._metadata.scope
    }), "product", {
      type: 'complex',
      schema: _this.jsonSchema.scopeproduct,
      metadata: _this._metadata.product
    }), "hazard", {
      type: 'complex',
      schema: _this.jsonSchema.scopehazard,
      metadata: _this._metadata.hazard
    }), "generalInformation", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationgeneralInformation,
      metadata: _this._metadata.generalInformation
    }), "creator", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationcreator,
      metadata: _this._metadata.creator
    }), "author", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationauthor,
      metadata: _this._metadata.author
    }), "reference", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationreference,
      metadata: _this._metadata.reference
    }), "modelCategory", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationmodelCategory,
      metadata: _this._metadata.modelCategory
    });
    return _this;
  }
  _inherits(ProcessModelView, _ModelView);
  return _createClass(ProcessModelView, [{
    key: "metaData",
    get: function get() {
      try {
        this._metadata.dataBackground.study = this.panels.study.data;
        this._metadata.dataBackground.laboratory = this.panels.laboratory.data;
        this._metadata.dataBackground.assay = this.panels.assay.data;
        this._metadata.dataBackground.studySample = this.panels.studySample.data;
        this._metadata.modelMath = this.panels.modelMath.data;
        this._metadata.modelMath.modelEquation = this.panels.modelEquation.data;
        this._metadata.modelMath.modelEquation.reference = this.panels.reference.data;
        this._metadata.modelMath.parameter = this.panels.parameter.data;
        this._metadata.modelMath.parameter.reference = this.panels.reference.data;
        this._metadata.modelMath.qualityMeasures = this.panels.qualityMeasures.data;
        this._metadata.scope = this.panels.scope.data;
        this._metadata.scope.product = this.panels.product.data;
        this._metadata.scope.hazard = this.panels.hazard.data;
        this._metadata.generalInformation = this.panels.generalInformation.data;
        this._metadata.generalInformation.creator = this.panels.creator.data;
        this._metadata.generalInformation.author = this.panels.author.data;
        this._metadata.generalInformation.reference = this.panels.reference.data;
        this._metadata.generalInformation.modelCategory = this.panels.modelCategory.data;
        this._metadata.modelType = "ProcessModel";
        this._metadata = metadataFix(this._metadata);
      } catch (error) {
        console.log(error);
      }
      return this._metadata;
    }
  }, {
    key: "jsonSchema",
    get: function get() {
      return {
        "dataBackground": {
          "study": [{
            "id": "identifier",
            "label": "Study identifier",
            "type": "text",
            "description": "A user defined identifier for the study"
          }, {
            "id": "protocolComponentsName",
            "label": "Components names",
            "type": "text",
            "description": "The names of the components used when carrying out this protocol"
          }, {
            "id": "designType",
            "label": "Design type",
            "type": "text",
            "description": "The type of study design being employed"
          }, {
            "id": "assayMeasurementType",
            "label": "Assay measurement type",
            "type": "text",
            "description": "The measurement being observed in this assay"
          }, {
            "id": "protocolComponentsType",
            "label": "Protocol components type",
            "type": "text",
            "description": "Description"
          }, {
            "id": "description",
            "label": "Study description",
            "type": "long-text",
            "description": "A brief description of the study aims"
          }, {
            "id": "assayTechnologyPlatform",
            "label": "Assay technology platform",
            "type": "text",
            "description": "The technology platform used"
          }, {
            "id": "assayTechnologyType",
            "label": "Assay technology type",
            "type": "text",
            "description": "The technology being employed to observe this measurement"
          }, {
            "id": "protocolType",
            "label": "Protocol type",
            "type": "text",
            "description": "The type of the protocol, preferably coming from an Ontology, e.g. Extraction Protocol"
          }, {
            "id": "title",
            "label": "Study title",
            "type": "long-text",
            "description": "A title for the study"
          }, {
            "id": "protocolDescription",
            "label": "Protocol description",
            "type": "long-text",
            "description": "A description of the protocol"
          }, {
            "id": "protocolParametersName",
            "label": "Parameters names",
            "type": "text",
            "description": "The parameters used when executing this protocol"
          }, {
            "id": "protocolName",
            "label": "Protocol name",
            "type": "text",
            "description": "The name of the protocol, e.g.Extraction Protocol"
          }, {
            "id": "protocolVersion",
            "label": "Protocol version",
            "type": "text",
            "description": "The version of the protocol used, where applicable."
          }, {
            "id": "protocolURI",
            "label": "Protocol URI",
            "type": "text",
            "description": "A URI to link out to a publication, web page, etc. describing the protocol"
          }, {
            "id": "accreditationProcedureForTheAssayTechnology",
            "label": "Accreditation procedure for assay",
            "type": "text",
            "description": "Accreditation procedure for the analytical method used"
          }],
          "laboratory": [{
            "id": "country",
            "label": "Laboratory country",
            "type": "text",
            "description": "Country where the laboratory is placed. (ISO 3166-1-alpha-2)"
          }, {
            "id": "name",
            "label": "Laboratory name",
            "type": "text",
            "description": "Laboratory code (National laboratory code if available) or Laboratory name "
          }, {
            "id": "accreditation",
            "label": "Laboratory accreditation",
            "description": "The laboratory accreditation to ISO/IEC 17025"
          }],
          "assay": [{
            "id": "contaminationRange",
            "label": "Range of contamination",
            "type": "text",
            "description": "Range of result of the analytical measure reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "uncertaintyValue",
            "label": "Uncertainty value",
            "type": "text",
            "description": "Indicate the expanded uncertainty (usually 95% confidence interval) value associated with the measurement expressed in the unit reported in the field Hazard unit"
          }, {
            "id": "fatPercentage",
            "label": "Percentage of fat",
            "type": "text",
            "description": "Percentage of fat in the original sample"
          }, {
            "id": "name",
            "label": "Assay name",
            "type": "text",
            "description": "A name given to the assay"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the assay. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "moisturePercentage",
            "label": "Percentage of moisture",
            "type": "text",
            "description": "Percentage of moisture in the original sample"
          }, {
            "id": "leftCensoredData",
            "label": "Left-censored data",
            "type": "text",
            "description": "Percentage of measures equal to LOQ and/or LOD"
          }, {
            "id": "detectionLimit",
            "label": "Limit of detection",
            "type": "text",
            "description": "Limit of detection reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "quantificationLimit",
            "label": "Limit of quantification",
            "type": "text",
            "description": "Limit of quantification reported in the unit specified by the variable Hazard unit"
          }],
          "studySample": [{
            "id": "sampleName",
            "label": "Name",
            "type": "text",
            "description": "An unambiguous ID given to the samples used in the assay"
          }, {
            "id": "samplingWeight",
            "label": "Sampling weight",
            "type": "text",
            "description": "Description of the method employed to compute sampling weight (nonresponse-adjusted weight)"
          }, {
            "id": "protocolOfSampleCollection",
            "label": "Protocol of sample collection",
            "type": "text",
            "description": "Additional protocol for sample and sample collection. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "samplingStrategy",
            "label": "Sampling strategy",
            "type": "text",
            "description": "Sampling strategy (ref. EUROSTAT - Typology of sampling strategy, version of July 2009)"
          }, {
            "id": "samplingSize",
            "label": "Sampling size",
            "type": "text",
            "description": "Number of units, full participants, partial participants, eligibles, not eligible, unresolved (eligibility status not resolved)"
          }, {
            "id": "lotSizeUnit",
            "label": "Lot size unit",
            "type": "text",
            "description": "Unit in which the lot size is expressed"
          }, {
            "id": "samplingPoint",
            "label": "Sampling point",
            "type": "text",
            "description": "Point in the food chain where the sample was taken. (Doc. ESTAT/F5/ES/155 Data dictionary of activities of the establishments)"
          }, {
            "id": "samplingMethod",
            "label": "Sampling method",
            "type": "text",
            "description": "Sampling method used to take the sample"
          }, {
            "id": "typeOfSamplingProgram",
            "label": "Type of sampling program",
            "type": "text",
            "description": "Indicate the type of programm for which the samples have been collected"
          }, {
            "id": "samplingPlan",
            "label": "Sampling plan",
            "type": "text",
            "description": "Description of data collection technique: stratified or complex sampling (several stages)"
          }]
        },
        "modelMath": {
          "modelEquation": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date",
              "required": "true"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)",
              "required": "true"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described",
              "required": "true"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... ",
              "required": "true"
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described ",
              "required": "true"
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'",
              "required": "true"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described",
              "required": "true"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication",
              "required": "true"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described",
              "required": "true"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described",
              "required": "true"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication",
              "required": "true"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script",
              "required": "true"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication",
              "required": "true"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc.",
              "required": "true"
            }],
            "modelEquation": [{
              "id": "modelEquation",
              "label": "Equation",
              "type": "text",
              "description": "The pointer to the file that holds the software code (e.g. R-script)",
              "required": "true"
            }, {
              "id": "name",
              "label": "Model equation name",
              "type": "text",
              "description": "A name given to the model equation",
              "required": "true"
            }, {
              "id": "modelHypothesis",
              "label": "Hypothesis of the model",
              "description": "Description of the hypothesis of the model",
              "required": "true"
            }, {
              "id": "modelEquationClass",
              "label": "Model equation class",
              "type": "text",
              "description": "Information on that helps to categorize model equations",
              "required": "true"
            }]
          },
          "parameter": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date",
              "required": "true"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)",
              "required": "true"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described",
              "required": "true"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... ",
              "required": "true"
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described ",
              "required": "true"
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'",
              "required": "true"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described",
              "required": "true"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication",
              "required": "true"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described",
              "required": "true"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described",
              "required": "true"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication",
              "required": "true"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script",
              "required": "true"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication",
              "required": "true"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc.",
              "required": "true"
            }],
            "parameter": [{
              "id": "subject",
              "label": "Parameter subject",
              "type": "text",
              "description": "Scope of the parameter, e.g. if it refers to an animal, a batch of animals, a batch of products, a carcass, a carcass skin etc",
              "required": "true"
            }, {
              "id": "maxValue",
              "label": "Value max",
              "type": "text",
              "description": "Numerical value of the maximum limit of the parameter that determines the range of applicability for which the model applies",
              "required": "true"
            }, {
              "id": "dataType",
              "label": "Data type",
              "type": "text",
              "description": "Information on the data format of the parameter, e.g. if it is a categorical variable: int, double, array of size x,y,z ",
              "required": "true"
            }, {
              "id": "description",
              "label": "Description",
              "type": "text",
              "description": "General description of the parameter",
              "required": "true"
            }, {
              "id": "source",
              "label": "Parameter source",
              "type": "text",
              "description": "Information on the type of knowledge used to define the parameter value",
              "required": "true"
            }, {
              "id": "classification",
              "label": "Parameter classification",
              "type": "text",
              "description": "General classification of the parameter (e.g. Input, Constant, Output etc)",
              "required": "true"
            }, {
              "id": "distribution",
              "label": "Parameter distribution",
              "type": "text",
              "description": "Distribution describing the parameter variabilty. If no distribution selected this means the value provided in 'Parameter value' is a point estimate. In case a distribution is selected the value provided in 'Parameter value' is a string that the model code can parse in order to sample from the named distribution",
              "required": "true"
            }, {
              "id": "error",
              "label": "Error",
              "type": "text",
              "description": "Error of the parameter value",
              "required": "true"
            }, {
              "id": "variabilitySubject",
              "label": "Parameter variability subject",
              "type": "text",
              "description": "Information on which the variability is described. It can be variability between broiler in a flock, variability between all meat packages sold in Denmark, variability between days, etc.",
              "required": "true"
            }, {
              "id": "unit",
              "label": "Unit",
              "type": "text",
              "description": "Unit of the parameter",
              "required": "true"
            }, {
              "id": "minValue",
              "label": "Value min",
              "type": "text",
              "description": "Numerical value of the minimum limit of the parameter that determines the range of applicability for which the model applies",
              "required": "true"
            }, {
              "id": "unitCategory",
              "label": "Unit category",
              "type": "text",
              "description": "General classification of the parameter unit",
              "required": "true"
            }, {
              "id": "name",
              "label": "Parameter name",
              "type": "text",
              "description": "A name given to the parameter",
              "required": "true"
            }, {
              "id": "id",
              "label": "Parameter ID",
              "type": "text",
              "description": "An unambiguous ID given to each of the parameters - preferably autogenerated by a software tool and compatible with SBML ID requirements, only letters from A to Z, numbers and '_'",
              "required": "true"
            }, {
              "id": "value",
              "label": "Value",
              "type": "text",
              "description": "A default value for the parameter. This is mandatory (needs to be provided) for all parameters of type 'Input'",
              "required": "true"
            }]
          },
          "qualityMeasures": [{
            "id": "rsquared",
            "label": "R squared",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure",
            "required": "true"
          }, {
            "id": "sse",
            "label": "SSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure",
            "required": "true"
          }, {
            "id": "rmse",
            "label": "RMSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure",
            "required": "true"
          }, {
            "id": "aic",
            "label": "AIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure",
            "required": "true"
          }, {
            "id": "sensitivityAnalysis",
            "label": "Sensitivity analysis",
            "type": "long-text",
            "description": "Description of the results of an sensitivity analysis, i.e. how independence assumptions are met or how variables will affect the output of model",
            "required": "true"
          }, {
            "id": "bic",
            "label": "BIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure",
            "required": "true"
          }, {
            "id": "mse",
            "label": "MSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure",
            "required": "true"
          }],
          "modelMath": [{
            "id": "fittingProcedure",
            "label": "Fitting procedure",
            "type": "text",
            "description": "Procedure used to fit the data to the model equation",
            "required": "true"
          }, {
            "id": "event",
            "label": "Event",
            "description": "Definition of time-dependent parameter changes",
            "required": "true"
          }]
        },
        "scope": {
          "product": [{
            "id": "expiryDate",
            "label": "Expiration date",
            "type": "date",
            "description": "Expiry date of food/product",
            "required": "true"
          }, {
            "id": "treatment",
            "label": "Treatment",
            "description": "Used to characterise a product/matrix based on the treatment or processes applied to the product or any indexed ingredient",
            "required": "true"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the product, matrix or environment for which the model or data applies",
            "required": "true"
          }, {
            "id": "productionDate",
            "label": "Production date",
            "type": "date",
            "description": "Date of production of food/product",
            "required": "true"
          }, {
            "id": "method",
            "label": "Method of production",
            "description": "Type of production for the product/ matrix",
            "required": "true"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "The product, matrix or environment (e.g food product, lab media, soil etc.) for which the model or data applies",
            "required": "true"
          }, {
            "id": "originCountry",
            "label": "Country of origin",
            "type": "text",
            "description": "Country of origin of the food/product (ISO 3166-1-alpha-2 country code)",
            "required": "true"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Detailed description of the product, matrix or environment for which the model or data applies",
            "required": "true"
          }, {
            "id": "packaging",
            "label": "Packaging",
            "description": "Describe container or wrapper that holds the product/matrix. Common type of packaging (paper or plastic bags, boxes, tinplate or aluminium cans, plastic trays, plastic bottles, glass bottles or jars)",
            "required": "true"
          }, {
            "id": "fisheriesArea",
            "label": "Fisheries area",
            "type": "text",
            "description": "Fisheries or aquaculture area specifying the origin of the sample (FAO Fisheries areas).",
            "required": "true"
          }, {
            "id": "originArea",
            "label": "Area of origin",
            "type": "text",
            "description": "Area of origin of the food/product (Nomenclature of territorial units for statistics  NUTS  coding system valid only for EEA and Switzerland).",
            "required": "true"
          }],
          "hazard": [{
            "id": "maximumResidueLimit",
            "label": "Maximum Residue Limit (MRL)",
            "type": "text",
            "description": "International regulations and permissible maximum residue levels in food and drinking water",
            "required": "true"
          }, {
            "id": "sourceOfContamination",
            "label": "Source of contamination",
            "type": "text",
            "description": "rigin of the contamination, source",
            "required": "true"
          }, {
            "id": "indSum",
            "label": "Individual or Summed Hazard",
            "type": "text",
            "description": "Define if the parameter reported is an individual residue/analyte, a summed residue definition or part of a sum a summed residue definition",
            "required": "true"
          }, {
            "id": "acceptableOperatorsExposureLevel",
            "label": "Acceptable Operator Exposure Level (AOEL)",
            "type": "text",
            "description": "Maximum amount of active substance to which the operator may be exposed without any adverse health effects. The AOEL is expressed as milligrams of the chemical per kilogram body weight of the operator",
            "required": "true"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Description of the hazard for which the model or data applies",
            "required": "true"
          }, {
            "id": "type",
            "label": "Hazard type",
            "type": "text",
            "description": "General classification of the hazard for which the model or data applies",
            "required": "true"
          }, {
            "id": "adverseEffect",
            "label": "Adverse effect",
            "type": "text",
            "description": "Adverse effect induced by hazard about morbidity, mortality, and etcetera",
            "required": "true"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the hazard for which the model or data applies",
            "required": "true"
          }, {
            "id": "noObservedAdverseAffectLevel",
            "label": "No Observed Adverse Affect Level (NOAEL)",
            "type": "text",
            "description": "Level of exposure of an organism, found by experiment or observation, at which there is no biologically or statistically significant increase in the frequency or severity of any adverse effects in the exposed population when compared to its appropriate control",
            "required": "true"
          }, {
            "id": "acuteReferenceDose",
            "label": "Acute Reference Dose (ARfD)",
            "type": "text",
            "description": "An estimate (with uncertainty spanning perhaps an order of magnitude) of a daily oral exposure for an acute duration (24 hours or less) to the human population (including sensitive subgroups) that is likely to be without an appreciable risk of deleterious effects during a lifetime",
            "required": "true"
          }, {
            "id": "name",
            "label": "Hazard name",
            "type": "text",
            "description": "Name of the hazard (agent, contaminant, chemical) for which the data or model applies",
            "required": "true"
          }, {
            "id": "lowestObservedAdverseAffectLevel",
            "label": "Lowest Observed Adverse Effect Level (LOAEL)",
            "type": "text",
            "description": "Lowest concentration or amount of a substance found by experiment or observation that causes an adverse alteration of morphology, function, capacity, growth, development, or lifespan of a target organism distinguished from normal organisms of the same species under defined conditions of exposure",
            "required": "true"
          }, {
            "id": "benchmarkDose",
            "label": "Benchmark Dose (BMD)",
            "type": "text",
            "description": "A dose or concentration that produces a predetermined change in response rate of an adverse effect (called the benchmark response or BMR) compared to background",
            "required": "true"
          }, {
            "id": "acceptableDailyIntake",
            "label": "Acceptable Daily Intake (ADI)",
            "type": "text",
            "description": "Measure of amount of a specific substance in food or in drinking water tahta can be ingested (orally) on a daily basis over a lifetime without an appreciable health risk",
            "required": "true"
          }],
          "scope": [{
            "id": "spatialInformation",
            "label": "Spatial information",
            "description": "Spatial information (area) on which the model or data applies",
            "required": "true"
          }, {
            "id": "generalComment",
            "label": "General comment",
            "type": "long-text",
            "description": "General comments on the scope of the study, data or model",
            "required": "true"
          }, {
            "id": "temporalInformation",
            "label": "Temporal information",
            "type": "long-text",
            "description": "Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)",
            "required": "true"
          }]
        },
        "generalInformation": {
          "creator": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English",
            "required": "true"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code",
            "required": "true"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment",
            "required": "true"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)",
            "required": "true"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name",
            "required": "true"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone",
            "required": "true"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication.",
            "required": "true"
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated.",
            "required": "true"
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address",
            "required": "true"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname.",
            "required": "true"
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information",
            "required": "true"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province",
            "required": "true"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication.",
            "required": "true"
          }],
          "author": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English",
            "required": "true"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code",
            "required": "true"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment",
            "required": "true"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)",
            "required": "true"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name",
            "required": "true"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone",
            "required": "true"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication.",
            "required": "true"
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated.",
            "required": "true"
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address",
            "required": "true"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname.",
            "required": "true"
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information",
            "required": "true"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province",
            "required": "true"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication.",
            "required": "true"
          }],
          "reference": [{
            "id": "date",
            "label": "Date",
            "type": "year_date",
            "description": "Temporal information on the publication date",
            "required": "true"
          }, {
            "id": "website",
            "label": "Website",
            "type": "text",
            "description": "A link to the publication website (different from DOI)",
            "required": "true"
          }, {
            "id": "issue",
            "label": "Issue",
            "type": "text",
            "description": "Data on the details of the issue in which the model or date has been described",
            "required": "true"
          }, {
            "id": "publicationType",
            "label": "Publication type",
            "type": "text",
            "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... ",
            "required": "true"
          }, {
            "id": "abstract",
            "label": "Abstract",
            "type": "text",
            "description": "Abstract of the publication in which the model or the data has been described ",
            "required": "true"
          }, {
            "id": "isReferenceDescription",
            "label": "Is_reference_description?",
            "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'",
            "required": "true"
          }, {
            "id": "title",
            "label": "Title",
            "type": "long-text",
            "description": "Title of publication in which the model or date has been described",
            "required": "true"
          }, {
            "id": "pmid",
            "label": "PubMed ID",
            "type": "text",
            "description": "The PubMed ID related to this publication",
            "required": "true"
          }, {
            "id": "volume",
            "label": "Volume",
            "type": "text",
            "description": "Data on the details of the volume in which the model or date has been described",
            "required": "true"
          }, {
            "id": "journal",
            "label": "Journal",
            "type": "long-text",
            "description": "Data on the details of the journal in which the model or date has been described",
            "required": "true"
          }, {
            "id": "authorList",
            "label": "Author list",
            "type": "long-text",
            "description": "Name and surname of the authors who contributed to this publication",
            "required": "true"
          }, {
            "id": "comment",
            "label": "Comment",
            "type": "long-text",
            "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script",
            "required": "true"
          }, {
            "id": "doi",
            "label": "Publication DOI",
            "type": "long-text",
            "description": "The DOI related to this publication",
            "required": "true"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The status of this publication, e.g. Published, Submitted, etc.",
            "required": "true"
          }],
          "modelCategory": [{
            "id": "modelClassComment",
            "label": "Comment",
            "type": "long-text",
            "description": "Comment with further details on the model class",
            "required": "true"
          }, {
            "id": "basicProcess",
            "label": "Basic process",
            "description": "Defines the impact of the process on the hazard (so far only valid for process models and predictive models)",
            "required": "true"
          }, {
            "id": "modelClass",
            "label": "Model class",
            "type": "text",
            "description": "Type of model according to RAKIP classification",
            "required": "true"
          }, {
            "id": "modelSubClass",
            "label": "Subclass",
            "description": "Sub-classification of the model given the Model Class",
            "required": "true"
          }],
          "generalInformation": [{
            "id": "identifier",
            "label": "Identifier",
            "type": "text",
            "description": "An unambiguous ID given to the model or data. This can also be created automatically by a software tool",
            "required": "true"
          }, {
            "id": "software",
            "label": "Software",
            "type": "text",
            "description": "The program or software language in which the model has been implemented",
            "required": "true"
          }, {
            "id": "format",
            "label": "Format",
            "type": "text",
            "description": "File extension of the model or data file (including version number of format if applicable)",
            "required": "true"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the study, data or model",
            "required": "true"
          }, {
            "id": "language",
            "label": "Language",
            "type": "text",
            "description": "A language of the resource (some data or reports can be available in French language for example)",
            "required": "true"
          }, {
            "id": "source",
            "label": "Source",
            "type": "text",
            "description": "A source from which the model/data is derived",
            "required": "true"
          }, {
            "id": "availability",
            "label": "Availability",
            "type": "text",
            "description": "Availability of data or model, i.e. if the annotated model code / data is included in this FSK file",
            "required": "true"
          }, {
            "id": "creationDate",
            "label": "Creation date",
            "type": "date",
            "description": "Creation date/time of the FSK file",
            "required": "true"
          }, {
            "id": "url",
            "label": "URL",
            "type": "text",
            "description": "Web address referencing the resource location (data for example)",
            "required": "true"
          }, {
            "id": "objective",
            "label": "Objective",
            "type": "long-text",
            "description": "Objective of the model or data",
            "required": "true"
          }, {
            "id": "modificationDate",
            "label": "Modification date",
            "description": "Date/time of the last version of the FSK file",
            "required": "true"
          }, {
            "id": "rights",
            "label": "Rights",
            "type": "text",
            "description": "Rights granted for usage, distribution and modification of this FSK file",
            "required": "true"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "A name given to the model or data",
            "required": "true"
          }, {
            "id": "languageWrittenIn",
            "label": "Language written in",
            "type": "text",
            "description": "Software language used to write the model, e.g. R or MatLab",
            "required": "true"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The curation status of the model",
            "required": "true"
          }]
        }
      };
    }
    // Validate this.panels and return boolean
  }, {
    key: "validate",
    value: function validate() {
      var isValid = true;
      if (!this.panels.generalInformation.validate()) isValid = false;
      if (!this.panels.modelCategory.validate()) isValid = false;
      if (!this.panels.scopeGeneral.validate()) isValid = false;
      if (!this.panels.study.validate()) isValid = false;
      return isValid;
    }
  }, {
    key: "_createPanels",
    value: function _createPanels() {
      var port = window.port || -1;
      var schema = schemas.genericModel;
      return _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
        study: new _FormPanel.FormPanel("Study", this.jsonSchema.dataBackground.study, this._metadata.dataBackground ? this._metadata.dataBackground.study : {}, port),
        laboratory: new _TablePanel.TablePanel("Laboratory", this.jsonSchema.dataBackground.laboratory, this._metadata.dataBackground ? this._metadata.dataBackground.laboratory : {}, port),
        assay: new _TablePanel.TablePanel("Assay", this.jsonSchema.dataBackground.assay, this._metadata.dataBackground ? this._metadata.dataBackground.assay : {}, port),
        studySample: new _TablePanel.TablePanel("Study Sample", this.jsonSchema.dataBackground.studySample, this._metadata.dataBackground ? this._metadata.dataBackground.studySample : {}, port),
        modelMath: new _FormPanel.FormPanel("Model Math", this.jsonSchema.modelMath.modelMath, this._metadata.modelMath, port),
        modelEquation: new _TablePanel.TablePanel("Model Equation", this.jsonSchema.modelMath.modelEquation.modelEquation, this._metadata.modelMath ? this._metadata.modelMath.modelEquation : {}, port),
        reference: new _TablePanel.TablePanel("Reference", this.jsonSchema.modelMath.modelEquation.reference, this._metadata.modelMath.modelEquation ? this._metadata.modelMath.modelEquation.reference : {}, port),
        parameter: new _TablePanel.TablePanel("Parameter", this.jsonSchema.modelMath.parameter.parameter, this._metadata.modelMath ? this._metadata.modelMath.parameter : {}, port)
      }, "reference", new _FormPanel.FormPanel("Reference", this.jsonSchema.modelMath.parameter.reference, this._metadata.modelMath.parameter ? this._metadata.modelMath.parameter.reference : {}, port)), "qualityMeasures", new _TablePanel.TablePanel("Quality Measures", this.jsonSchema.modelMath.qualityMeasures, this._metadata.modelMath ? this._metadata.modelMath.qualityMeasures : {}, port)), "scope", new _FormPanel.FormPanel("Scope", this.jsonSchema.scope.scope, this._metadata.scope, port)), "product", new _TablePanel.TablePanel("Product", this.jsonSchema.scope.product, this._metadata.scope ? this._metadata.scope.product : {}, port)), "hazard", new _TablePanel.TablePanel("Hazard", this.jsonSchema.scope.hazard, this._metadata.scope ? this._metadata.scope.hazard : {}, port)), "generalInformation", new _FormPanel.FormPanel("General Information", this.jsonSchema.generalInformation.generalInformation, this._metadata.generalInformation, port)), "creator", new _TablePanel.TablePanel("Creator", this.jsonSchema.generalInformation.creator, this._metadata.generalInformation ? this._metadata.generalInformation.creator : {}, port)), "author", new _TablePanel.TablePanel("Author", this.jsonSchema.generalInformation.author, this._metadata.generalInformation ? this._metadata.generalInformation.author : {}, port)), "reference", new _TablePanel.TablePanel("Reference", this.jsonSchema.generalInformation.reference, this._metadata.generalInformation ? this._metadata.generalInformation.reference : {}, port)), "modelCategory", new _FormPanel.FormPanel("Model Category", this.jsonSchema.generalInformation.modelCategory, this._metadata.generalInformation ? this._metadata.generalInformation.modelCategory : {}, port));
    }
  }]);
}(_ModelView2.ModelView);

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./ModelView":118,"./PredictiveModelDataBackgroundView":135,"./PredictiveModelGeneralInformationView":137,"./PredictiveModelModelMathView":139,"./ProcessModelScopeView":147}],149:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Product = void 0;
var _ApiClient = require("../ApiClient");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Product model module.
 * @module model/Product
 * @version 1.0.0
 */
var Product = exports.Product = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>Product</code>.
   * @alias module:model/Product
   * @class
   * @param unit {} Unit of the product, matrix or environment for which the model or data applies
   * @param name {} The product, matrix or environment (e.g food product, lab media, soil etc.) for which the model or data applies
   */
  function Product(unitname) {
    _classCallCheck(this, Product);
    this.unit = unit;
    this.name = name;
  }

  /**
   * Constructs a <code>Product</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/Product} obj Optional instance to populate.
   * @return {module:model/Product} The populated <code>Product</code> instance.
   */
  return _createClass(Product, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new Product();
        if (data.hasOwnProperty('expiryDate')) obj.expiryDate = _ApiClient.ApiClient.convertToType(data['expiryDate'], 'Date');
        if (data.hasOwnProperty('treatment')) obj.treatment = _ApiClient.ApiClient.convertToType(data['treatment'], ['String']);
        if (data.hasOwnProperty('unit')) obj.unit = _ApiClient.ApiClient.convertToType(data['unit'], 'String');
        if (data.hasOwnProperty('productionDate')) obj.productionDate = _ApiClient.ApiClient.convertToType(data['productionDate'], 'Date');
        if (data.hasOwnProperty('method')) obj.method = _ApiClient.ApiClient.convertToType(data['method'], ['String']);
        if (data.hasOwnProperty('name')) obj.name = _ApiClient.ApiClient.convertToType(data['name'], 'String');
        if (data.hasOwnProperty('originCountry')) obj.originCountry = _ApiClient.ApiClient.convertToType(data['originCountry'], 'String');
        if (data.hasOwnProperty('description')) obj.description = _ApiClient.ApiClient.convertToType(data['description'], 'String');
        if (data.hasOwnProperty('packaging')) obj.packaging = _ApiClient.ApiClient.convertToType(data['packaging'], ['String']);
        if (data.hasOwnProperty('fisheriesArea')) obj.fisheriesArea = _ApiClient.ApiClient.convertToType(data['fisheriesArea'], 'String');
        if (data.hasOwnProperty('originArea')) obj.originArea = _ApiClient.ApiClient.convertToType(data['originArea'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * Expiry date of food/product
 * @member {Date} expiryDate
 */
Product.prototype.expiryDate = undefined;

/**
 * Used to characterise a product/matrix based on the treatment or processes applied to the product or any indexed ingredient
 * @member {Array.<String>} treatment
 */
Product.prototype.treatment = undefined;

/**
 * Unit of the product, matrix or environment for which the model or data applies
 * @member {String} unit
 */
Product.prototype.unit = undefined;

/**
 * Date of production of food/product
 * @member {Date} productionDate
 */
Product.prototype.productionDate = undefined;

/**
 * Type of production for the product/ matrix
 * @member {Array.<String>} method
 */
Product.prototype.method = undefined;

/**
 * The product, matrix or environment (e.g food product, lab media, soil etc.) for which the model or data applies
 * @member {String} name
 */
Product.prototype.name = undefined;

/**
 * Country of origin of the food/product (ISO 3166-1-alpha-2 country code)
 * @member {String} originCountry
 */
Product.prototype.originCountry = undefined;

/**
 * Detailed description of the product, matrix or environment for which the model or data applies
 * @member {String} description
 */
Product.prototype.description = undefined;

/**
 * Describe container or wrapper that holds the product/matrix. Common type of packaging (paper or plastic bags, boxes, tinplate or aluminium cans, plastic trays, plastic bottles, glass bottles or jars)
 * @member {Array.<String>} packaging
 */
Product.prototype.packaging = undefined;

/**
 * Fisheries or aquaculture area specifying the origin of the sample (FAO Fisheries areas).
 * @member {String} fisheriesArea
 */
Product.prototype.fisheriesArea = undefined;

/**
 * Area of origin of the food/product (Nomenclature of territorial units for statistics  NUTS  coding system valid only for EEA and Switzerland).
 * @member {String} originArea
 */
Product.prototype.originArea = undefined;

},{"../ApiClient":44}],150:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProductView = void 0;
var _ApiClient = require("../ApiClient");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Product View  module.
 * @module model/Product
 * @version 1.0.0
 */
var ProductView = exports.ProductView = /*#__PURE__*/_createClass(function ProductView() {
  _classCallCheck(this, ProductView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63}],151:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QraModel = void 0;
var _ApiClient = require("../ApiClient");
var _ExposureModelScope = require("./ExposureModelScope");
var _GenericModelDataBackground = require("./GenericModelDataBackground");
var _GenericModelModelMath = require("./GenericModelModelMath");
var _Model2 = require("./Model");
var _PredictiveModelGeneralInformation = require("./PredictiveModelGeneralInformation");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The QraModel model module.
 * @module model/QraModel
 * @version 1.0.0
 */
var QraModel = exports.QraModel = /*#__PURE__*/function (_Model) {
  /**
   * Constructs a new <code>QraModel</code>.
   * @alias module:model/QraModel
   * @class
   * @extends module:model/Model
   * @param modelType {} 
   */
  function QraModel(modelType) {
    _classCallCheck(this, QraModel);
    return _callSuper(this, QraModel, [modelType]);
  }

  /**
   * Constructs a <code>QraModel</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/QraModel} obj Optional instance to populate.
   * @return {module:model/QraModel} The populated <code>QraModel</code> instance.
   */
  _inherits(QraModel, _Model);
  return _createClass(QraModel, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new QraModel();
        _Model2.Model.constructFromObject(data, obj);
        if (data.hasOwnProperty('dataBackground')) obj.dataBackground = _GenericModelDataBackground.GenericModelDataBackground.constructFromObject(data['dataBackground']);
        if (data.hasOwnProperty('modelMath')) obj.modelMath = _GenericModelModelMath.GenericModelModelMath.constructFromObject(data['modelMath']);
        if (data.hasOwnProperty('scope')) obj.scope = _ExposureModelScope.ExposureModelScope.constructFromObject(data['scope']);
        if (data.hasOwnProperty('generalInformation')) obj.generalInformation = _PredictiveModelGeneralInformation.PredictiveModelGeneralInformation.constructFromObject(data['generalInformation']);
      }
      return obj;
    }
  }]);
}(_Model2.Model);
/**
 * @member {module:model/GenericModelDataBackground} dataBackground
 */
QraModel.prototype.dataBackground = undefined;

/**
 * @member {module:model/GenericModelModelMath} modelMath
 */
QraModel.prototype.modelMath = undefined;

/**
 * @member {module:model/ExposureModelScope} scope
 */
QraModel.prototype.scope = undefined;

/**
 * @member {module:model/PredictiveModelGeneralInformation} generalInformation
 */
QraModel.prototype.generalInformation = undefined;

},{"../ApiClient":44,"./ExposureModelScope":91,"./GenericModelDataBackground":96,"./GenericModelModelMath":100,"./Model":113,"./PredictiveModelGeneralInformation":136}],152:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QraModelView = void 0;
var _ApiClient = require("../ApiClient");
var _ExposureModelScopeView = require("./ExposureModelScopeView");
var _GenericModelDataBackgroundView = require("./GenericModelDataBackgroundView");
var _GenericModelModelMathView = require("./GenericModelModelMathView");
var _ModelView2 = require("./ModelView");
var _PredictiveModelGeneralInformationView = require("./PredictiveModelGeneralInformationView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The QraModel View  module.
 * @module model/QraModel
 * @version 1.0.0
 */
var QraModelView = exports.QraModelView = /*#__PURE__*/function (_ModelView) {
  function QraModelView(metadata, img, state, modelScript, visScript, readme) {
    var _this$_panels;
    var _this;
    _classCallCheck(this, QraModelView);
    _this = _callSuper(this, QraModelView, [metadata, img, modelScript, visScript, readme]);
    _this._schema = schemas.genericModel;
    if (state) {
      _this.panels = _this._createPanels();
    }
    _this._menu = [{
      "label": "General Information",
      "id": "generalInformation",
      "submenus": [{
        "label": "General Information",
        "id": "generalInformation"
      }, {
        "label": "Model Category",
        "id": "modelCategory"
      }, {
        "label": "Reference",
        "id": "reference"
      }, {
        "label": "Author",
        "id": "author"
      }, {
        "label": "Creator",
        "id": "creator"
      }]
    }, {
      "label": "Scope",
      "id": "scope",
      "submenus": [{
        "label": "Scope",
        "id": "scope"
      }, {
        "label": "Hazard",
        "id": "hazard"
      }, {
        "label": "Population Group",
        "id": "populationGroup"
      }, {
        "label": "Product",
        "id": "product"
      }]
    }, {
      "label": "Model Math",
      "id": "modelMath",
      "submenus": [{
        "label": "Model Math",
        "id": "modelMath"
      }, {
        "label": "Quality Measures",
        "id": "qualityMeasures"
      }, {
        "label": "Parameter",
        "id": "parameter",
        "submenus": [{
          "label": "Parameter",
          "id": "parameter"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }, {
        "label": "Exposure",
        "id": "exposure"
      }, {
        "label": "Model Equation",
        "id": "modelEquation",
        "submenus": [{
          "label": "Model Equation",
          "id": "modelEquation"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }]
    }, {
      "label": "Data Background",
      "id": "dataBackground",
      "submenus": [{
        "label": "Study Sample",
        "id": "studySample"
      }, {
        "label": "Dietary Assessment Method",
        "id": "dietaryAssessmentMethod"
      }, {
        "label": "Assay",
        "id": "assay"
      }, {
        "label": "Laboratory",
        "id": "laboratory"
      }, {
        "label": "Study",
        "id": "study"
      }]
    }];
    _this._panels = (_this$_panels = {
      study: {
        type: 'simple',
        schema: _this.jsonSchema.dataBackgroundstudy,
        metadata: _this._metadata.study
      },
      laboratory: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundlaboratory,
        metadata: _this._metadata.laboratory
      },
      assay: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundassay,
        metadata: _this._metadata.assay
      },
      dietaryAssessmentMethod: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgrounddietaryAssessmentMethod,
        metadata: _this._metadata.dietaryAssessmentMethod
      },
      studySample: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundstudySample,
        metadata: _this._metadata.studySample
      },
      modelMath: {
        type: 'simple',
        schema: _this.jsonSchema.modelMathmodelMath,
        metadata: _this._metadata.modelMath
      },
      modelEquation: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationmodelEquation,
        metadata: _this._metadata.modelEquation
      },
      reference: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationreference,
        metadata: _this._metadata.reference
      },
      exposure: {
        type: 'complex',
        schema: _this.jsonSchema.modelMathexposure,
        metadata: _this._metadata.exposure
      },
      parameter: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.parameterparameter,
        metadata: _this._metadata.parameter
      }
    }, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_this$_panels, "reference", {
      type: 'simple',
      schema: _this.jsonSchema.modelMath.parameterreference,
      metadata: _this._metadata.reference
    }), "qualityMeasures", {
      type: 'complex',
      schema: _this.jsonSchema.modelMathqualityMeasures,
      metadata: _this._metadata.qualityMeasures
    }), "scope", {
      type: 'simple',
      schema: _this.jsonSchema.scopescope,
      metadata: _this._metadata.scope
    }), "product", {
      type: 'complex',
      schema: _this.jsonSchema.scopeproduct,
      metadata: _this._metadata.product
    }), "populationGroup", {
      type: 'complex',
      schema: _this.jsonSchema.scopepopulationGroup,
      metadata: _this._metadata.populationGroup
    }), "hazard", {
      type: 'complex',
      schema: _this.jsonSchema.scopehazard,
      metadata: _this._metadata.hazard
    }), "generalInformation", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationgeneralInformation,
      metadata: _this._metadata.generalInformation
    }), "creator", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationcreator,
      metadata: _this._metadata.creator
    }), "author", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationauthor,
      metadata: _this._metadata.author
    }), "reference", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationreference,
      metadata: _this._metadata.reference
    }), _defineProperty(_this$_panels, "modelCategory", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationmodelCategory,
      metadata: _this._metadata.modelCategory
    }));
    return _this;
  }
  _inherits(QraModelView, _ModelView);
  return _createClass(QraModelView, [{
    key: "metaData",
    get: function get() {
      try {
        this._metadata.dataBackground.study = this.panels.study.data;
        this._metadata.dataBackground.laboratory = this.panels.laboratory.data;
        this._metadata.dataBackground.assay = this.panels.assay.data;
        this._metadata.dataBackground.dietaryAssessmentMethod = this.panels.dietaryAssessmentMethod.data;
        this._metadata.dataBackground.studySample = this.panels.studySample.data;
        this._metadata.modelMath = this.panels.modelMath.data;
        this._metadata.modelMath.modelEquation = this.panels.modelEquation.data;
        this._metadata.modelMath.modelEquation.reference = this.panels.reference.data;
        this._metadata.modelMath.exposure = this.panels.exposure.data;
        this._metadata.modelMath.parameter = this.panels.parameter.data;
        this._metadata.modelMath.parameter.reference = this.panels.reference.data;
        this._metadata.modelMath.qualityMeasures = this.panels.qualityMeasures.data;
        this._metadata.scope = this.panels.scope.data;
        this._metadata.scope.product = this.panels.product.data;
        this._metadata.scope.populationGroup = this.panels.populationGroup.data;
        this._metadata.scope.hazard = this.panels.hazard.data;
        this._metadata.generalInformation = this.panels.generalInformation.data;
        this._metadata.generalInformation.creator = this.panels.creator.data;
        this._metadata.generalInformation.author = this.panels.author.data;
        this._metadata.generalInformation.reference = this.panels.reference.data;
        this._metadata.generalInformation.modelCategory = this.panels.modelCategory.data;
        this._metadata.modelType = "QraModel";
        this._metadata = metadataFix(this._metadata);
      } catch (error) {
        console.log(error);
      }
      return this._metadata;
    }
  }, {
    key: "jsonSchema",
    get: function get() {
      return {
        "dataBackground": {
          "study": [{
            "id": "identifier",
            "label": "Study identifier",
            "type": "text",
            "description": "A user defined identifier for the study"
          }, {
            "id": "protocolComponentsName",
            "label": "Components names",
            "type": "text",
            "description": "The names of the components used when carrying out this protocol"
          }, {
            "id": "designType",
            "label": "Design type",
            "type": "text",
            "description": "The type of study design being employed"
          }, {
            "id": "assayMeasurementType",
            "label": "Assay measurement type",
            "type": "text",
            "description": "The measurement being observed in this assay"
          }, {
            "id": "protocolComponentsType",
            "label": "Protocol components type",
            "type": "text",
            "description": "Description"
          }, {
            "id": "description",
            "label": "Study description",
            "type": "long-text",
            "description": "A brief description of the study aims"
          }, {
            "id": "assayTechnologyPlatform",
            "label": "Assay technology platform",
            "type": "text",
            "description": "The technology platform used"
          }, {
            "id": "assayTechnologyType",
            "label": "Assay technology type",
            "type": "text",
            "description": "The technology being employed to observe this measurement"
          }, {
            "id": "protocolType",
            "label": "Protocol type",
            "type": "text",
            "description": "The type of the protocol, preferably coming from an Ontology, e.g. Extraction Protocol"
          }, {
            "id": "title",
            "label": "Study title",
            "type": "long-text",
            "description": "A title for the study"
          }, {
            "id": "protocolDescription",
            "label": "Protocol description",
            "type": "long-text",
            "description": "A description of the protocol"
          }, {
            "id": "protocolParametersName",
            "label": "Parameters names",
            "type": "text",
            "description": "The parameters used when executing this protocol"
          }, {
            "id": "protocolName",
            "label": "Protocol name",
            "type": "text",
            "description": "The name of the protocol, e.g.Extraction Protocol"
          }, {
            "id": "protocolVersion",
            "label": "Protocol version",
            "type": "text",
            "description": "The version of the protocol used, where applicable."
          }, {
            "id": "protocolURI",
            "label": "Protocol URI",
            "type": "text",
            "description": "A URI to link out to a publication, web page, etc. describing the protocol"
          }, {
            "id": "accreditationProcedureForTheAssayTechnology",
            "label": "Accreditation procedure for assay",
            "type": "text",
            "description": "Accreditation procedure for the analytical method used"
          }],
          "laboratory": [{
            "id": "country",
            "label": "Laboratory country",
            "type": "text",
            "description": "Country where the laboratory is placed. (ISO 3166-1-alpha-2)"
          }, {
            "id": "name",
            "label": "Laboratory name",
            "type": "text",
            "description": "Laboratory code (National laboratory code if available) or Laboratory name "
          }, {
            "id": "accreditation",
            "label": "Laboratory accreditation",
            "description": "The laboratory accreditation to ISO/IEC 17025"
          }],
          "assay": [{
            "id": "contaminationRange",
            "label": "Range of contamination",
            "type": "text",
            "description": "Range of result of the analytical measure reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "uncertaintyValue",
            "label": "Uncertainty value",
            "type": "text",
            "description": "Indicate the expanded uncertainty (usually 95% confidence interval) value associated with the measurement expressed in the unit reported in the field Hazard unit"
          }, {
            "id": "fatPercentage",
            "label": "Percentage of fat",
            "type": "text",
            "description": "Percentage of fat in the original sample"
          }, {
            "id": "name",
            "label": "Assay name",
            "type": "text",
            "description": "A name given to the assay"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the assay. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "moisturePercentage",
            "label": "Percentage of moisture",
            "type": "text",
            "description": "Percentage of moisture in the original sample"
          }, {
            "id": "leftCensoredData",
            "label": "Left-censored data",
            "type": "text",
            "description": "Percentage of measures equal to LOQ and/or LOD"
          }, {
            "id": "detectionLimit",
            "label": "Limit of detection",
            "type": "text",
            "description": "Limit of detection reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "quantificationLimit",
            "label": "Limit of quantification",
            "type": "text",
            "description": "Limit of quantification reported in the unit specified by the variable Hazard unit"
          }],
          "dietaryAssessmentMethod": [{
            "id": "recordTypes",
            "label": "Type of records",
            "description": "Consumption occasion, mean of consumption, quantified and described as eaten, recipes for self-made"
          }, {
            "id": "numberOfFoodItems",
            "label": "Number of food items",
            "description": "Number of food items"
          }, {
            "id": "numberOfNonConsecutiveOneDay",
            "label": "Number of non-consecutive one-day",
            "type": "text",
            "description": "Number of non-consecutive one-day recorded"
          }, {
            "id": "softwareTool",
            "label": "Dietary software tool",
            "type": "text",
            "description": "Name of the software used to collect the data"
          }, {
            "id": "foodDescriptors",
            "label": "Food descriptors",
            "description": "Description using FoodEx2 facet"
          }, {
            "id": "collectionTool",
            "label": "Methodological tool to collect data",
            "type": "text",
            "description": "Food diaries, interview, 24-hour recall interview, food propensy questionnaire, portion size measurement aids, eating outside questionnaire"
          }],
          "studySample": [{
            "id": "sampleName",
            "label": "Name",
            "type": "text",
            "description": "An unambiguous ID given to the samples used in the assay"
          }, {
            "id": "samplingWeight",
            "label": "Sampling weight",
            "type": "text",
            "description": "Description of the method employed to compute sampling weight (nonresponse-adjusted weight)"
          }, {
            "id": "protocolOfSampleCollection",
            "label": "Protocol of sample collection",
            "type": "text",
            "description": "Additional protocol for sample and sample collection. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "samplingStrategy",
            "label": "Sampling strategy",
            "type": "text",
            "description": "Sampling strategy (ref. EUROSTAT - Typology of sampling strategy, version of July 2009)"
          }, {
            "id": "samplingSize",
            "label": "Sampling size",
            "type": "text",
            "description": "Number of units, full participants, partial participants, eligibles, not eligible, unresolved (eligibility status not resolved)"
          }, {
            "id": "lotSizeUnit",
            "label": "Lot size unit",
            "type": "text",
            "description": "Unit in which the lot size is expressed"
          }, {
            "id": "samplingPoint",
            "label": "Sampling point",
            "type": "text",
            "description": "Point in the food chain where the sample was taken. (Doc. ESTAT/F5/ES/155 Data dictionary of activities of the establishments)"
          }, {
            "id": "samplingMethod",
            "label": "Sampling method",
            "type": "text",
            "description": "Sampling method used to take the sample"
          }, {
            "id": "typeOfSamplingProgram",
            "label": "Type of sampling program",
            "type": "text",
            "description": "Indicate the type of programm for which the samples have been collected"
          }, {
            "id": "samplingPlan",
            "label": "Sampling plan",
            "type": "text",
            "description": "Description of data collection technique: stratified or complex sampling (several stages)"
          }]
        },
        "modelMath": {
          "modelEquation": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "modelEquation": [{
              "id": "modelEquation",
              "label": "Equation",
              "type": "text",
              "description": "The pointer to the file that holds the software code (e.g. R-script)"
            }, {
              "id": "name",
              "label": "Model equation name",
              "type": "text",
              "description": "A name given to the model equation"
            }, {
              "id": "modelHypothesis",
              "label": "Hypothesis of the model",
              "description": "Description of the hypothesis of the model"
            }, {
              "id": "modelEquationClass",
              "label": "Model equation class",
              "type": "text",
              "description": "Information on that helps to categorize model equations"
            }]
          },
          "exposure": [{
            "id": "treatment",
            "label": "Left-censored data treatment",
            "description": "Description of the mathematical method to replace left-censored data (recommandation of WHO (2013), distribution or others)"
          }, {
            "id": "scenario",
            "label": "Scenario",
            "description": "Description of the different scenarios of exposure assessment"
          }, {
            "id": "uncertaintyEstimation",
            "label": "Uncertainty estimation",
            "type": "text",
            "description": "Analysis to estimate uncertainty"
          }, {
            "id": "type",
            "label": "Type of exposure",
            "type": "text",
            "description": "Description of the type of exposure"
          }, {
            "id": "contamination",
            "label": "Contam level post data treatment",
            "description": "Description of the range of of the level of contamination after left censored data treatment"
          }],
          "parameter": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "parameter": [{
              "id": "subject",
              "label": "Parameter subject",
              "type": "text",
              "description": "Scope of the parameter, e.g. if it refers to an animal, a batch of animals, a batch of products, a carcass, a carcass skin etc"
            }, {
              "id": "maxValue",
              "label": "Value max",
              "type": "text",
              "description": "Numerical value of the maximum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "dataType",
              "label": "Data type",
              "type": "text",
              "description": "Information on the data format of the parameter, e.g. if it is a categorical variable: int, double, array of size x,y,z "
            }, {
              "id": "description",
              "label": "Description",
              "type": "text",
              "description": "General description of the parameter"
            }, {
              "id": "source",
              "label": "Parameter source",
              "type": "text",
              "description": "Information on the type of knowledge used to define the parameter value"
            }, {
              "id": "classification",
              "label": "Parameter classification",
              "type": "text",
              "description": "General classification of the parameter (e.g. Input, Constant, Output etc)"
            }, {
              "id": "distribution",
              "label": "Parameter distribution",
              "type": "text",
              "description": "Distribution describing the parameter variabilty. If no distribution selected this means the value provided in 'Parameter value' is a point estimate. In case a distribution is selected the value provided in 'Parameter value' is a string that the model code can parse in order to sample from the named distribution"
            }, {
              "id": "error",
              "label": "Error",
              "type": "text",
              "description": "Error of the parameter value"
            }, {
              "id": "variabilitySubject",
              "label": "Parameter variability subject",
              "type": "text",
              "description": "Information on which the variability is described. It can be variability between broiler in a flock, variability between all meat packages sold in Denmark, variability between days, etc."
            }, {
              "id": "unit",
              "label": "Unit",
              "type": "text",
              "description": "Unit of the parameter"
            }, {
              "id": "minValue",
              "label": "Value min",
              "type": "text",
              "description": "Numerical value of the minimum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "unitCategory",
              "label": "Unit category",
              "type": "text",
              "description": "General classification of the parameter unit"
            }, {
              "id": "name",
              "label": "Parameter name",
              "type": "text",
              "description": "A name given to the parameter"
            }, {
              "id": "id",
              "label": "Parameter ID",
              "type": "text",
              "description": "An unambiguous ID given to each of the parameters - preferably autogenerated by a software tool and compatible with SBML ID requirements, only letters from A to Z, numbers and '_'"
            }, {
              "id": "value",
              "label": "Value",
              "type": "text",
              "description": "A default value for the parameter. This is mandatory (needs to be provided) for all parameters of type 'Input'"
            }]
          },
          "qualityMeasures": [{
            "id": "rsquared",
            "label": "R squared",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sse",
            "label": "SSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "rmse",
            "label": "RMSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "aic",
            "label": "AIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sensitivityAnalysis",
            "label": "Sensitivity analysis",
            "type": "long-text",
            "description": "Description of the results of an sensitivity analysis, i.e. how independence assumptions are met or how variables will affect the output of model"
          }, {
            "id": "bic",
            "label": "BIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "mse",
            "label": "MSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }],
          "modelMath": [{
            "id": "fittingProcedure",
            "label": "Fitting procedure",
            "type": "text",
            "description": "Procedure used to fit the data to the model equation"
          }, {
            "id": "event",
            "label": "Event",
            "description": "Definition of time-dependent parameter changes"
          }]
        },
        "scope": {
          "product": [{
            "id": "expiryDate",
            "label": "Expiration date",
            "type": "date",
            "description": "Expiry date of food/product"
          }, {
            "id": "treatment",
            "label": "Treatment",
            "description": "Used to characterise a product/matrix based on the treatment or processes applied to the product or any indexed ingredient"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the product, matrix or environment for which the model or data applies"
          }, {
            "id": "productionDate",
            "label": "Production date",
            "type": "date",
            "description": "Date of production of food/product"
          }, {
            "id": "method",
            "label": "Method of production",
            "description": "Type of production for the product/ matrix"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "The product, matrix or environment (e.g food product, lab media, soil etc.) for which the model or data applies"
          }, {
            "id": "originCountry",
            "label": "Country of origin",
            "type": "text",
            "description": "Country of origin of the food/product (ISO 3166-1-alpha-2 country code)"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Detailed description of the product, matrix or environment for which the model or data applies"
          }, {
            "id": "packaging",
            "label": "Packaging",
            "description": "Describe container or wrapper that holds the product/matrix. Common type of packaging (paper or plastic bags, boxes, tinplate or aluminium cans, plastic trays, plastic bottles, glass bottles or jars)"
          }, {
            "id": "fisheriesArea",
            "label": "Fisheries area",
            "type": "text",
            "description": "Fisheries or aquaculture area specifying the origin of the sample (FAO Fisheries areas)."
          }, {
            "id": "originArea",
            "label": "Area of origin",
            "type": "text",
            "description": "Area of origin of the food/product (Nomenclature of territorial units for statistics  NUTS  coding system valid only for EEA and Switzerland)."
          }],
          "populationGroup": [{
            "id": "populationRiskFactor",
            "label": "Risk and population factors",
            "description": "Population risk factor that may influence the outcomes of the study, confounder should be included"
          }, {
            "id": "country",
            "label": "Country",
            "description": "Country on which the population group of the model or data applies"
          }, {
            "id": "populationSpan",
            "label": "Population span (years)",
            "description": "Temporal information on the exposure duration"
          }, {
            "id": "populationGender",
            "label": "Population gender",
            "type": "text",
            "description": "Description of the percentage of gender"
          }, {
            "id": "populationDescription",
            "label": "Description",
            "description": "Description of the population for which the model applies (demographic and socio-economic characteristics for example). Background information that are needed in the data analysis phase, size of household, education level, employment status, professional category, ethnicity, etc."
          }, {
            "id": "populationAge",
            "label": "Population age",
            "description": "Description of the range of age or group of age"
          }, {
            "id": "patternConsumption",
            "label": "Consumption pattern",
            "description": "Description of the consumption of different food items, frequency, portion size"
          }, {
            "id": "name",
            "label": "Population name",
            "type": "text",
            "description": "Name of the population for which the model or data applies"
          }, {
            "id": "season",
            "label": "Season",
            "description": "Distribution of surveyed people according to the season (influence consumption pattern)"
          }, {
            "id": "region",
            "label": "Region",
            "description": "Spatial information (area) on which the population group of the model or data applies"
          }, {
            "id": "targetPopulation",
            "label": "Target population",
            "type": "text",
            "description": "Population of individual that we are interested in describing and making statistical inferences about"
          }, {
            "id": "bmi",
            "label": "BMI",
            "description": "Description of the range of BMI or class of BMI or BMI mean"
          }, {
            "id": "specialDietGroups",
            "label": "Special diet groups",
            "description": "Description of sub-population with special diets (vegetarians, diabetics, group following special ethnic diets)"
          }],
          "hazard": [{
            "id": "maximumResidueLimit",
            "label": "Maximum Residue Limit (MRL)",
            "type": "text",
            "description": "International regulations and permissible maximum residue levels in food and drinking water"
          }, {
            "id": "sourceOfContamination",
            "label": "Source of contamination",
            "type": "text",
            "description": "rigin of the contamination, source"
          }, {
            "id": "indSum",
            "label": "Individual or Summed Hazard",
            "type": "text",
            "description": "Define if the parameter reported is an individual residue/analyte, a summed residue definition or part of a sum a summed residue definition"
          }, {
            "id": "acceptableOperatorsExposureLevel",
            "label": "Acceptable Operator Exposure Level (AOEL)",
            "type": "text",
            "description": "Maximum amount of active substance to which the operator may be exposed without any adverse health effects. The AOEL is expressed as milligrams of the chemical per kilogram body weight of the operator"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Description of the hazard for which the model or data applies"
          }, {
            "id": "type",
            "label": "Hazard type",
            "type": "text",
            "description": "General classification of the hazard for which the model or data applies"
          }, {
            "id": "adverseEffect",
            "label": "Adverse effect",
            "type": "text",
            "description": "Adverse effect induced by hazard about morbidity, mortality, and etcetera"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the hazard for which the model or data applies"
          }, {
            "id": "noObservedAdverseAffectLevel",
            "label": "No Observed Adverse Affect Level (NOAEL)",
            "type": "text",
            "description": "Level of exposure of an organism, found by experiment or observation, at which there is no biologically or statistically significant increase in the frequency or severity of any adverse effects in the exposed population when compared to its appropriate control"
          }, {
            "id": "acuteReferenceDose",
            "label": "Acute Reference Dose (ARfD)",
            "type": "text",
            "description": "An estimate (with uncertainty spanning perhaps an order of magnitude) of a daily oral exposure for an acute duration (24 hours or less) to the human population (including sensitive subgroups) that is likely to be without an appreciable risk of deleterious effects during a lifetime"
          }, {
            "id": "name",
            "label": "Hazard name",
            "type": "text",
            "description": "Name of the hazard (agent, contaminant, chemical) for which the data or model applies"
          }, {
            "id": "lowestObservedAdverseAffectLevel",
            "label": "Lowest Observed Adverse Effect Level (LOAEL)",
            "type": "text",
            "description": "Lowest concentration or amount of a substance found by experiment or observation that causes an adverse alteration of morphology, function, capacity, growth, development, or lifespan of a target organism distinguished from normal organisms of the same species under defined conditions of exposure"
          }, {
            "id": "benchmarkDose",
            "label": "Benchmark Dose (BMD)",
            "type": "text",
            "description": "A dose or concentration that produces a predetermined change in response rate of an adverse effect (called the benchmark response or BMR) compared to background"
          }, {
            "id": "acceptableDailyIntake",
            "label": "Acceptable Daily Intake (ADI)",
            "type": "text",
            "description": "Measure of amount of a specific substance in food or in drinking water tahta can be ingested (orally) on a daily basis over a lifetime without an appreciable health risk"
          }],
          "scope": [{
            "id": "spatialInformation",
            "label": "Spatial information",
            "description": "Spatial information (area) on which the model or data applies"
          }, {
            "id": "generalComment",
            "label": "General comment",
            "type": "long-text",
            "description": "General comments on the scope of the study, data or model"
          }, {
            "id": "temporalInformation",
            "label": "Temporal information",
            "type": "long-text",
            "description": "Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)"
          }]
        },
        "generalInformation": {
          "creator": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "author": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "reference": [{
            "id": "date",
            "label": "Date",
            "type": "year_date",
            "description": "Temporal information on the publication date"
          }, {
            "id": "website",
            "label": "Website",
            "type": "text",
            "description": "A link to the publication website (different from DOI)"
          }, {
            "id": "issue",
            "label": "Issue",
            "type": "text",
            "description": "Data on the details of the issue in which the model or date has been described"
          }, {
            "id": "publicationType",
            "label": "Publication type",
            "type": "text",
            "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
          }, {
            "id": "abstract",
            "label": "Abstract",
            "type": "text",
            "description": "Abstract of the publication in which the model or the data has been described "
          }, {
            "id": "isReferenceDescription",
            "label": "Is_reference_description?",
            "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
          }, {
            "id": "title",
            "label": "Title",
            "type": "long-text",
            "description": "Title of publication in which the model or date has been described"
          }, {
            "id": "pmid",
            "label": "PubMed ID",
            "type": "text",
            "description": "The PubMed ID related to this publication"
          }, {
            "id": "volume",
            "label": "Volume",
            "type": "text",
            "description": "Data on the details of the volume in which the model or date has been described"
          }, {
            "id": "journal",
            "label": "Journal",
            "type": "long-text",
            "description": "Data on the details of the journal in which the model or date has been described"
          }, {
            "id": "authorList",
            "label": "Author list",
            "type": "long-text",
            "description": "Name and surname of the authors who contributed to this publication"
          }, {
            "id": "comment",
            "label": "Comment",
            "type": "long-text",
            "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
          }, {
            "id": "doi",
            "label": "Publication DOI",
            "type": "long-text",
            "description": "The DOI related to this publication"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The status of this publication, e.g. Published, Submitted, etc."
          }],
          "modelCategory": [{
            "id": "modelClassComment",
            "label": "Comment",
            "type": "long-text",
            "description": "Comment with further details on the model class"
          }, {
            "id": "basicProcess",
            "label": "Basic process",
            "description": "Defines the impact of the process on the hazard (so far only valid for process models and predictive models)"
          }, {
            "id": "modelClass",
            "label": "Model class",
            "type": "text",
            "description": "Type of model according to RAKIP classification"
          }, {
            "id": "modelSubClass",
            "label": "Subclass",
            "description": "Sub-classification of the model given the Model Class"
          }],
          "generalInformation": [{
            "id": "identifier",
            "label": "Identifier",
            "type": "text",
            "description": "An unambiguous ID given to the model or data. This can also be created automatically by a software tool"
          }, {
            "id": "software",
            "label": "Software",
            "type": "text",
            "description": "The program or software language in which the model has been implemented"
          }, {
            "id": "format",
            "label": "Format",
            "type": "text",
            "description": "File extension of the model or data file (including version number of format if applicable)"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the study, data or model"
          }, {
            "id": "language",
            "label": "Language",
            "type": "text",
            "description": "A language of the resource (some data or reports can be available in French language for example)"
          }, {
            "id": "source",
            "label": "Source",
            "type": "text",
            "description": "A source from which the model/data is derived"
          }, {
            "id": "availability",
            "label": "Availability",
            "type": "text",
            "description": "Availability of data or model, i.e. if the annotated model code / data is included in this FSK file"
          }, {
            "id": "creationDate",
            "label": "Creation date",
            "type": "date",
            "description": "Creation date/time of the FSK file"
          }, {
            "id": "url",
            "label": "URL",
            "type": "text",
            "description": "Web address referencing the resource location (data for example)"
          }, {
            "id": "objective",
            "label": "Objective",
            "type": "long-text",
            "description": "Objective of the model or data"
          }, {
            "id": "modificationDate",
            "label": "Modification date",
            "description": "Date/time of the last version of the FSK file"
          }, {
            "id": "rights",
            "label": "Rights",
            "type": "text",
            "description": "Rights granted for usage, distribution and modification of this FSK file"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "A name given to the model or data"
          }, {
            "id": "languageWrittenIn",
            "label": "Language written in",
            "type": "text",
            "description": "Software language used to write the model, e.g. R or MatLab"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The curation status of the model"
          }]
        }
      };
    }
    // Validate this.panels and return boolean
  }, {
    key: "validate",
    value: function validate() {
      var isValid = true;
      if (!this.panels.generalInformation.validate()) isValid = false;
      if (!this.panels.modelCategory.validate()) isValid = false;
      if (!this.panels.scopeGeneral.validate()) isValid = false;
      if (!this.panels.study.validate()) isValid = false;
      return isValid;
    }
  }, {
    key: "_createPanels",
    value: function _createPanels() {
      var _ref;
      var port = window.port || -1;
      var schema = schemas.genericModel;
      return _ref = {
        study: new _FormPanel.FormPanel("Study", this.jsonSchema.dataBackground.study, this._metadata.dataBackground ? this._metadata.dataBackground.study : {}, port),
        laboratory: new _TablePanel.TablePanel("Laboratory", this.jsonSchema.dataBackground.laboratory, this._metadata.dataBackground ? this._metadata.dataBackground.laboratory : {}, port),
        assay: new _TablePanel.TablePanel("Assay", this.jsonSchema.dataBackground.assay, this._metadata.dataBackground ? this._metadata.dataBackground.assay : {}, port),
        dietaryAssessmentMethod: new _TablePanel.TablePanel("Dietary Assessment Method", this.jsonSchema.dataBackground.dietaryAssessmentMethod, this._metadata.dataBackground ? this._metadata.dataBackground.dietaryAssessmentMethod : {}, port),
        studySample: new _TablePanel.TablePanel("Study Sample", this.jsonSchema.dataBackground.studySample, this._metadata.dataBackground ? this._metadata.dataBackground.studySample : {}, port),
        modelMath: new _FormPanel.FormPanel("Model Math", this.jsonSchema.modelMath.modelMath, this._metadata.modelMath, port),
        modelEquation: new _TablePanel.TablePanel("Model Equation", this.jsonSchema.modelMath.modelEquation.modelEquation, this._metadata.modelMath ? this._metadata.modelMath.modelEquation : {}, port),
        reference: new _TablePanel.TablePanel("Reference", this.jsonSchema.modelMath.modelEquation.reference, this._metadata.modelMath.modelEquation ? this._metadata.modelMath.modelEquation.reference : {}, port),
        exposure: new _TablePanel.TablePanel("Exposure", this.jsonSchema.modelMath.exposure, this._metadata.modelMath ? this._metadata.modelMath.exposure : {}, port),
        parameter: new _TablePanel.TablePanel("Parameter", this.jsonSchema.modelMath.parameter.parameter, this._metadata.modelMath ? this._metadata.modelMath.parameter : {}, port)
      }, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref, "reference", new _FormPanel.FormPanel("Reference", this.jsonSchema.modelMath.parameter.reference, this._metadata.modelMath.parameter ? this._metadata.modelMath.parameter.reference : {}, port)), "qualityMeasures", new _TablePanel.TablePanel("Quality Measures", this.jsonSchema.modelMath.qualityMeasures, this._metadata.modelMath ? this._metadata.modelMath.qualityMeasures : {}, port)), "scope", new _FormPanel.FormPanel("Scope", this.jsonSchema.scope.scope, this._metadata.scope, port)), "product", new _TablePanel.TablePanel("Product", this.jsonSchema.scope.product, this._metadata.scope ? this._metadata.scope.product : {}, port)), "populationGroup", new _TablePanel.TablePanel("Population Group", this.jsonSchema.scope.populationGroup, this._metadata.scope ? this._metadata.scope.populationGroup : {}, port)), "hazard", new _TablePanel.TablePanel("Hazard", this.jsonSchema.scope.hazard, this._metadata.scope ? this._metadata.scope.hazard : {}, port)), "generalInformation", new _FormPanel.FormPanel("General Information", this.jsonSchema.generalInformation.generalInformation, this._metadata.generalInformation, port)), "creator", new _TablePanel.TablePanel("Creator", this.jsonSchema.generalInformation.creator, this._metadata.generalInformation ? this._metadata.generalInformation.creator : {}, port)), "author", new _TablePanel.TablePanel("Author", this.jsonSchema.generalInformation.author, this._metadata.generalInformation ? this._metadata.generalInformation.author : {}, port)), "reference", new _TablePanel.TablePanel("Reference", this.jsonSchema.generalInformation.reference, this._metadata.generalInformation ? this._metadata.generalInformation.reference : {}, port)), _defineProperty(_ref, "modelCategory", new _FormPanel.FormPanel("Model Category", this.jsonSchema.generalInformation.modelCategory, this._metadata.generalInformation ? this._metadata.generalInformation.modelCategory : {}, port));
    }
  }]);
}(_ModelView2.ModelView);

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./ExposureModelScopeView":92,"./GenericModelDataBackgroundView":97,"./GenericModelModelMathView":101,"./ModelView":118,"./PredictiveModelGeneralInformationView":137}],153:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QualityMeasures = void 0;
var _ApiClient = require("../ApiClient");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The QualityMeasures model module.
 * @module model/QualityMeasures
 * @version 1.0.0
 */
var QualityMeasures = exports.QualityMeasures = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>QualityMeasures</code>.
   * @alias module:model/QualityMeasures
   * @class
   */
  function QualityMeasures() {
    _classCallCheck(this, QualityMeasures);
  }

  /**
   * Constructs a <code>QualityMeasures</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/QualityMeasures} obj Optional instance to populate.
   * @return {module:model/QualityMeasures} The populated <code>QualityMeasures</code> instance.
   */
  return _createClass(QualityMeasures, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new QualityMeasures();
        if (data.hasOwnProperty('rsquared')) obj.rsquared = _ApiClient.ApiClient.convertToType(data['rsquared'], 'Number');
        if (data.hasOwnProperty('sse')) obj.sse = _ApiClient.ApiClient.convertToType(data['sse'], 'Number');
        if (data.hasOwnProperty('rmse')) obj.rmse = _ApiClient.ApiClient.convertToType(data['rmse'], 'Number');
        if (data.hasOwnProperty('aic')) obj.aic = _ApiClient.ApiClient.convertToType(data['aic'], 'Number');
        if (data.hasOwnProperty('sensitivityAnalysis')) obj.sensitivityAnalysis = _ApiClient.ApiClient.convertToType(data['sensitivityAnalysis'], 'String');
        if (data.hasOwnProperty('bic')) obj.bic = _ApiClient.ApiClient.convertToType(data['bic'], 'Number');
        if (data.hasOwnProperty('mse')) obj.mse = _ApiClient.ApiClient.convertToType(data['mse'], 'Number');
      }
      return obj;
    }
  }]);
}();
/**
 * Statistical values calculated to describe the performance of the model fitting procedure
 * @member {Number} rsquared
 */
QualityMeasures.prototype.rsquared = undefined;

/**
 * Statistical values calculated to describe the performance of the model fitting procedure
 * @member {Number} sse
 */
QualityMeasures.prototype.sse = undefined;

/**
 * Statistical values calculated to describe the performance of the model fitting procedure
 * @member {Number} rmse
 */
QualityMeasures.prototype.rmse = undefined;

/**
 * Statistical values calculated to describe the performance of the model fitting procedure
 * @member {Number} aic
 */
QualityMeasures.prototype.aic = undefined;

/**
 * Description of the results of an sensitivity analysis, i.e. how independence assumptions are met or how variables will affect the output of model
 * @member {String} sensitivityAnalysis
 */
QualityMeasures.prototype.sensitivityAnalysis = undefined;

/**
 * Statistical values calculated to describe the performance of the model fitting procedure
 * @member {Number} bic
 */
QualityMeasures.prototype.bic = undefined;

/**
 * Statistical values calculated to describe the performance of the model fitting procedure
 * @member {Number} mse
 */
QualityMeasures.prototype.mse = undefined;

},{"../ApiClient":44}],154:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QualityMeasuresView = void 0;
var _ApiClient = require("../ApiClient");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The QualityMeasures View  module.
 * @module model/QualityMeasures
 * @version 1.0.0
 */
var QualityMeasuresView = exports.QualityMeasuresView = /*#__PURE__*/_createClass(function QualityMeasuresView() {
  _classCallCheck(this, QualityMeasuresView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63}],155:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Reference = void 0;
var _ApiClient = require("../ApiClient");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Reference model module.
 * @module model/Reference
 * @version 1.0.0
 */
var Reference = exports.Reference = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>Reference</code>.
   * @alias module:model/Reference
   * @class
   * @param isReferenceDescription {} Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'
   * @param title {} Title of publication in which the model or date has been described
   * @param doi {} The DOI related to this publication
   */
  function Reference(isReferenceDescriptiontitledoi) {
    _classCallCheck(this, Reference);
    this.isReferenceDescription = isReferenceDescription;
    this.title = title;
    this.doi = doi;
  }

  /**
   * Constructs a <code>Reference</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/Reference} obj Optional instance to populate.
   * @return {module:model/Reference} The populated <code>Reference</code> instance.
   */
  return _createClass(Reference, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new Reference();
        if (data.hasOwnProperty('date')) obj._date = _ApiClient.ApiClient.convertToType(data['date'], 'String');
        if (data.hasOwnProperty('website')) obj.website = _ApiClient.ApiClient.convertToType(data['website'], 'String');
        if (data.hasOwnProperty('issue')) obj.issue = _ApiClient.ApiClient.convertToType(data['issue'], 'String');
        if (data.hasOwnProperty('publicationType')) obj.publicationType = _ApiClient.ApiClient.convertToType(data['publicationType'], 'String');
        if (data.hasOwnProperty('abstract')) obj._abstract = _ApiClient.ApiClient.convertToType(data['abstract'], 'String');
        if (data.hasOwnProperty('isReferenceDescription')) obj.isReferenceDescription = _ApiClient.ApiClient.convertToType(data['isReferenceDescription'], 'Boolean');
        if (data.hasOwnProperty('title')) obj.title = _ApiClient.ApiClient.convertToType(data['title'], 'String');
        if (data.hasOwnProperty('pmid')) obj.pmid = _ApiClient.ApiClient.convertToType(data['pmid'], 'String');
        if (data.hasOwnProperty('volume')) obj.volume = _ApiClient.ApiClient.convertToType(data['volume'], 'String');
        if (data.hasOwnProperty('journal')) obj.journal = _ApiClient.ApiClient.convertToType(data['journal'], 'String');
        if (data.hasOwnProperty('authorList')) obj.authorList = _ApiClient.ApiClient.convertToType(data['authorList'], 'String');
        if (data.hasOwnProperty('comment')) obj.comment = _ApiClient.ApiClient.convertToType(data['comment'], 'String');
        if (data.hasOwnProperty('doi')) obj.doi = _ApiClient.ApiClient.convertToType(data['doi'], 'String');
        if (data.hasOwnProperty('status')) obj.status = _ApiClient.ApiClient.convertToType(data['status'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * Temporal information on the publication date
 * @member {String} _date
 */
Reference.prototype._date = undefined;

/**
 * A link to the publication website (different from DOI)
 * @member {String} website
 */
Reference.prototype.website = undefined;

/**
 * Data on the details of the issue in which the model or date has been described
 * @member {String} issue
 */
Reference.prototype.issue = undefined;

/**
 * Allowed values for the <code>publicationType</code> property.
 * @enum {String}
 * @readonly
 */
Reference.PublicationTypeEnum = {
  /**
   * value: "ABST"
   * @const
   */
  ABST: "ABST",
  /**
   * value: "ADVS"
   * @const
   */
  ADVS: "ADVS",
  /**
   * value: "AGGR"
   * @const
   */
  AGGR: "AGGR",
  /**
   * value: "ANCIENT"
   * @const
   */
  ANCIENT: "ANCIENT",
  /**
   * value: "ART"
   * @const
   */
  ART: "ART",
  /**
   * value: "BILL"
   * @const
   */
  BILL: "BILL",
  /**
   * value: "BLOG"
   * @const
   */
  BLOG: "BLOG",
  /**
   * value: "BOOK"
   * @const
   */
  BOOK: "BOOK",
  /**
   * value: "CASE"
   * @const
   */
  CASE: "CASE",
  /**
   * value: "CHAP"
   * @const
   */
  CHAP: "CHAP",
  /**
   * value: "CHART"
   * @const
   */
  CHART: "CHART",
  /**
   * value: "CLSWK"
   * @const
   */
  CLSWK: "CLSWK",
  /**
   * value: "COMP"
   * @const
   */
  COMP: "COMP",
  /**
   * value: "CONF"
   * @const
   */
  CONF: "CONF",
  /**
   * value: "CPAPER"
   * @const
   */
  CPAPER: "CPAPER",
  /**
   * value: "CTLG"
   * @const
   */
  CTLG: "CTLG",
  /**
   * value: "DATA"
   * @const
   */
  DATA: "DATA",
  /**
   * value: "DBASE"
   * @const
   */
  DBASE: "DBASE",
  /**
   * value: "DICT"
   * @const
   */
  DICT: "DICT",
  /**
   * value: "EBOOK"
   * @const
   */
  EBOOK: "EBOOK",
  /**
   * value: "ECHAP"
   * @const
   */
  ECHAP: "ECHAP",
  /**
   * value: "EDBOOK"
   * @const
   */
  EDBOOK: "EDBOOK",
  /**
   * value: "EJOUR"
   * @const
   */
  EJOUR: "EJOUR",
  /**
   * value: "ELECT"
   * @const
   */
  ELECT: "ELECT",
  /**
   * value: "ENCYC"
   * @const
   */
  ENCYC: "ENCYC",
  /**
   * value: "EQUA"
   * @const
   */
  EQUA: "EQUA",
  /**
   * value: "FIGURE"
   * @const
   */
  FIGURE: "FIGURE",
  /**
   * value: "GEN"
   * @const
   */
  GEN: "GEN",
  /**
   * value: "GOVDOC"
   * @const
   */
  GOVDOC: "GOVDOC",
  /**
   * value: "GRANT"
   * @const
   */
  GRANT: "GRANT",
  /**
   * value: "HEAR"
   * @const
   */
  HEAR: "HEAR",
  /**
   * value: "ICOMM"
   * @const
   */
  ICOMM: "ICOMM",
  /**
   * value: "INPR"
   * @const
   */
  INPR: "INPR",
  /**
   * value: "JOUR"
   * @const
   */
  JOUR: "JOUR",
  /**
   * value: "JFULL"
   * @const
   */
  JFULL: "JFULL",
  /**
   * value: "LEGAL"
   * @const
   */
  LEGAL: "LEGAL",
  /**
   * value: "MANSCPT"
   * @const
   */
  MANSCPT: "MANSCPT",
  /**
   * value: "MAP"
   * @const
   */
  MAP: "MAP",
  /**
   * value: "MGZN"
   * @const
   */
  MGZN: "MGZN",
  /**
   * value: "MPCT"
   * @const
   */
  MPCT: "MPCT",
  /**
   * value: "MULTI"
   * @const
   */
  MULTI: "MULTI",
  /**
   * value: "MUSIC"
   * @const
   */
  MUSIC: "MUSIC",
  /**
   * value: "NEW"
   * @const
   */
  NEW: "NEW",
  /**
   * value: "PAMP"
   * @const
   */
  PAMP: "PAMP",
  /**
   * value: "PAT"
   * @const
   */
  PAT: "PAT",
  /**
   * value: "PCOMM"
   * @const
   */
  PCOMM: "PCOMM",
  /**
   * value: "RPRT"
   * @const
   */
  RPRT: "RPRT",
  /**
   * value: "SER"
   * @const
   */
  SER: "SER",
  /**
   * value: "SLIDE"
   * @const
   */
  SLIDE: "SLIDE",
  /**
   * value: "SOUND"
   * @const
   */
  SOUND: "SOUND",
  /**
   * value: "STAND"
   * @const
   */
  STAND: "STAND",
  /**
   * value: "STAT"
   * @const
   */
  STAT: "STAT",
  /**
   * value: "THES"
   * @const
   */
  THES: "THES",
  /**
   * value: "UNPB"
   * @const
   */
  UNPB: "UNPB",
  /**
   * value: "VIDEO"
   * @const
   */
  VIDEO: "VIDEO"
};
/**
 * The type of publication, e.g. Report, Journal article, Book, Online database, ... 
 * @member {module:model/Reference.PublicationTypeEnum} publicationType
 */
Reference.prototype.publicationType = undefined;

/**
 * Abstract of the publication in which the model or the data has been described 
 * @member {String} _abstract
 */
Reference.prototype._abstract = undefined;

/**
 * Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'
 * @member {Boolean} isReferenceDescription
 */
Reference.prototype.isReferenceDescription = undefined;

/**
 * Title of publication in which the model or date has been described
 * @member {String} title
 */
Reference.prototype.title = undefined;

/**
 * The PubMed ID related to this publication
 * @member {String} pmid
 */
Reference.prototype.pmid = undefined;

/**
 * Data on the details of the volume in which the model or date has been described
 * @member {String} volume
 */
Reference.prototype.volume = undefined;

/**
 * Data on the details of the journal in which the model or date has been described
 * @member {String} journal
 */
Reference.prototype.journal = undefined;

/**
 * Name and surname of the authors who contributed to this publication
 * @member {String} authorList
 */
Reference.prototype.authorList = undefined;

/**
 * Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script
 * @member {String} comment
 */
Reference.prototype.comment = undefined;

/**
 * The DOI related to this publication
 * @member {String} doi
 */
Reference.prototype.doi = undefined;

/**
 * The status of this publication, e.g. Published, Submitted, etc.
 * @member {String} status
 */
Reference.prototype.status = undefined;

},{"../ApiClient":44}],156:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReferenceView = void 0;
var _ApiClient = require("../ApiClient");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Reference View  module.
 * @module model/Reference
 * @version 1.0.0
 */
var ReferenceView = exports.ReferenceView = /*#__PURE__*/_createClass(function ReferenceView() {
  _classCallCheck(this, ReferenceView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63}],157:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RiskModel = void 0;
var _ApiClient = require("../ApiClient");
var _ExposureModelScope = require("./ExposureModelScope");
var _GenericModelDataBackground = require("./GenericModelDataBackground");
var _GenericModelModelMath = require("./GenericModelModelMath");
var _Model2 = require("./Model");
var _PredictiveModelGeneralInformation = require("./PredictiveModelGeneralInformation");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The RiskModel model module.
 * @module model/RiskModel
 * @version 1.0.0
 */
var RiskModel = exports.RiskModel = /*#__PURE__*/function (_Model) {
  /**
   * Constructs a new <code>RiskModel</code>.
   * @alias module:model/RiskModel
   * @class
   * @extends module:model/Model
   * @param modelType {} 
   */
  function RiskModel(modelType) {
    _classCallCheck(this, RiskModel);
    return _callSuper(this, RiskModel, [modelType]);
  }

  /**
   * Constructs a <code>RiskModel</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/RiskModel} obj Optional instance to populate.
   * @return {module:model/RiskModel} The populated <code>RiskModel</code> instance.
   */
  _inherits(RiskModel, _Model);
  return _createClass(RiskModel, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new RiskModel();
        _Model2.Model.constructFromObject(data, obj);
        if (data.hasOwnProperty('dataBackground')) obj.dataBackground = _GenericModelDataBackground.GenericModelDataBackground.constructFromObject(data['dataBackground']);
        if (data.hasOwnProperty('modelMath')) obj.modelMath = _GenericModelModelMath.GenericModelModelMath.constructFromObject(data['modelMath']);
        if (data.hasOwnProperty('scope')) obj.scope = _ExposureModelScope.ExposureModelScope.constructFromObject(data['scope']);
        if (data.hasOwnProperty('generalInformation')) obj.generalInformation = _PredictiveModelGeneralInformation.PredictiveModelGeneralInformation.constructFromObject(data['generalInformation']);
      }
      return obj;
    }
  }]);
}(_Model2.Model);
/**
 * @member {module:model/GenericModelDataBackground} dataBackground
 */
RiskModel.prototype.dataBackground = undefined;

/**
 * @member {module:model/GenericModelModelMath} modelMath
 */
RiskModel.prototype.modelMath = undefined;

/**
 * @member {module:model/ExposureModelScope} scope
 */
RiskModel.prototype.scope = undefined;

/**
 * @member {module:model/PredictiveModelGeneralInformation} generalInformation
 */
RiskModel.prototype.generalInformation = undefined;

},{"../ApiClient":44,"./ExposureModelScope":91,"./GenericModelDataBackground":96,"./GenericModelModelMath":100,"./Model":113,"./PredictiveModelGeneralInformation":136}],158:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RiskModelView = void 0;
var _ApiClient = require("../ApiClient");
var _ExposureModelScopeView = require("./ExposureModelScopeView");
var _GenericModelDataBackgroundView = require("./GenericModelDataBackgroundView");
var _GenericModelModelMathView = require("./GenericModelModelMathView");
var _ModelView2 = require("./ModelView");
var _PredictiveModelGeneralInformationView = require("./PredictiveModelGeneralInformationView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The RiskModel View  module.
 * @module model/RiskModel
 * @version 1.0.0
 */
var RiskModelView = exports.RiskModelView = /*#__PURE__*/function (_ModelView) {
  function RiskModelView(metadata, img, state, modelScript, visScript, readme) {
    var _this$_panels;
    var _this;
    _classCallCheck(this, RiskModelView);
    _this = _callSuper(this, RiskModelView, [metadata, img, modelScript, visScript, readme]);
    _this._schema = schemas.genericModel;
    if (state) {
      _this.panels = _this._createPanels();
    }
    _this._menu = [{
      "label": "General Information",
      "id": "generalInformation",
      "submenus": [{
        "label": "General Information",
        "id": "generalInformation"
      }, {
        "label": "Model Category",
        "id": "modelCategory"
      }, {
        "label": "Reference",
        "id": "reference"
      }, {
        "label": "Author",
        "id": "author"
      }, {
        "label": "Creator",
        "id": "creator"
      }]
    }, {
      "label": "Scope",
      "id": "scope",
      "submenus": [{
        "label": "Scope",
        "id": "scope"
      }, {
        "label": "Hazard",
        "id": "hazard"
      }, {
        "label": "Population Group",
        "id": "populationGroup"
      }, {
        "label": "Product",
        "id": "product"
      }]
    }, {
      "label": "Model Math",
      "id": "modelMath",
      "submenus": [{
        "label": "Model Math",
        "id": "modelMath"
      }, {
        "label": "Quality Measures",
        "id": "qualityMeasures"
      }, {
        "label": "Parameter",
        "id": "parameter",
        "submenus": [{
          "label": "Parameter",
          "id": "parameter"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }, {
        "label": "Exposure",
        "id": "exposure"
      }, {
        "label": "Model Equation",
        "id": "modelEquation",
        "submenus": [{
          "label": "Model Equation",
          "id": "modelEquation"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }]
    }, {
      "label": "Data Background",
      "id": "dataBackground",
      "submenus": [{
        "label": "Study Sample",
        "id": "studySample"
      }, {
        "label": "Dietary Assessment Method",
        "id": "dietaryAssessmentMethod"
      }, {
        "label": "Assay",
        "id": "assay"
      }, {
        "label": "Laboratory",
        "id": "laboratory"
      }, {
        "label": "Study",
        "id": "study"
      }]
    }];
    _this._panels = (_this$_panels = {
      study: {
        type: 'simple',
        schema: _this.jsonSchema.dataBackgroundstudy,
        metadata: _this._metadata.study
      },
      laboratory: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundlaboratory,
        metadata: _this._metadata.laboratory
      },
      assay: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundassay,
        metadata: _this._metadata.assay
      },
      dietaryAssessmentMethod: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgrounddietaryAssessmentMethod,
        metadata: _this._metadata.dietaryAssessmentMethod
      },
      studySample: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundstudySample,
        metadata: _this._metadata.studySample
      },
      modelMath: {
        type: 'simple',
        schema: _this.jsonSchema.modelMathmodelMath,
        metadata: _this._metadata.modelMath
      },
      modelEquation: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationmodelEquation,
        metadata: _this._metadata.modelEquation
      },
      reference: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationreference,
        metadata: _this._metadata.reference
      },
      exposure: {
        type: 'complex',
        schema: _this.jsonSchema.modelMathexposure,
        metadata: _this._metadata.exposure
      },
      parameter: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.parameterparameter,
        metadata: _this._metadata.parameter
      }
    }, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_this$_panels, "reference", {
      type: 'simple',
      schema: _this.jsonSchema.modelMath.parameterreference,
      metadata: _this._metadata.reference
    }), "qualityMeasures", {
      type: 'complex',
      schema: _this.jsonSchema.modelMathqualityMeasures,
      metadata: _this._metadata.qualityMeasures
    }), "scope", {
      type: 'simple',
      schema: _this.jsonSchema.scopescope,
      metadata: _this._metadata.scope
    }), "product", {
      type: 'complex',
      schema: _this.jsonSchema.scopeproduct,
      metadata: _this._metadata.product
    }), "populationGroup", {
      type: 'complex',
      schema: _this.jsonSchema.scopepopulationGroup,
      metadata: _this._metadata.populationGroup
    }), "hazard", {
      type: 'complex',
      schema: _this.jsonSchema.scopehazard,
      metadata: _this._metadata.hazard
    }), "generalInformation", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationgeneralInformation,
      metadata: _this._metadata.generalInformation
    }), "creator", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationcreator,
      metadata: _this._metadata.creator
    }), "author", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationauthor,
      metadata: _this._metadata.author
    }), "reference", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationreference,
      metadata: _this._metadata.reference
    }), _defineProperty(_this$_panels, "modelCategory", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationmodelCategory,
      metadata: _this._metadata.modelCategory
    }));
    return _this;
  }
  _inherits(RiskModelView, _ModelView);
  return _createClass(RiskModelView, [{
    key: "metaData",
    get: function get() {
      try {
        this._metadata.dataBackground.study = this.panels.study.data;
        this._metadata.dataBackground.laboratory = this.panels.laboratory.data;
        this._metadata.dataBackground.assay = this.panels.assay.data;
        this._metadata.dataBackground.dietaryAssessmentMethod = this.panels.dietaryAssessmentMethod.data;
        this._metadata.dataBackground.studySample = this.panels.studySample.data;
        this._metadata.modelMath = this.panels.modelMath.data;
        this._metadata.modelMath.modelEquation = this.panels.modelEquation.data;
        this._metadata.modelMath.modelEquation.reference = this.panels.reference.data;
        this._metadata.modelMath.exposure = this.panels.exposure.data;
        this._metadata.modelMath.parameter = this.panels.parameter.data;
        this._metadata.modelMath.parameter.reference = this.panels.reference.data;
        this._metadata.modelMath.qualityMeasures = this.panels.qualityMeasures.data;
        this._metadata.scope = this.panels.scope.data;
        this._metadata.scope.product = this.panels.product.data;
        this._metadata.scope.populationGroup = this.panels.populationGroup.data;
        this._metadata.scope.hazard = this.panels.hazard.data;
        this._metadata.generalInformation = this.panels.generalInformation.data;
        this._metadata.generalInformation.creator = this.panels.creator.data;
        this._metadata.generalInformation.author = this.panels.author.data;
        this._metadata.generalInformation.reference = this.panels.reference.data;
        this._metadata.generalInformation.modelCategory = this.panels.modelCategory.data;
        this._metadata.modelType = "RiskModel";
        this._metadata = metadataFix(this._metadata);
      } catch (error) {
        console.log(error);
      }
      return this._metadata;
    }
  }, {
    key: "jsonSchema",
    get: function get() {
      return {
        "dataBackground": {
          "study": [{
            "id": "identifier",
            "label": "Study identifier",
            "type": "text",
            "description": "A user defined identifier for the study"
          }, {
            "id": "protocolComponentsName",
            "label": "Components names",
            "type": "text",
            "description": "The names of the components used when carrying out this protocol"
          }, {
            "id": "designType",
            "label": "Design type",
            "type": "text",
            "description": "The type of study design being employed"
          }, {
            "id": "assayMeasurementType",
            "label": "Assay measurement type",
            "type": "text",
            "description": "The measurement being observed in this assay"
          }, {
            "id": "protocolComponentsType",
            "label": "Protocol components type",
            "type": "text",
            "description": "Description"
          }, {
            "id": "description",
            "label": "Study description",
            "type": "long-text",
            "description": "A brief description of the study aims"
          }, {
            "id": "assayTechnologyPlatform",
            "label": "Assay technology platform",
            "type": "text",
            "description": "The technology platform used"
          }, {
            "id": "assayTechnologyType",
            "label": "Assay technology type",
            "type": "text",
            "description": "The technology being employed to observe this measurement"
          }, {
            "id": "protocolType",
            "label": "Protocol type",
            "type": "text",
            "description": "The type of the protocol, preferably coming from an Ontology, e.g. Extraction Protocol"
          }, {
            "id": "title",
            "label": "Study title",
            "type": "long-text",
            "description": "A title for the study"
          }, {
            "id": "protocolDescription",
            "label": "Protocol description",
            "type": "long-text",
            "description": "A description of the protocol"
          }, {
            "id": "protocolParametersName",
            "label": "Parameters names",
            "type": "text",
            "description": "The parameters used when executing this protocol"
          }, {
            "id": "protocolName",
            "label": "Protocol name",
            "type": "text",
            "description": "The name of the protocol, e.g.Extraction Protocol"
          }, {
            "id": "protocolVersion",
            "label": "Protocol version",
            "type": "text",
            "description": "The version of the protocol used, where applicable."
          }, {
            "id": "protocolURI",
            "label": "Protocol URI",
            "type": "text",
            "description": "A URI to link out to a publication, web page, etc. describing the protocol"
          }, {
            "id": "accreditationProcedureForTheAssayTechnology",
            "label": "Accreditation procedure for assay",
            "type": "text",
            "description": "Accreditation procedure for the analytical method used"
          }],
          "laboratory": [{
            "id": "country",
            "label": "Laboratory country",
            "type": "text",
            "description": "Country where the laboratory is placed. (ISO 3166-1-alpha-2)"
          }, {
            "id": "name",
            "label": "Laboratory name",
            "type": "text",
            "description": "Laboratory code (National laboratory code if available) or Laboratory name "
          }, {
            "id": "accreditation",
            "label": "Laboratory accreditation",
            "description": "The laboratory accreditation to ISO/IEC 17025"
          }],
          "assay": [{
            "id": "contaminationRange",
            "label": "Range of contamination",
            "type": "text",
            "description": "Range of result of the analytical measure reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "uncertaintyValue",
            "label": "Uncertainty value",
            "type": "text",
            "description": "Indicate the expanded uncertainty (usually 95% confidence interval) value associated with the measurement expressed in the unit reported in the field Hazard unit"
          }, {
            "id": "fatPercentage",
            "label": "Percentage of fat",
            "type": "text",
            "description": "Percentage of fat in the original sample"
          }, {
            "id": "name",
            "label": "Assay name",
            "type": "text",
            "description": "A name given to the assay"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the assay. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "moisturePercentage",
            "label": "Percentage of moisture",
            "type": "text",
            "description": "Percentage of moisture in the original sample"
          }, {
            "id": "leftCensoredData",
            "label": "Left-censored data",
            "type": "text",
            "description": "Percentage of measures equal to LOQ and/or LOD"
          }, {
            "id": "detectionLimit",
            "label": "Limit of detection",
            "type": "text",
            "description": "Limit of detection reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "quantificationLimit",
            "label": "Limit of quantification",
            "type": "text",
            "description": "Limit of quantification reported in the unit specified by the variable Hazard unit"
          }],
          "dietaryAssessmentMethod": [{
            "id": "recordTypes",
            "label": "Type of records",
            "description": "Consumption occasion, mean of consumption, quantified and described as eaten, recipes for self-made"
          }, {
            "id": "numberOfFoodItems",
            "label": "Number of food items",
            "description": "Number of food items"
          }, {
            "id": "numberOfNonConsecutiveOneDay",
            "label": "Number of non-consecutive one-day",
            "type": "text",
            "description": "Number of non-consecutive one-day recorded"
          }, {
            "id": "softwareTool",
            "label": "Dietary software tool",
            "type": "text",
            "description": "Name of the software used to collect the data"
          }, {
            "id": "foodDescriptors",
            "label": "Food descriptors",
            "description": "Description using FoodEx2 facet"
          }, {
            "id": "collectionTool",
            "label": "Methodological tool to collect data",
            "type": "text",
            "description": "Food diaries, interview, 24-hour recall interview, food propensy questionnaire, portion size measurement aids, eating outside questionnaire"
          }],
          "studySample": [{
            "id": "sampleName",
            "label": "Name",
            "type": "text",
            "description": "An unambiguous ID given to the samples used in the assay"
          }, {
            "id": "samplingWeight",
            "label": "Sampling weight",
            "type": "text",
            "description": "Description of the method employed to compute sampling weight (nonresponse-adjusted weight)"
          }, {
            "id": "protocolOfSampleCollection",
            "label": "Protocol of sample collection",
            "type": "text",
            "description": "Additional protocol for sample and sample collection. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "samplingStrategy",
            "label": "Sampling strategy",
            "type": "text",
            "description": "Sampling strategy (ref. EUROSTAT - Typology of sampling strategy, version of July 2009)"
          }, {
            "id": "samplingSize",
            "label": "Sampling size",
            "type": "text",
            "description": "Number of units, full participants, partial participants, eligibles, not eligible, unresolved (eligibility status not resolved)"
          }, {
            "id": "lotSizeUnit",
            "label": "Lot size unit",
            "type": "text",
            "description": "Unit in which the lot size is expressed"
          }, {
            "id": "samplingPoint",
            "label": "Sampling point",
            "type": "text",
            "description": "Point in the food chain where the sample was taken. (Doc. ESTAT/F5/ES/155 Data dictionary of activities of the establishments)"
          }, {
            "id": "samplingMethod",
            "label": "Sampling method",
            "type": "text",
            "description": "Sampling method used to take the sample"
          }, {
            "id": "typeOfSamplingProgram",
            "label": "Type of sampling program",
            "type": "text",
            "description": "Indicate the type of programm for which the samples have been collected"
          }, {
            "id": "samplingPlan",
            "label": "Sampling plan",
            "type": "text",
            "description": "Description of data collection technique: stratified or complex sampling (several stages)"
          }]
        },
        "modelMath": {
          "modelEquation": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "modelEquation": [{
              "id": "modelEquation",
              "label": "Equation",
              "type": "text",
              "description": "The pointer to the file that holds the software code (e.g. R-script)"
            }, {
              "id": "name",
              "label": "Model equation name",
              "type": "text",
              "description": "A name given to the model equation"
            }, {
              "id": "modelHypothesis",
              "label": "Hypothesis of the model",
              "description": "Description of the hypothesis of the model"
            }, {
              "id": "modelEquationClass",
              "label": "Model equation class",
              "type": "text",
              "description": "Information on that helps to categorize model equations"
            }]
          },
          "exposure": [{
            "id": "treatment",
            "label": "Left-censored data treatment",
            "description": "Description of the mathematical method to replace left-censored data (recommandation of WHO (2013), distribution or others)"
          }, {
            "id": "scenario",
            "label": "Scenario",
            "description": "Description of the different scenarios of exposure assessment"
          }, {
            "id": "uncertaintyEstimation",
            "label": "Uncertainty estimation",
            "type": "text",
            "description": "Analysis to estimate uncertainty"
          }, {
            "id": "type",
            "label": "Type of exposure",
            "type": "text",
            "description": "Description of the type of exposure"
          }, {
            "id": "contamination",
            "label": "Contam level post data treatment",
            "description": "Description of the range of of the level of contamination after left censored data treatment"
          }],
          "parameter": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "parameter": [{
              "id": "subject",
              "label": "Parameter subject",
              "type": "text",
              "description": "Scope of the parameter, e.g. if it refers to an animal, a batch of animals, a batch of products, a carcass, a carcass skin etc"
            }, {
              "id": "maxValue",
              "label": "Value max",
              "type": "text",
              "description": "Numerical value of the maximum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "dataType",
              "label": "Data type",
              "type": "text",
              "description": "Information on the data format of the parameter, e.g. if it is a categorical variable: int, double, array of size x,y,z "
            }, {
              "id": "description",
              "label": "Description",
              "type": "text",
              "description": "General description of the parameter"
            }, {
              "id": "source",
              "label": "Parameter source",
              "type": "text",
              "description": "Information on the type of knowledge used to define the parameter value"
            }, {
              "id": "classification",
              "label": "Parameter classification",
              "type": "text",
              "description": "General classification of the parameter (e.g. Input, Constant, Output etc)"
            }, {
              "id": "distribution",
              "label": "Parameter distribution",
              "type": "text",
              "description": "Distribution describing the parameter variabilty. If no distribution selected this means the value provided in 'Parameter value' is a point estimate. In case a distribution is selected the value provided in 'Parameter value' is a string that the model code can parse in order to sample from the named distribution"
            }, {
              "id": "error",
              "label": "Error",
              "type": "text",
              "description": "Error of the parameter value"
            }, {
              "id": "variabilitySubject",
              "label": "Parameter variability subject",
              "type": "text",
              "description": "Information on which the variability is described. It can be variability between broiler in a flock, variability between all meat packages sold in Denmark, variability between days, etc."
            }, {
              "id": "unit",
              "label": "Unit",
              "type": "text",
              "description": "Unit of the parameter"
            }, {
              "id": "minValue",
              "label": "Value min",
              "type": "text",
              "description": "Numerical value of the minimum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "unitCategory",
              "label": "Unit category",
              "type": "text",
              "description": "General classification of the parameter unit"
            }, {
              "id": "name",
              "label": "Parameter name",
              "type": "text",
              "description": "A name given to the parameter"
            }, {
              "id": "id",
              "label": "Parameter ID",
              "type": "text",
              "description": "An unambiguous ID given to each of the parameters - preferably autogenerated by a software tool and compatible with SBML ID requirements, only letters from A to Z, numbers and '_'"
            }, {
              "id": "value",
              "label": "Value",
              "type": "text",
              "description": "A default value for the parameter. This is mandatory (needs to be provided) for all parameters of type 'Input'"
            }]
          },
          "qualityMeasures": [{
            "id": "rsquared",
            "label": "R squared",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sse",
            "label": "SSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "rmse",
            "label": "RMSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "aic",
            "label": "AIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sensitivityAnalysis",
            "label": "Sensitivity analysis",
            "type": "long-text",
            "description": "Description of the results of an sensitivity analysis, i.e. how independence assumptions are met or how variables will affect the output of model"
          }, {
            "id": "bic",
            "label": "BIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "mse",
            "label": "MSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }],
          "modelMath": [{
            "id": "fittingProcedure",
            "label": "Fitting procedure",
            "type": "text",
            "description": "Procedure used to fit the data to the model equation"
          }, {
            "id": "event",
            "label": "Event",
            "description": "Definition of time-dependent parameter changes"
          }]
        },
        "scope": {
          "product": [{
            "id": "expiryDate",
            "label": "Expiration date",
            "type": "date",
            "description": "Expiry date of food/product"
          }, {
            "id": "treatment",
            "label": "Treatment",
            "description": "Used to characterise a product/matrix based on the treatment or processes applied to the product or any indexed ingredient"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the product, matrix or environment for which the model or data applies"
          }, {
            "id": "productionDate",
            "label": "Production date",
            "type": "date",
            "description": "Date of production of food/product"
          }, {
            "id": "method",
            "label": "Method of production",
            "description": "Type of production for the product/ matrix"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "The product, matrix or environment (e.g food product, lab media, soil etc.) for which the model or data applies"
          }, {
            "id": "originCountry",
            "label": "Country of origin",
            "type": "text",
            "description": "Country of origin of the food/product (ISO 3166-1-alpha-2 country code)"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Detailed description of the product, matrix or environment for which the model or data applies"
          }, {
            "id": "packaging",
            "label": "Packaging",
            "description": "Describe container or wrapper that holds the product/matrix. Common type of packaging (paper or plastic bags, boxes, tinplate or aluminium cans, plastic trays, plastic bottles, glass bottles or jars)"
          }, {
            "id": "fisheriesArea",
            "label": "Fisheries area",
            "type": "text",
            "description": "Fisheries or aquaculture area specifying the origin of the sample (FAO Fisheries areas)."
          }, {
            "id": "originArea",
            "label": "Area of origin",
            "type": "text",
            "description": "Area of origin of the food/product (Nomenclature of territorial units for statistics  NUTS  coding system valid only for EEA and Switzerland)."
          }],
          "populationGroup": [{
            "id": "populationRiskFactor",
            "label": "Risk and population factors",
            "description": "Population risk factor that may influence the outcomes of the study, confounder should be included"
          }, {
            "id": "country",
            "label": "Country",
            "description": "Country on which the population group of the model or data applies"
          }, {
            "id": "populationSpan",
            "label": "Population span (years)",
            "description": "Temporal information on the exposure duration"
          }, {
            "id": "populationGender",
            "label": "Population gender",
            "type": "text",
            "description": "Description of the percentage of gender"
          }, {
            "id": "populationDescription",
            "label": "Description",
            "description": "Description of the population for which the model applies (demographic and socio-economic characteristics for example). Background information that are needed in the data analysis phase, size of household, education level, employment status, professional category, ethnicity, etc."
          }, {
            "id": "populationAge",
            "label": "Population age",
            "description": "Description of the range of age or group of age"
          }, {
            "id": "patternConsumption",
            "label": "Consumption pattern",
            "description": "Description of the consumption of different food items, frequency, portion size"
          }, {
            "id": "name",
            "label": "Population name",
            "type": "text",
            "description": "Name of the population for which the model or data applies"
          }, {
            "id": "season",
            "label": "Season",
            "description": "Distribution of surveyed people according to the season (influence consumption pattern)"
          }, {
            "id": "region",
            "label": "Region",
            "description": "Spatial information (area) on which the population group of the model or data applies"
          }, {
            "id": "targetPopulation",
            "label": "Target population",
            "type": "text",
            "description": "Population of individual that we are interested in describing and making statistical inferences about"
          }, {
            "id": "bmi",
            "label": "BMI",
            "description": "Description of the range of BMI or class of BMI or BMI mean"
          }, {
            "id": "specialDietGroups",
            "label": "Special diet groups",
            "description": "Description of sub-population with special diets (vegetarians, diabetics, group following special ethnic diets)"
          }],
          "hazard": [{
            "id": "maximumResidueLimit",
            "label": "Maximum Residue Limit (MRL)",
            "type": "text",
            "description": "International regulations and permissible maximum residue levels in food and drinking water"
          }, {
            "id": "sourceOfContamination",
            "label": "Source of contamination",
            "type": "text",
            "description": "rigin of the contamination, source"
          }, {
            "id": "indSum",
            "label": "Individual or Summed Hazard",
            "type": "text",
            "description": "Define if the parameter reported is an individual residue/analyte, a summed residue definition or part of a sum a summed residue definition"
          }, {
            "id": "acceptableOperatorsExposureLevel",
            "label": "Acceptable Operator Exposure Level (AOEL)",
            "type": "text",
            "description": "Maximum amount of active substance to which the operator may be exposed without any adverse health effects. The AOEL is expressed as milligrams of the chemical per kilogram body weight of the operator"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Description of the hazard for which the model or data applies"
          }, {
            "id": "type",
            "label": "Hazard type",
            "type": "text",
            "description": "General classification of the hazard for which the model or data applies"
          }, {
            "id": "adverseEffect",
            "label": "Adverse effect",
            "type": "text",
            "description": "Adverse effect induced by hazard about morbidity, mortality, and etcetera"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the hazard for which the model or data applies"
          }, {
            "id": "noObservedAdverseAffectLevel",
            "label": "No Observed Adverse Affect Level (NOAEL)",
            "type": "text",
            "description": "Level of exposure of an organism, found by experiment or observation, at which there is no biologically or statistically significant increase in the frequency or severity of any adverse effects in the exposed population when compared to its appropriate control"
          }, {
            "id": "acuteReferenceDose",
            "label": "Acute Reference Dose (ARfD)",
            "type": "text",
            "description": "An estimate (with uncertainty spanning perhaps an order of magnitude) of a daily oral exposure for an acute duration (24 hours or less) to the human population (including sensitive subgroups) that is likely to be without an appreciable risk of deleterious effects during a lifetime"
          }, {
            "id": "name",
            "label": "Hazard name",
            "type": "text",
            "description": "Name of the hazard (agent, contaminant, chemical) for which the data or model applies"
          }, {
            "id": "lowestObservedAdverseAffectLevel",
            "label": "Lowest Observed Adverse Effect Level (LOAEL)",
            "type": "text",
            "description": "Lowest concentration or amount of a substance found by experiment or observation that causes an adverse alteration of morphology, function, capacity, growth, development, or lifespan of a target organism distinguished from normal organisms of the same species under defined conditions of exposure"
          }, {
            "id": "benchmarkDose",
            "label": "Benchmark Dose (BMD)",
            "type": "text",
            "description": "A dose or concentration that produces a predetermined change in response rate of an adverse effect (called the benchmark response or BMR) compared to background"
          }, {
            "id": "acceptableDailyIntake",
            "label": "Acceptable Daily Intake (ADI)",
            "type": "text",
            "description": "Measure of amount of a specific substance in food or in drinking water tahta can be ingested (orally) on a daily basis over a lifetime without an appreciable health risk"
          }],
          "scope": [{
            "id": "spatialInformation",
            "label": "Spatial information",
            "description": "Spatial information (area) on which the model or data applies"
          }, {
            "id": "generalComment",
            "label": "General comment",
            "type": "long-text",
            "description": "General comments on the scope of the study, data or model"
          }, {
            "id": "temporalInformation",
            "label": "Temporal information",
            "type": "long-text",
            "description": "Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)"
          }]
        },
        "generalInformation": {
          "creator": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "author": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "reference": [{
            "id": "date",
            "label": "Date",
            "type": "year_date",
            "description": "Temporal information on the publication date"
          }, {
            "id": "website",
            "label": "Website",
            "type": "text",
            "description": "A link to the publication website (different from DOI)"
          }, {
            "id": "issue",
            "label": "Issue",
            "type": "text",
            "description": "Data on the details of the issue in which the model or date has been described"
          }, {
            "id": "publicationType",
            "label": "Publication type",
            "type": "text",
            "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
          }, {
            "id": "abstract",
            "label": "Abstract",
            "type": "text",
            "description": "Abstract of the publication in which the model or the data has been described "
          }, {
            "id": "isReferenceDescription",
            "label": "Is_reference_description?",
            "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
          }, {
            "id": "title",
            "label": "Title",
            "type": "long-text",
            "description": "Title of publication in which the model or date has been described"
          }, {
            "id": "pmid",
            "label": "PubMed ID",
            "type": "text",
            "description": "The PubMed ID related to this publication"
          }, {
            "id": "volume",
            "label": "Volume",
            "type": "text",
            "description": "Data on the details of the volume in which the model or date has been described"
          }, {
            "id": "journal",
            "label": "Journal",
            "type": "long-text",
            "description": "Data on the details of the journal in which the model or date has been described"
          }, {
            "id": "authorList",
            "label": "Author list",
            "type": "long-text",
            "description": "Name and surname of the authors who contributed to this publication"
          }, {
            "id": "comment",
            "label": "Comment",
            "type": "long-text",
            "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
          }, {
            "id": "doi",
            "label": "Publication DOI",
            "type": "long-text",
            "description": "The DOI related to this publication"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The status of this publication, e.g. Published, Submitted, etc."
          }],
          "modelCategory": [{
            "id": "modelClassComment",
            "label": "Comment",
            "type": "long-text",
            "description": "Comment with further details on the model class"
          }, {
            "id": "basicProcess",
            "label": "Basic process",
            "description": "Defines the impact of the process on the hazard (so far only valid for process models and predictive models)"
          }, {
            "id": "modelClass",
            "label": "Model class",
            "type": "text",
            "description": "Type of model according to RAKIP classification"
          }, {
            "id": "modelSubClass",
            "label": "Subclass",
            "description": "Sub-classification of the model given the Model Class"
          }],
          "generalInformation": [{
            "id": "identifier",
            "label": "Identifier",
            "type": "text",
            "description": "An unambiguous ID given to the model or data. This can also be created automatically by a software tool"
          }, {
            "id": "software",
            "label": "Software",
            "type": "text",
            "description": "The program or software language in which the model has been implemented"
          }, {
            "id": "format",
            "label": "Format",
            "type": "text",
            "description": "File extension of the model or data file (including version number of format if applicable)"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the study, data or model"
          }, {
            "id": "language",
            "label": "Language",
            "type": "text",
            "description": "A language of the resource (some data or reports can be available in French language for example)"
          }, {
            "id": "source",
            "label": "Source",
            "type": "text",
            "description": "A source from which the model/data is derived"
          }, {
            "id": "availability",
            "label": "Availability",
            "type": "text",
            "description": "Availability of data or model, i.e. if the annotated model code / data is included in this FSK file"
          }, {
            "id": "creationDate",
            "label": "Creation date",
            "type": "date",
            "description": "Creation date/time of the FSK file"
          }, {
            "id": "url",
            "label": "URL",
            "type": "text",
            "description": "Web address referencing the resource location (data for example)"
          }, {
            "id": "objective",
            "label": "Objective",
            "type": "long-text",
            "description": "Objective of the model or data"
          }, {
            "id": "modificationDate",
            "label": "Modification date",
            "description": "Date/time of the last version of the FSK file"
          }, {
            "id": "rights",
            "label": "Rights",
            "type": "text",
            "description": "Rights granted for usage, distribution and modification of this FSK file"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "A name given to the model or data"
          }, {
            "id": "languageWrittenIn",
            "label": "Language written in",
            "type": "text",
            "description": "Software language used to write the model, e.g. R or MatLab"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The curation status of the model"
          }]
        }
      };
    }
    // Validate this.panels and return boolean
  }, {
    key: "validate",
    value: function validate() {
      var isValid = true;
      if (!this.panels.generalInformation.validate()) isValid = false;
      if (!this.panels.modelCategory.validate()) isValid = false;
      if (!this.panels.scopeGeneral.validate()) isValid = false;
      if (!this.panels.study.validate()) isValid = false;
      return isValid;
    }
  }, {
    key: "_createPanels",
    value: function _createPanels() {
      var _ref;
      var port = window.port || -1;
      var schema = schemas.genericModel;
      return _ref = {
        study: new _FormPanel.FormPanel("Study", this.jsonSchema.dataBackground.study, this._metadata.dataBackground ? this._metadata.dataBackground.study : {}, port),
        laboratory: new _TablePanel.TablePanel("Laboratory", this.jsonSchema.dataBackground.laboratory, this._metadata.dataBackground ? this._metadata.dataBackground.laboratory : {}, port),
        assay: new _TablePanel.TablePanel("Assay", this.jsonSchema.dataBackground.assay, this._metadata.dataBackground ? this._metadata.dataBackground.assay : {}, port),
        dietaryAssessmentMethod: new _TablePanel.TablePanel("Dietary Assessment Method", this.jsonSchema.dataBackground.dietaryAssessmentMethod, this._metadata.dataBackground ? this._metadata.dataBackground.dietaryAssessmentMethod : {}, port),
        studySample: new _TablePanel.TablePanel("Study Sample", this.jsonSchema.dataBackground.studySample, this._metadata.dataBackground ? this._metadata.dataBackground.studySample : {}, port),
        modelMath: new _FormPanel.FormPanel("Model Math", this.jsonSchema.modelMath.modelMath, this._metadata.modelMath, port),
        modelEquation: new _TablePanel.TablePanel("Model Equation", this.jsonSchema.modelMath.modelEquation.modelEquation, this._metadata.modelMath ? this._metadata.modelMath.modelEquation : {}, port),
        reference: new _TablePanel.TablePanel("Reference", this.jsonSchema.modelMath.modelEquation.reference, this._metadata.modelMath.modelEquation ? this._metadata.modelMath.modelEquation.reference : {}, port),
        exposure: new _TablePanel.TablePanel("Exposure", this.jsonSchema.modelMath.exposure, this._metadata.modelMath ? this._metadata.modelMath.exposure : {}, port),
        parameter: new _TablePanel.TablePanel("Parameter", this.jsonSchema.modelMath.parameter.parameter, this._metadata.modelMath ? this._metadata.modelMath.parameter : {}, port)
      }, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref, "reference", new _FormPanel.FormPanel("Reference", this.jsonSchema.modelMath.parameter.reference, this._metadata.modelMath.parameter ? this._metadata.modelMath.parameter.reference : {}, port)), "qualityMeasures", new _TablePanel.TablePanel("Quality Measures", this.jsonSchema.modelMath.qualityMeasures, this._metadata.modelMath ? this._metadata.modelMath.qualityMeasures : {}, port)), "scope", new _FormPanel.FormPanel("Scope", this.jsonSchema.scope.scope, this._metadata.scope, port)), "product", new _TablePanel.TablePanel("Product", this.jsonSchema.scope.product, this._metadata.scope ? this._metadata.scope.product : {}, port)), "populationGroup", new _TablePanel.TablePanel("Population Group", this.jsonSchema.scope.populationGroup, this._metadata.scope ? this._metadata.scope.populationGroup : {}, port)), "hazard", new _TablePanel.TablePanel("Hazard", this.jsonSchema.scope.hazard, this._metadata.scope ? this._metadata.scope.hazard : {}, port)), "generalInformation", new _FormPanel.FormPanel("General Information", this.jsonSchema.generalInformation.generalInformation, this._metadata.generalInformation, port)), "creator", new _TablePanel.TablePanel("Creator", this.jsonSchema.generalInformation.creator, this._metadata.generalInformation ? this._metadata.generalInformation.creator : {}, port)), "author", new _TablePanel.TablePanel("Author", this.jsonSchema.generalInformation.author, this._metadata.generalInformation ? this._metadata.generalInformation.author : {}, port)), "reference", new _TablePanel.TablePanel("Reference", this.jsonSchema.generalInformation.reference, this._metadata.generalInformation ? this._metadata.generalInformation.reference : {}, port)), _defineProperty(_ref, "modelCategory", new _FormPanel.FormPanel("Model Category", this.jsonSchema.generalInformation.modelCategory, this._metadata.generalInformation ? this._metadata.generalInformation.modelCategory : {}, port));
    }
  }]);
}(_ModelView2.ModelView);

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./ExposureModelScopeView":92,"./GenericModelDataBackgroundView":97,"./GenericModelModelMathView":101,"./ModelView":118,"./PredictiveModelGeneralInformationView":137}],159:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Study = void 0;
var _ApiClient = require("../ApiClient");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Study model module.
 * @module model/Study
 * @version 1.0.0
 */
var Study = exports.Study = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>Study</code>.
   * @alias module:model/Study
   * @class
   * @param title {} A title for the study
   */
  function Study(title) {
    _classCallCheck(this, Study);
    this.title = title;
  }

  /**
   * Constructs a <code>Study</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/Study} obj Optional instance to populate.
   * @return {module:model/Study} The populated <code>Study</code> instance.
   */
  return _createClass(Study, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new Study();
        if (data.hasOwnProperty('identifier')) obj.identifier = _ApiClient.ApiClient.convertToType(data['identifier'], 'String');
        if (data.hasOwnProperty('protocolComponentsName')) obj.protocolComponentsName = _ApiClient.ApiClient.convertToType(data['protocolComponentsName'], 'String');
        if (data.hasOwnProperty('designType')) obj.designType = _ApiClient.ApiClient.convertToType(data['designType'], 'String');
        if (data.hasOwnProperty('assayMeasurementType')) obj.assayMeasurementType = _ApiClient.ApiClient.convertToType(data['assayMeasurementType'], 'String');
        if (data.hasOwnProperty('protocolComponentsType')) obj.protocolComponentsType = _ApiClient.ApiClient.convertToType(data['protocolComponentsType'], 'String');
        if (data.hasOwnProperty('description')) obj.description = _ApiClient.ApiClient.convertToType(data['description'], 'String');
        if (data.hasOwnProperty('assayTechnologyPlatform')) obj.assayTechnologyPlatform = _ApiClient.ApiClient.convertToType(data['assayTechnologyPlatform'], 'String');
        if (data.hasOwnProperty('assayTechnologyType')) obj.assayTechnologyType = _ApiClient.ApiClient.convertToType(data['assayTechnologyType'], 'String');
        if (data.hasOwnProperty('protocolType')) obj.protocolType = _ApiClient.ApiClient.convertToType(data['protocolType'], 'String');
        if (data.hasOwnProperty('title')) obj.title = _ApiClient.ApiClient.convertToType(data['title'], 'String');
        if (data.hasOwnProperty('protocolDescription')) obj.protocolDescription = _ApiClient.ApiClient.convertToType(data['protocolDescription'], 'String');
        if (data.hasOwnProperty('protocolParametersName')) obj.protocolParametersName = _ApiClient.ApiClient.convertToType(data['protocolParametersName'], 'String');
        if (data.hasOwnProperty('protocolName')) obj.protocolName = _ApiClient.ApiClient.convertToType(data['protocolName'], 'String');
        if (data.hasOwnProperty('protocolVersion')) obj.protocolVersion = _ApiClient.ApiClient.convertToType(data['protocolVersion'], 'String');
        if (data.hasOwnProperty('protocolURI')) obj.protocolURI = _ApiClient.ApiClient.convertToType(data['protocolURI'], 'String');
        if (data.hasOwnProperty('accreditationProcedureForTheAssayTechnology')) obj.accreditationProcedureForTheAssayTechnology = _ApiClient.ApiClient.convertToType(data['accreditationProcedureForTheAssayTechnology'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * A user defined identifier for the study
 * @member {String} identifier
 */
Study.prototype.identifier = undefined;

/**
 * The names of the components used when carrying out this protocol
 * @member {String} protocolComponentsName
 */
Study.prototype.protocolComponentsName = undefined;

/**
 * The type of study design being employed
 * @member {String} designType
 */
Study.prototype.designType = undefined;

/**
 * The measurement being observed in this assay
 * @member {String} assayMeasurementType
 */
Study.prototype.assayMeasurementType = undefined;

/**
 * Description
 * @member {String} protocolComponentsType
 */
Study.prototype.protocolComponentsType = undefined;

/**
 * A brief description of the study aims
 * @member {String} description
 */
Study.prototype.description = undefined;

/**
 * The technology platform used
 * @member {String} assayTechnologyPlatform
 */
Study.prototype.assayTechnologyPlatform = undefined;

/**
 * The technology being employed to observe this measurement
 * @member {String} assayTechnologyType
 */
Study.prototype.assayTechnologyType = undefined;

/**
 * The type of the protocol, preferably coming from an Ontology, e.g. Extraction Protocol
 * @member {String} protocolType
 */
Study.prototype.protocolType = undefined;

/**
 * A title for the study
 * @member {String} title
 */
Study.prototype.title = undefined;

/**
 * A description of the protocol
 * @member {String} protocolDescription
 */
Study.prototype.protocolDescription = undefined;

/**
 * The parameters used when executing this protocol
 * @member {String} protocolParametersName
 */
Study.prototype.protocolParametersName = undefined;

/**
 * The name of the protocol, e.g.Extraction Protocol
 * @member {String} protocolName
 */
Study.prototype.protocolName = undefined;

/**
 * The version of the protocol used, where applicable.
 * @member {String} protocolVersion
 */
Study.prototype.protocolVersion = undefined;

/**
 * A URI to link out to a publication, web page, etc. describing the protocol
 * @member {String} protocolURI
 */
Study.prototype.protocolURI = undefined;

/**
 * Accreditation procedure for the analytical method used
 * @member {String} accreditationProcedureForTheAssayTechnology
 */
Study.prototype.accreditationProcedureForTheAssayTechnology = undefined;

},{"../ApiClient":44}],160:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StudySample = void 0;
var _ApiClient = require("../ApiClient");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The StudySample model module.
 * @module model/StudySample
 * @version 1.0.0
 */
var StudySample = exports.StudySample = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>StudySample</code>.
   * @alias module:model/StudySample
   * @class
   * @param sampleName {} An unambiguous ID given to the samples used in the assay
   * @param samplingWeight {} Description of the method employed to compute sampling weight (nonresponse-adjusted weight)
   * @param protocolOfSampleCollection {} Additional protocol for sample and sample collection. Corresponds to the Protocol REF in ISA
   * @param samplingSize {} Number of units, full participants, partial participants, eligibles, not eligible, unresolved (eligibility status not resolved)
   * @param samplingPlan {} Description of data collection technique: stratified or complex sampling (several stages)
   */
  function StudySample(sampleNamesamplingWeightprotocolOfSampleCollectionsamplingSizesamplingPlan) {
    _classCallCheck(this, StudySample);
    this.sampleName = sampleName;
    this.samplingWeight = samplingWeight;
    this.protocolOfSampleCollection = protocolOfSampleCollection;
    this.samplingSize = samplingSize;
    this.samplingPlan = samplingPlan;
  }

  /**
   * Constructs a <code>StudySample</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/StudySample} obj Optional instance to populate.
   * @return {module:model/StudySample} The populated <code>StudySample</code> instance.
   */
  return _createClass(StudySample, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new StudySample();
        if (data.hasOwnProperty('sampleName')) obj.sampleName = _ApiClient.ApiClient.convertToType(data['sampleName'], 'String');
        if (data.hasOwnProperty('samplingWeight')) obj.samplingWeight = _ApiClient.ApiClient.convertToType(data['samplingWeight'], 'String');
        if (data.hasOwnProperty('protocolOfSampleCollection')) obj.protocolOfSampleCollection = _ApiClient.ApiClient.convertToType(data['protocolOfSampleCollection'], 'String');
        if (data.hasOwnProperty('samplingStrategy')) obj.samplingStrategy = _ApiClient.ApiClient.convertToType(data['samplingStrategy'], 'String');
        if (data.hasOwnProperty('samplingSize')) obj.samplingSize = _ApiClient.ApiClient.convertToType(data['samplingSize'], 'String');
        if (data.hasOwnProperty('lotSizeUnit')) obj.lotSizeUnit = _ApiClient.ApiClient.convertToType(data['lotSizeUnit'], 'String');
        if (data.hasOwnProperty('samplingPoint')) obj.samplingPoint = _ApiClient.ApiClient.convertToType(data['samplingPoint'], 'String');
        if (data.hasOwnProperty('samplingMethod')) obj.samplingMethod = _ApiClient.ApiClient.convertToType(data['samplingMethod'], 'String');
        if (data.hasOwnProperty('typeOfSamplingProgram')) obj.typeOfSamplingProgram = _ApiClient.ApiClient.convertToType(data['typeOfSamplingProgram'], 'String');
        if (data.hasOwnProperty('samplingPlan')) obj.samplingPlan = _ApiClient.ApiClient.convertToType(data['samplingPlan'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * An unambiguous ID given to the samples used in the assay
 * @member {String} sampleName
 */
StudySample.prototype.sampleName = undefined;

/**
 * Description of the method employed to compute sampling weight (nonresponse-adjusted weight)
 * @member {String} samplingWeight
 */
StudySample.prototype.samplingWeight = undefined;

/**
 * Additional protocol for sample and sample collection. Corresponds to the Protocol REF in ISA
 * @member {String} protocolOfSampleCollection
 */
StudySample.prototype.protocolOfSampleCollection = undefined;

/**
 * Sampling strategy (ref. EUROSTAT - Typology of sampling strategy, version of July 2009)
 * @member {String} samplingStrategy
 */
StudySample.prototype.samplingStrategy = undefined;

/**
 * Number of units, full participants, partial participants, eligibles, not eligible, unresolved (eligibility status not resolved)
 * @member {String} samplingSize
 */
StudySample.prototype.samplingSize = undefined;

/**
 * Unit in which the lot size is expressed
 * @member {String} lotSizeUnit
 */
StudySample.prototype.lotSizeUnit = undefined;

/**
 * Point in the food chain where the sample was taken. (Doc. ESTAT/F5/ES/155 Data dictionary of activities of the establishments)
 * @member {String} samplingPoint
 */
StudySample.prototype.samplingPoint = undefined;

/**
 * Sampling method used to take the sample
 * @member {String} samplingMethod
 */
StudySample.prototype.samplingMethod = undefined;

/**
 * Indicate the type of programm for which the samples have been collected
 * @member {String} typeOfSamplingProgram
 */
StudySample.prototype.typeOfSamplingProgram = undefined;

/**
 * Description of data collection technique: stratified or complex sampling (several stages)
 * @member {String} samplingPlan
 */
StudySample.prototype.samplingPlan = undefined;

},{"../ApiClient":44}],161:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StudySampleView = void 0;
var _ApiClient = require("../ApiClient");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The StudySample View  module.
 * @module model/StudySample
 * @version 1.0.0
 */
var StudySampleView = exports.StudySampleView = /*#__PURE__*/_createClass(function StudySampleView() {
  _classCallCheck(this, StudySampleView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63}],162:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StudyView = void 0;
var _ApiClient = require("../ApiClient");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The Study View  module.
 * @module model/Study
 * @version 1.0.0
 */
var StudyView = exports.StudyView = /*#__PURE__*/_createClass(function StudyView() {
  _classCallCheck(this, StudyView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63}],163:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToxicologicalModel = void 0;
var _ApiClient = require("../ApiClient");
var _GenericModelModelMath = require("./GenericModelModelMath");
var _Model2 = require("./Model");
var _PredictiveModelDataBackground = require("./PredictiveModelDataBackground");
var _PredictiveModelGeneralInformation = require("./PredictiveModelGeneralInformation");
var _ToxicologicalModelScope = require("./ToxicologicalModelScope");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ToxicologicalModel model module.
 * @module model/ToxicologicalModel
 * @version 1.0.0
 */
var ToxicologicalModel = exports.ToxicologicalModel = /*#__PURE__*/function (_Model) {
  /**
   * Constructs a new <code>ToxicologicalModel</code>.
   * @alias module:model/ToxicologicalModel
   * @class
   * @extends module:model/Model
   * @param modelType {} 
   */
  function ToxicologicalModel(modelType) {
    _classCallCheck(this, ToxicologicalModel);
    return _callSuper(this, ToxicologicalModel, [modelType]);
  }

  /**
   * Constructs a <code>ToxicologicalModel</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/ToxicologicalModel} obj Optional instance to populate.
   * @return {module:model/ToxicologicalModel} The populated <code>ToxicologicalModel</code> instance.
   */
  _inherits(ToxicologicalModel, _Model);
  return _createClass(ToxicologicalModel, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new ToxicologicalModel();
        _Model2.Model.constructFromObject(data, obj);
        if (data.hasOwnProperty('dataBackground')) obj.dataBackground = _PredictiveModelDataBackground.PredictiveModelDataBackground.constructFromObject(data['dataBackground']);
        if (data.hasOwnProperty('modelMath')) obj.modelMath = _GenericModelModelMath.GenericModelModelMath.constructFromObject(data['modelMath']);
        if (data.hasOwnProperty('scope')) obj.scope = _ToxicologicalModelScope.ToxicologicalModelScope.constructFromObject(data['scope']);
        if (data.hasOwnProperty('generalInformation')) obj.generalInformation = _PredictiveModelGeneralInformation.PredictiveModelGeneralInformation.constructFromObject(data['generalInformation']);
      }
      return obj;
    }
  }]);
}(_Model2.Model);
/**
 * @member {module:model/PredictiveModelDataBackground} dataBackground
 */
ToxicologicalModel.prototype.dataBackground = undefined;

/**
 * @member {module:model/GenericModelModelMath} modelMath
 */
ToxicologicalModel.prototype.modelMath = undefined;

/**
 * @member {module:model/ToxicologicalModelScope} scope
 */
ToxicologicalModel.prototype.scope = undefined;

/**
 * @member {module:model/PredictiveModelGeneralInformation} generalInformation
 */
ToxicologicalModel.prototype.generalInformation = undefined;

},{"../ApiClient":44,"./GenericModelModelMath":100,"./Model":113,"./PredictiveModelDataBackground":134,"./PredictiveModelGeneralInformation":136,"./ToxicologicalModelScope":164}],164:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToxicologicalModelScope = void 0;
var _ApiClient = require("../ApiClient");
var _Hazard = require("./Hazard");
var _PopulationGroup = require("./PopulationGroup");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ToxicologicalModelScope model module.
 * @module model/ToxicologicalModelScope
 * @version 1.0.0
 */
var ToxicologicalModelScope = exports.ToxicologicalModelScope = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>ToxicologicalModelScope</code>.
   * @alias module:model/ToxicologicalModelScope
   * @class
   */
  function ToxicologicalModelScope() {
    _classCallCheck(this, ToxicologicalModelScope);
  }

  /**
   * Constructs a <code>ToxicologicalModelScope</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/ToxicologicalModelScope} obj Optional instance to populate.
   * @return {module:model/ToxicologicalModelScope} The populated <code>ToxicologicalModelScope</code> instance.
   */
  return _createClass(ToxicologicalModelScope, null, [{
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new ToxicologicalModelScope();
        if (data.hasOwnProperty('spatialInformation')) obj.spatialInformation = _ApiClient.ApiClient.convertToType(data['spatialInformation'], ['String']);
        if (data.hasOwnProperty('populationGroup')) obj.populationGroup = _ApiClient.ApiClient.convertToType(data['populationGroup'], [_PopulationGroup.PopulationGroup]);
        if (data.hasOwnProperty('hazard')) obj.hazard = _ApiClient.ApiClient.convertToType(data['hazard'], [_Hazard.Hazard]);
        if (data.hasOwnProperty('generalComment')) obj.generalComment = _ApiClient.ApiClient.convertToType(data['generalComment'], 'String');
        if (data.hasOwnProperty('temporalInformation')) obj.temporalInformation = _ApiClient.ApiClient.convertToType(data['temporalInformation'], 'String');
      }
      return obj;
    }
  }]);
}();
/**
 * Spatial information (area) on which the model or data applies
 * @member {Array.<String>} spatialInformation
 */
ToxicologicalModelScope.prototype.spatialInformation = undefined;

/**
 * @member {Array.<module:model/PopulationGroup>} populationGroup
 */
ToxicologicalModelScope.prototype.populationGroup = undefined;

/**
 * @member {Array.<module:model/Hazard>} hazard
 */
ToxicologicalModelScope.prototype.hazard = undefined;

/**
 * General comments on the scope of the study, data or model
 * @member {String} generalComment
 */
ToxicologicalModelScope.prototype.generalComment = undefined;

/**
 * Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)
 * @member {String} temporalInformation
 */
ToxicologicalModelScope.prototype.temporalInformation = undefined;

},{"../ApiClient":44,"./Hazard":105,"./PopulationGroup":131}],165:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToxicologicalModelScopeView = void 0;
var _ApiClient = require("../ApiClient");
var _HazardView = require("./HazardView");
var _PopulationGroupView = require("./PopulationGroupView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ToxicologicalModelScope View  module.
 * @module model/ToxicologicalModelScope
 * @version 1.0.0
 */
var ToxicologicalModelScopeView = exports.ToxicologicalModelScopeView = /*#__PURE__*/_createClass(function ToxicologicalModelScopeView() {
  _classCallCheck(this, ToxicologicalModelScopeView);
});

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./HazardView":106,"./PopulationGroupView":132}],166:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToxicologicalModelView = void 0;
var _ApiClient = require("../ApiClient");
var _GenericModelModelMathView = require("./GenericModelModelMathView");
var _ModelView2 = require("./ModelView");
var _PredictiveModelDataBackgroundView = require("./PredictiveModelDataBackgroundView");
var _PredictiveModelGeneralInformationView = require("./PredictiveModelGeneralInformationView");
var _ToxicologicalModelScopeView = require("./ToxicologicalModelScopeView");
var _EventObserver = require("../app/EventObserver.js");
var _ArrayForm = require("../app/ArrayForm.js");
var _InputForm = require("../app/InputForm.js");
var _SelectForm = require("../app/SelectForm.js");
var _SimpleTable = require("../app/SimpleTable.js");
var _TablePanel = require("../app/TablePanel.js");
var _TextareaForm = require("../app/TextareaForm.js");
var _FormPanel = require("../app/FormPanel.js");
var _Dialog = require("../app/Dialog.js");
var _APPTable = require("../app/APPTable.js");
var _APPTableMT = require("../app/APPTableMT.js");
var _APPModal = require("../app/APPModal.js");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*
 * 
 * 
 *
 *
 * NOTE: This class is auto generated by the KIDA code generator program.
 *
 * KIDA Codegen version: 1.0.0
 *
 * Do not edit the class manually.
 *
 */
/**
 * The ToxicologicalModel View  module.
 * @module model/ToxicologicalModel
 * @version 1.0.0
 */
var ToxicologicalModelView = exports.ToxicologicalModelView = /*#__PURE__*/function (_ModelView) {
  function ToxicologicalModelView(metadata, img, state, modelScript, visScript, readme) {
    var _this;
    _classCallCheck(this, ToxicologicalModelView);
    _this = _callSuper(this, ToxicologicalModelView, [metadata, img, modelScript, visScript, readme]);
    _this._schema = schemas.genericModel;
    if (state) {
      _this.panels = _this._createPanels();
    }
    _this._menu = [{
      "label": "General Information",
      "id": "generalInformation",
      "submenus": [{
        "label": "General Information",
        "id": "generalInformation"
      }, {
        "label": "Model Category",
        "id": "modelCategory"
      }, {
        "label": "Reference",
        "id": "reference"
      }, {
        "label": "Author",
        "id": "author"
      }, {
        "label": "Creator",
        "id": "creator"
      }]
    }, {
      "label": "Scope",
      "id": "scope",
      "submenus": [{
        "label": "Scope",
        "id": "scope"
      }, {
        "label": "Hazard",
        "id": "hazard"
      }, {
        "label": "Population Group",
        "id": "populationGroup"
      }]
    }, {
      "label": "Model Math",
      "id": "modelMath",
      "submenus": [{
        "label": "Model Math",
        "id": "modelMath"
      }, {
        "label": "Quality Measures",
        "id": "qualityMeasures"
      }, {
        "label": "Parameter",
        "id": "parameter",
        "submenus": [{
          "label": "Parameter",
          "id": "parameter"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }, {
        "label": "Exposure",
        "id": "exposure"
      }, {
        "label": "Model Equation",
        "id": "modelEquation",
        "submenus": [{
          "label": "Model Equation",
          "id": "modelEquation"
        }, {
          "label": "Reference",
          "id": "reference"
        }]
      }]
    }, {
      "label": "Data Background",
      "id": "dataBackground",
      "submenus": [{
        "label": "Study Sample",
        "id": "studySample"
      }, {
        "label": "Assay",
        "id": "assay"
      }, {
        "label": "Laboratory",
        "id": "laboratory"
      }, {
        "label": "Study",
        "id": "study"
      }]
    }];
    _this._panels = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
      study: {
        type: 'simple',
        schema: _this.jsonSchema.dataBackgroundstudy,
        metadata: _this._metadata.study
      },
      laboratory: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundlaboratory,
        metadata: _this._metadata.laboratory
      },
      assay: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundassay,
        metadata: _this._metadata.assay
      },
      studySample: {
        type: 'complex',
        schema: _this.jsonSchema.dataBackgroundstudySample,
        metadata: _this._metadata.studySample
      },
      modelMath: {
        type: 'simple',
        schema: _this.jsonSchema.modelMathmodelMath,
        metadata: _this._metadata.modelMath
      },
      modelEquation: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationmodelEquation,
        metadata: _this._metadata.modelEquation
      },
      reference: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.modelEquationreference,
        metadata: _this._metadata.reference
      },
      exposure: {
        type: 'complex',
        schema: _this.jsonSchema.modelMathexposure,
        metadata: _this._metadata.exposure
      },
      parameter: {
        type: 'complex',
        schema: _this.jsonSchema.modelMath.parameterparameter,
        metadata: _this._metadata.parameter
      }
    }, "reference", {
      type: 'simple',
      schema: _this.jsonSchema.modelMath.parameterreference,
      metadata: _this._metadata.reference
    }), "qualityMeasures", {
      type: 'complex',
      schema: _this.jsonSchema.modelMathqualityMeasures,
      metadata: _this._metadata.qualityMeasures
    }), "scope", {
      type: 'simple',
      schema: _this.jsonSchema.scopescope,
      metadata: _this._metadata.scope
    }), "populationGroup", {
      type: 'complex',
      schema: _this.jsonSchema.scopepopulationGroup,
      metadata: _this._metadata.populationGroup
    }), "hazard", {
      type: 'complex',
      schema: _this.jsonSchema.scopehazard,
      metadata: _this._metadata.hazard
    }), "generalInformation", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationgeneralInformation,
      metadata: _this._metadata.generalInformation
    }), "creator", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationcreator,
      metadata: _this._metadata.creator
    }), "author", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationauthor,
      metadata: _this._metadata.author
    }), "reference", {
      type: 'complex',
      schema: _this.jsonSchema.generalInformationreference,
      metadata: _this._metadata.reference
    }), "modelCategory", {
      type: 'simple',
      schema: _this.jsonSchema.generalInformationmodelCategory,
      metadata: _this._metadata.modelCategory
    });
    return _this;
  }
  _inherits(ToxicologicalModelView, _ModelView);
  return _createClass(ToxicologicalModelView, [{
    key: "metaData",
    get: function get() {
      try {
        this._metadata.dataBackground.study = this.panels.study.data;
        this._metadata.dataBackground.laboratory = this.panels.laboratory.data;
        this._metadata.dataBackground.assay = this.panels.assay.data;
        this._metadata.dataBackground.studySample = this.panels.studySample.data;
        this._metadata.modelMath = this.panels.modelMath.data;
        this._metadata.modelMath.modelEquation = this.panels.modelEquation.data;
        this._metadata.modelMath.modelEquation.reference = this.panels.reference.data;
        this._metadata.modelMath.exposure = this.panels.exposure.data;
        this._metadata.modelMath.parameter = this.panels.parameter.data;
        this._metadata.modelMath.parameter.reference = this.panels.reference.data;
        this._metadata.modelMath.qualityMeasures = this.panels.qualityMeasures.data;
        this._metadata.scope = this.panels.scope.data;
        this._metadata.scope.populationGroup = this.panels.populationGroup.data;
        this._metadata.scope.hazard = this.panels.hazard.data;
        this._metadata.generalInformation = this.panels.generalInformation.data;
        this._metadata.generalInformation.creator = this.panels.creator.data;
        this._metadata.generalInformation.author = this.panels.author.data;
        this._metadata.generalInformation.reference = this.panels.reference.data;
        this._metadata.generalInformation.modelCategory = this.panels.modelCategory.data;
        this._metadata.modelType = "ToxicologicalModel";
        this._metadata = metadataFix(this._metadata);
      } catch (error) {
        console.log(error);
      }
      return this._metadata;
    }
  }, {
    key: "jsonSchema",
    get: function get() {
      return {
        "dataBackground": {
          "study": [{
            "id": "identifier",
            "label": "Study identifier",
            "type": "text",
            "description": "A user defined identifier for the study"
          }, {
            "id": "protocolComponentsName",
            "label": "Components names",
            "type": "text",
            "description": "The names of the components used when carrying out this protocol"
          }, {
            "id": "designType",
            "label": "Design type",
            "type": "text",
            "description": "The type of study design being employed"
          }, {
            "id": "assayMeasurementType",
            "label": "Assay measurement type",
            "type": "text",
            "description": "The measurement being observed in this assay"
          }, {
            "id": "protocolComponentsType",
            "label": "Protocol components type",
            "type": "text",
            "description": "Description"
          }, {
            "id": "description",
            "label": "Study description",
            "type": "long-text",
            "description": "A brief description of the study aims"
          }, {
            "id": "assayTechnologyPlatform",
            "label": "Assay technology platform",
            "type": "text",
            "description": "The technology platform used"
          }, {
            "id": "assayTechnologyType",
            "label": "Assay technology type",
            "type": "text",
            "description": "The technology being employed to observe this measurement"
          }, {
            "id": "protocolType",
            "label": "Protocol type",
            "type": "text",
            "description": "The type of the protocol, preferably coming from an Ontology, e.g. Extraction Protocol"
          }, {
            "id": "title",
            "label": "Study title",
            "type": "long-text",
            "description": "A title for the study"
          }, {
            "id": "protocolDescription",
            "label": "Protocol description",
            "type": "long-text",
            "description": "A description of the protocol"
          }, {
            "id": "protocolParametersName",
            "label": "Parameters names",
            "type": "text",
            "description": "The parameters used when executing this protocol"
          }, {
            "id": "protocolName",
            "label": "Protocol name",
            "type": "text",
            "description": "The name of the protocol, e.g.Extraction Protocol"
          }, {
            "id": "protocolVersion",
            "label": "Protocol version",
            "type": "text",
            "description": "The version of the protocol used, where applicable."
          }, {
            "id": "protocolURI",
            "label": "Protocol URI",
            "type": "text",
            "description": "A URI to link out to a publication, web page, etc. describing the protocol"
          }, {
            "id": "accreditationProcedureForTheAssayTechnology",
            "label": "Accreditation procedure for assay",
            "type": "text",
            "description": "Accreditation procedure for the analytical method used"
          }],
          "laboratory": [{
            "id": "country",
            "label": "Laboratory country",
            "type": "text",
            "description": "Country where the laboratory is placed. (ISO 3166-1-alpha-2)"
          }, {
            "id": "name",
            "label": "Laboratory name",
            "type": "text",
            "description": "Laboratory code (National laboratory code if available) or Laboratory name "
          }, {
            "id": "accreditation",
            "label": "Laboratory accreditation",
            "description": "The laboratory accreditation to ISO/IEC 17025"
          }],
          "assay": [{
            "id": "contaminationRange",
            "label": "Range of contamination",
            "type": "text",
            "description": "Range of result of the analytical measure reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "uncertaintyValue",
            "label": "Uncertainty value",
            "type": "text",
            "description": "Indicate the expanded uncertainty (usually 95% confidence interval) value associated with the measurement expressed in the unit reported in the field Hazard unit"
          }, {
            "id": "fatPercentage",
            "label": "Percentage of fat",
            "type": "text",
            "description": "Percentage of fat in the original sample"
          }, {
            "id": "name",
            "label": "Assay name",
            "type": "text",
            "description": "A name given to the assay"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the assay. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "moisturePercentage",
            "label": "Percentage of moisture",
            "type": "text",
            "description": "Percentage of moisture in the original sample"
          }, {
            "id": "leftCensoredData",
            "label": "Left-censored data",
            "type": "text",
            "description": "Percentage of measures equal to LOQ and/or LOD"
          }, {
            "id": "detectionLimit",
            "label": "Limit of detection",
            "type": "text",
            "description": "Limit of detection reported in the unit specified by the variable Hazard unit"
          }, {
            "id": "quantificationLimit",
            "label": "Limit of quantification",
            "type": "text",
            "description": "Limit of quantification reported in the unit specified by the variable Hazard unit"
          }],
          "studySample": [{
            "id": "sampleName",
            "label": "Name",
            "type": "text",
            "description": "An unambiguous ID given to the samples used in the assay"
          }, {
            "id": "samplingWeight",
            "label": "Sampling weight",
            "type": "text",
            "description": "Description of the method employed to compute sampling weight (nonresponse-adjusted weight)"
          }, {
            "id": "protocolOfSampleCollection",
            "label": "Protocol of sample collection",
            "type": "text",
            "description": "Additional protocol for sample and sample collection. Corresponds to the Protocol REF in ISA"
          }, {
            "id": "samplingStrategy",
            "label": "Sampling strategy",
            "type": "text",
            "description": "Sampling strategy (ref. EUROSTAT - Typology of sampling strategy, version of July 2009)"
          }, {
            "id": "samplingSize",
            "label": "Sampling size",
            "type": "text",
            "description": "Number of units, full participants, partial participants, eligibles, not eligible, unresolved (eligibility status not resolved)"
          }, {
            "id": "lotSizeUnit",
            "label": "Lot size unit",
            "type": "text",
            "description": "Unit in which the lot size is expressed"
          }, {
            "id": "samplingPoint",
            "label": "Sampling point",
            "type": "text",
            "description": "Point in the food chain where the sample was taken. (Doc. ESTAT/F5/ES/155 Data dictionary of activities of the establishments)"
          }, {
            "id": "samplingMethod",
            "label": "Sampling method",
            "type": "text",
            "description": "Sampling method used to take the sample"
          }, {
            "id": "typeOfSamplingProgram",
            "label": "Type of sampling program",
            "type": "text",
            "description": "Indicate the type of programm for which the samples have been collected"
          }, {
            "id": "samplingPlan",
            "label": "Sampling plan",
            "type": "text",
            "description": "Description of data collection technique: stratified or complex sampling (several stages)"
          }]
        },
        "modelMath": {
          "modelEquation": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "modelEquation": [{
              "id": "modelEquation",
              "label": "Equation",
              "type": "text",
              "description": "The pointer to the file that holds the software code (e.g. R-script)"
            }, {
              "id": "name",
              "label": "Model equation name",
              "type": "text",
              "description": "A name given to the model equation"
            }, {
              "id": "modelHypothesis",
              "label": "Hypothesis of the model",
              "description": "Description of the hypothesis of the model"
            }, {
              "id": "modelEquationClass",
              "label": "Model equation class",
              "type": "text",
              "description": "Information on that helps to categorize model equations"
            }]
          },
          "exposure": [{
            "id": "treatment",
            "label": "Left-censored data treatment",
            "description": "Description of the mathematical method to replace left-censored data (recommandation of WHO (2013), distribution or others)"
          }, {
            "id": "scenario",
            "label": "Scenario",
            "description": "Description of the different scenarios of exposure assessment"
          }, {
            "id": "uncertaintyEstimation",
            "label": "Uncertainty estimation",
            "type": "text",
            "description": "Analysis to estimate uncertainty"
          }, {
            "id": "type",
            "label": "Type of exposure",
            "type": "text",
            "description": "Description of the type of exposure"
          }, {
            "id": "contamination",
            "label": "Contam level post data treatment",
            "description": "Description of the range of of the level of contamination after left censored data treatment"
          }],
          "parameter": {
            "reference": [{
              "id": "date",
              "label": "Date",
              "type": "year_date",
              "description": "Temporal information on the publication date"
            }, {
              "id": "website",
              "label": "Website",
              "type": "text",
              "description": "A link to the publication website (different from DOI)"
            }, {
              "id": "issue",
              "label": "Issue",
              "type": "text",
              "description": "Data on the details of the issue in which the model or date has been described"
            }, {
              "id": "publicationType",
              "label": "Publication type",
              "type": "text",
              "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
            }, {
              "id": "abstract",
              "label": "Abstract",
              "type": "text",
              "description": "Abstract of the publication in which the model or the data has been described "
            }, {
              "id": "isReferenceDescription",
              "label": "Is_reference_description?",
              "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
            }, {
              "id": "title",
              "label": "Title",
              "type": "long-text",
              "description": "Title of publication in which the model or date has been described"
            }, {
              "id": "pmid",
              "label": "PubMed ID",
              "type": "text",
              "description": "The PubMed ID related to this publication"
            }, {
              "id": "volume",
              "label": "Volume",
              "type": "text",
              "description": "Data on the details of the volume in which the model or date has been described"
            }, {
              "id": "journal",
              "label": "Journal",
              "type": "long-text",
              "description": "Data on the details of the journal in which the model or date has been described"
            }, {
              "id": "authorList",
              "label": "Author list",
              "type": "long-text",
              "description": "Name and surname of the authors who contributed to this publication"
            }, {
              "id": "comment",
              "label": "Comment",
              "type": "long-text",
              "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
            }, {
              "id": "doi",
              "label": "Publication DOI",
              "type": "long-text",
              "description": "The DOI related to this publication"
            }, {
              "id": "status",
              "label": "Status",
              "type": "text",
              "description": "The status of this publication, e.g. Published, Submitted, etc."
            }],
            "parameter": [{
              "id": "subject",
              "label": "Parameter subject",
              "type": "text",
              "description": "Scope of the parameter, e.g. if it refers to an animal, a batch of animals, a batch of products, a carcass, a carcass skin etc"
            }, {
              "id": "maxValue",
              "label": "Value max",
              "type": "text",
              "description": "Numerical value of the maximum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "dataType",
              "label": "Data type",
              "type": "text",
              "description": "Information on the data format of the parameter, e.g. if it is a categorical variable: int, double, array of size x,y,z "
            }, {
              "id": "description",
              "label": "Description",
              "type": "text",
              "description": "General description of the parameter"
            }, {
              "id": "source",
              "label": "Parameter source",
              "type": "text",
              "description": "Information on the type of knowledge used to define the parameter value"
            }, {
              "id": "classification",
              "label": "Parameter classification",
              "type": "text",
              "description": "General classification of the parameter (e.g. Input, Constant, Output etc)"
            }, {
              "id": "distribution",
              "label": "Parameter distribution",
              "type": "text",
              "description": "Distribution describing the parameter variabilty. If no distribution selected this means the value provided in 'Parameter value' is a point estimate. In case a distribution is selected the value provided in 'Parameter value' is a string that the model code can parse in order to sample from the named distribution"
            }, {
              "id": "error",
              "label": "Error",
              "type": "text",
              "description": "Error of the parameter value"
            }, {
              "id": "variabilitySubject",
              "label": "Parameter variability subject",
              "type": "text",
              "description": "Information on which the variability is described. It can be variability between broiler in a flock, variability between all meat packages sold in Denmark, variability between days, etc."
            }, {
              "id": "unit",
              "label": "Unit",
              "type": "text",
              "description": "Unit of the parameter"
            }, {
              "id": "minValue",
              "label": "Value min",
              "type": "text",
              "description": "Numerical value of the minimum limit of the parameter that determines the range of applicability for which the model applies"
            }, {
              "id": "unitCategory",
              "label": "Unit category",
              "type": "text",
              "description": "General classification of the parameter unit"
            }, {
              "id": "name",
              "label": "Parameter name",
              "type": "text",
              "description": "A name given to the parameter"
            }, {
              "id": "id",
              "label": "Parameter ID",
              "type": "text",
              "description": "An unambiguous ID given to each of the parameters - preferably autogenerated by a software tool and compatible with SBML ID requirements, only letters from A to Z, numbers and '_'"
            }, {
              "id": "value",
              "label": "Value",
              "type": "text",
              "description": "A default value for the parameter. This is mandatory (needs to be provided) for all parameters of type 'Input'"
            }]
          },
          "qualityMeasures": [{
            "id": "rsquared",
            "label": "R squared",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sse",
            "label": "SSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "rmse",
            "label": "RMSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "aic",
            "label": "AIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "sensitivityAnalysis",
            "label": "Sensitivity analysis",
            "type": "long-text",
            "description": "Description of the results of an sensitivity analysis, i.e. how independence assumptions are met or how variables will affect the output of model"
          }, {
            "id": "bic",
            "label": "BIC",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }, {
            "id": "mse",
            "label": "MSE",
            "description": "Statistical values calculated to describe the performance of the model fitting procedure"
          }],
          "modelMath": [{
            "id": "fittingProcedure",
            "label": "Fitting procedure",
            "type": "text",
            "description": "Procedure used to fit the data to the model equation"
          }, {
            "id": "event",
            "label": "Event",
            "description": "Definition of time-dependent parameter changes"
          }]
        },
        "scope": {
          "populationGroup": [{
            "id": "populationRiskFactor",
            "label": "Risk and population factors",
            "description": "Population risk factor that may influence the outcomes of the study, confounder should be included"
          }, {
            "id": "country",
            "label": "Country",
            "description": "Country on which the population group of the model or data applies"
          }, {
            "id": "populationSpan",
            "label": "Population span (years)",
            "description": "Temporal information on the exposure duration"
          }, {
            "id": "populationGender",
            "label": "Population gender",
            "type": "text",
            "description": "Description of the percentage of gender"
          }, {
            "id": "populationDescription",
            "label": "Description",
            "description": "Description of the population for which the model applies (demographic and socio-economic characteristics for example). Background information that are needed in the data analysis phase, size of household, education level, employment status, professional category, ethnicity, etc."
          }, {
            "id": "populationAge",
            "label": "Population age",
            "description": "Description of the range of age or group of age"
          }, {
            "id": "patternConsumption",
            "label": "Consumption pattern",
            "description": "Description of the consumption of different food items, frequency, portion size"
          }, {
            "id": "name",
            "label": "Population name",
            "type": "text",
            "description": "Name of the population for which the model or data applies"
          }, {
            "id": "season",
            "label": "Season",
            "description": "Distribution of surveyed people according to the season (influence consumption pattern)"
          }, {
            "id": "region",
            "label": "Region",
            "description": "Spatial information (area) on which the population group of the model or data applies"
          }, {
            "id": "targetPopulation",
            "label": "Target population",
            "type": "text",
            "description": "Population of individual that we are interested in describing and making statistical inferences about"
          }, {
            "id": "bmi",
            "label": "BMI",
            "description": "Description of the range of BMI or class of BMI or BMI mean"
          }, {
            "id": "specialDietGroups",
            "label": "Special diet groups",
            "description": "Description of sub-population with special diets (vegetarians, diabetics, group following special ethnic diets)"
          }],
          "hazard": [{
            "id": "maximumResidueLimit",
            "label": "Maximum Residue Limit (MRL)",
            "type": "text",
            "description": "International regulations and permissible maximum residue levels in food and drinking water"
          }, {
            "id": "sourceOfContamination",
            "label": "Source of contamination",
            "type": "text",
            "description": "rigin of the contamination, source"
          }, {
            "id": "indSum",
            "label": "Individual or Summed Hazard",
            "type": "text",
            "description": "Define if the parameter reported is an individual residue/analyte, a summed residue definition or part of a sum a summed residue definition"
          }, {
            "id": "acceptableOperatorsExposureLevel",
            "label": "Acceptable Operator Exposure Level (AOEL)",
            "type": "text",
            "description": "Maximum amount of active substance to which the operator may be exposed without any adverse health effects. The AOEL is expressed as milligrams of the chemical per kilogram body weight of the operator"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "Description of the hazard for which the model or data applies"
          }, {
            "id": "type",
            "label": "Hazard type",
            "type": "text",
            "description": "General classification of the hazard for which the model or data applies"
          }, {
            "id": "adverseEffect",
            "label": "Adverse effect",
            "type": "text",
            "description": "Adverse effect induced by hazard about morbidity, mortality, and etcetera"
          }, {
            "id": "unit",
            "label": "Unit",
            "type": "text",
            "description": "Unit of the hazard for which the model or data applies"
          }, {
            "id": "noObservedAdverseAffectLevel",
            "label": "No Observed Adverse Affect Level (NOAEL)",
            "type": "text",
            "description": "Level of exposure of an organism, found by experiment or observation, at which there is no biologically or statistically significant increase in the frequency or severity of any adverse effects in the exposed population when compared to its appropriate control"
          }, {
            "id": "acuteReferenceDose",
            "label": "Acute Reference Dose (ARfD)",
            "type": "text",
            "description": "An estimate (with uncertainty spanning perhaps an order of magnitude) of a daily oral exposure for an acute duration (24 hours or less) to the human population (including sensitive subgroups) that is likely to be without an appreciable risk of deleterious effects during a lifetime"
          }, {
            "id": "name",
            "label": "Hazard name",
            "type": "text",
            "description": "Name of the hazard (agent, contaminant, chemical) for which the data or model applies"
          }, {
            "id": "lowestObservedAdverseAffectLevel",
            "label": "Lowest Observed Adverse Effect Level (LOAEL)",
            "type": "text",
            "description": "Lowest concentration or amount of a substance found by experiment or observation that causes an adverse alteration of morphology, function, capacity, growth, development, or lifespan of a target organism distinguished from normal organisms of the same species under defined conditions of exposure"
          }, {
            "id": "benchmarkDose",
            "label": "Benchmark Dose (BMD)",
            "type": "text",
            "description": "A dose or concentration that produces a predetermined change in response rate of an adverse effect (called the benchmark response or BMR) compared to background"
          }, {
            "id": "acceptableDailyIntake",
            "label": "Acceptable Daily Intake (ADI)",
            "type": "text",
            "description": "Measure of amount of a specific substance in food or in drinking water tahta can be ingested (orally) on a daily basis over a lifetime without an appreciable health risk"
          }],
          "scope": [{
            "id": "spatialInformation",
            "label": "Spatial information",
            "description": "Spatial information (area) on which the model or data applies"
          }, {
            "id": "generalComment",
            "label": "General comment",
            "type": "long-text",
            "description": "General comments on the scope of the study, data or model"
          }, {
            "id": "temporalInformation",
            "label": "Temporal information",
            "type": "long-text",
            "description": "Temporal information on which the model or data applies / An interval of time that is named or defined by its start and end dates (period of study)"
          }]
        },
        "generalInformation": {
          "creator": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "author": [{
            "id": "country",
            "label": "Country",
            "type": "text",
            "description": "Full name of the country in English"
          }, {
            "id": "zipCode",
            "label": "Zip code",
            "type": "text",
            "description": "Postal code"
          }, {
            "id": "note",
            "label": "Note",
            "type": "text",
            "description": "Supplemental information or a comment"
          }, {
            "id": "gender",
            "label": "Gender",
            "type": "text",
            "description": "Sex and gender identity. M (male), F (female), O (other), N (none or not applicable) and U (unknown)"
          }, {
            "id": "givenName",
            "label": "Given name",
            "type": "long-text",
            "description": "Given name"
          }, {
            "id": "timeZone",
            "label": "Timezone",
            "type": "text",
            "description": "Time zone"
          }, {
            "id": "telephone",
            "label": "Telephone",
            "type": "text",
            "description": "The canonical number string for a telephone number for telephony communication."
          }, {
            "id": "title",
            "label": "Title",
            "type": "text",
            "description": "Specifies the job title, functional position or function of the individual associated."
          }, {
            "id": "streetAddress",
            "label": "Address",
            "type": "text",
            "description": "Physical delivery address"
          }, {
            "id": "familyName",
            "label": "Family name",
            "type": "long-text",
            "description": "Family name or surname."
          }, {
            "id": "organization",
            "label": "Organization",
            "type": "long-text",
            "description": "Organization information"
          }, {
            "id": "region",
            "label": "Region",
            "type": "text",
            "description": "State or province"
          }, {
            "id": "email",
            "label": "Email",
            "type": "email",
            "description": "The address for electronic mail communication."
          }],
          "reference": [{
            "id": "date",
            "label": "Date",
            "type": "year_date",
            "description": "Temporal information on the publication date"
          }, {
            "id": "website",
            "label": "Website",
            "type": "text",
            "description": "A link to the publication website (different from DOI)"
          }, {
            "id": "issue",
            "label": "Issue",
            "type": "text",
            "description": "Data on the details of the issue in which the model or date has been described"
          }, {
            "id": "publicationType",
            "label": "Publication type",
            "type": "text",
            "description": "The type of publication, e.g. Report, Journal article, Book, Online database, ... "
          }, {
            "id": "abstract",
            "label": "Abstract",
            "type": "text",
            "description": "Abstract of the publication in which the model or the data has been described "
          }, {
            "id": "isReferenceDescription",
            "label": "Is_reference_description?",
            "description": "Indicates whether this specific publication serves as the reference description for the model. There has to be at least one reference where this field is set to 'True'"
          }, {
            "id": "title",
            "label": "Title",
            "type": "long-text",
            "description": "Title of publication in which the model or date has been described"
          }, {
            "id": "pmid",
            "label": "PubMed ID",
            "type": "text",
            "description": "The PubMed ID related to this publication"
          }, {
            "id": "volume",
            "label": "Volume",
            "type": "text",
            "description": "Data on the details of the volume in which the model or date has been described"
          }, {
            "id": "journal",
            "label": "Journal",
            "type": "long-text",
            "description": "Data on the details of the journal in which the model or date has been described"
          }, {
            "id": "authorList",
            "label": "Author list",
            "type": "long-text",
            "description": "Name and surname of the authors who contributed to this publication"
          }, {
            "id": "comment",
            "label": "Comment",
            "type": "long-text",
            "description": "Further comments related to the reference description, e.g. which section in there describes the specific model or which figure in there can be reproduced with the visualization script"
          }, {
            "id": "doi",
            "label": "Publication DOI",
            "type": "long-text",
            "description": "The DOI related to this publication"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The status of this publication, e.g. Published, Submitted, etc."
          }],
          "modelCategory": [{
            "id": "modelClassComment",
            "label": "Comment",
            "type": "long-text",
            "description": "Comment with further details on the model class"
          }, {
            "id": "basicProcess",
            "label": "Basic process",
            "description": "Defines the impact of the process on the hazard (so far only valid for process models and predictive models)"
          }, {
            "id": "modelClass",
            "label": "Model class",
            "type": "text",
            "description": "Type of model according to RAKIP classification"
          }, {
            "id": "modelSubClass",
            "label": "Subclass",
            "description": "Sub-classification of the model given the Model Class"
          }],
          "generalInformation": [{
            "id": "identifier",
            "label": "Identifier",
            "type": "text",
            "description": "An unambiguous ID given to the model or data. This can also be created automatically by a software tool"
          }, {
            "id": "software",
            "label": "Software",
            "type": "text",
            "description": "The program or software language in which the model has been implemented"
          }, {
            "id": "format",
            "label": "Format",
            "type": "text",
            "description": "File extension of the model or data file (including version number of format if applicable)"
          }, {
            "id": "description",
            "label": "Description",
            "type": "long-text",
            "description": "General description of the study, data or model"
          }, {
            "id": "language",
            "label": "Language",
            "type": "text",
            "description": "A language of the resource (some data or reports can be available in French language for example)"
          }, {
            "id": "source",
            "label": "Source",
            "type": "text",
            "description": "A source from which the model/data is derived"
          }, {
            "id": "availability",
            "label": "Availability",
            "type": "text",
            "description": "Availability of data or model, i.e. if the annotated model code / data is included in this FSK file"
          }, {
            "id": "creationDate",
            "label": "Creation date",
            "type": "date",
            "description": "Creation date/time of the FSK file"
          }, {
            "id": "url",
            "label": "URL",
            "type": "text",
            "description": "Web address referencing the resource location (data for example)"
          }, {
            "id": "objective",
            "label": "Objective",
            "type": "long-text",
            "description": "Objective of the model or data"
          }, {
            "id": "modificationDate",
            "label": "Modification date",
            "description": "Date/time of the last version of the FSK file"
          }, {
            "id": "rights",
            "label": "Rights",
            "type": "text",
            "description": "Rights granted for usage, distribution and modification of this FSK file"
          }, {
            "id": "name",
            "label": "Name",
            "type": "text",
            "description": "A name given to the model or data"
          }, {
            "id": "languageWrittenIn",
            "label": "Language written in",
            "type": "text",
            "description": "Software language used to write the model, e.g. R or MatLab"
          }, {
            "id": "status",
            "label": "Status",
            "type": "text",
            "description": "The curation status of the model"
          }]
        }
      };
    }
    // Validate this.panels and return boolean
  }, {
    key: "validate",
    value: function validate() {
      var isValid = true;
      if (!this.panels.generalInformation.validate()) isValid = false;
      if (!this.panels.modelCategory.validate()) isValid = false;
      if (!this.panels.scopeGeneral.validate()) isValid = false;
      if (!this.panels.study.validate()) isValid = false;
      return isValid;
    }
  }, {
    key: "_createPanels",
    value: function _createPanels() {
      var port = window.port || -1;
      var schema = schemas.genericModel;
      return _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
        study: new _FormPanel.FormPanel("Study", this.jsonSchema.dataBackground.study, this._metadata.dataBackground ? this._metadata.dataBackground.study : {}, port),
        laboratory: new _TablePanel.TablePanel("Laboratory", this.jsonSchema.dataBackground.laboratory, this._metadata.dataBackground ? this._metadata.dataBackground.laboratory : {}, port),
        assay: new _TablePanel.TablePanel("Assay", this.jsonSchema.dataBackground.assay, this._metadata.dataBackground ? this._metadata.dataBackground.assay : {}, port),
        studySample: new _TablePanel.TablePanel("Study Sample", this.jsonSchema.dataBackground.studySample, this._metadata.dataBackground ? this._metadata.dataBackground.studySample : {}, port),
        modelMath: new _FormPanel.FormPanel("Model Math", this.jsonSchema.modelMath.modelMath, this._metadata.modelMath, port),
        modelEquation: new _TablePanel.TablePanel("Model Equation", this.jsonSchema.modelMath.modelEquation.modelEquation, this._metadata.modelMath ? this._metadata.modelMath.modelEquation : {}, port),
        reference: new _TablePanel.TablePanel("Reference", this.jsonSchema.modelMath.modelEquation.reference, this._metadata.modelMath.modelEquation ? this._metadata.modelMath.modelEquation.reference : {}, port),
        exposure: new _TablePanel.TablePanel("Exposure", this.jsonSchema.modelMath.exposure, this._metadata.modelMath ? this._metadata.modelMath.exposure : {}, port),
        parameter: new _TablePanel.TablePanel("Parameter", this.jsonSchema.modelMath.parameter.parameter, this._metadata.modelMath ? this._metadata.modelMath.parameter : {}, port)
      }, "reference", new _FormPanel.FormPanel("Reference", this.jsonSchema.modelMath.parameter.reference, this._metadata.modelMath.parameter ? this._metadata.modelMath.parameter.reference : {}, port)), "qualityMeasures", new _TablePanel.TablePanel("Quality Measures", this.jsonSchema.modelMath.qualityMeasures, this._metadata.modelMath ? this._metadata.modelMath.qualityMeasures : {}, port)), "scope", new _FormPanel.FormPanel("Scope", this.jsonSchema.scope.scope, this._metadata.scope, port)), "populationGroup", new _TablePanel.TablePanel("Population Group", this.jsonSchema.scope.populationGroup, this._metadata.scope ? this._metadata.scope.populationGroup : {}, port)), "hazard", new _TablePanel.TablePanel("Hazard", this.jsonSchema.scope.hazard, this._metadata.scope ? this._metadata.scope.hazard : {}, port)), "generalInformation", new _FormPanel.FormPanel("General Information", this.jsonSchema.generalInformation.generalInformation, this._metadata.generalInformation, port)), "creator", new _TablePanel.TablePanel("Creator", this.jsonSchema.generalInformation.creator, this._metadata.generalInformation ? this._metadata.generalInformation.creator : {}, port)), "author", new _TablePanel.TablePanel("Author", this.jsonSchema.generalInformation.author, this._metadata.generalInformation ? this._metadata.generalInformation.author : {}, port)), "reference", new _TablePanel.TablePanel("Reference", this.jsonSchema.generalInformation.reference, this._metadata.generalInformation ? this._metadata.generalInformation.reference : {}, port)), "modelCategory", new _FormPanel.FormPanel("Model Category", this.jsonSchema.generalInformation.modelCategory, this._metadata.generalInformation ? this._metadata.generalInformation.modelCategory : {}, port));
    }
  }]);
}(_ModelView2.ModelView);

},{"../ApiClient":44,"../app/APPModal.js":48,"../app/APPTable.js":52,"../app/APPTableMT.js":53,"../app/ArrayForm.js":55,"../app/Dialog.js":56,"../app/EventObserver.js":57,"../app/FormPanel.js":58,"../app/InputForm.js":59,"../app/SelectForm.js":60,"../app/SimpleTable.js":61,"../app/TablePanel.js":62,"../app/TextareaForm.js":63,"./GenericModelModelMathView":101,"./ModelView":118,"./PredictiveModelDataBackgroundView":135,"./PredictiveModelGeneralInformationView":137,"./ToxicologicalModelScopeView":165}]},{},[64])(64)
});
